---
title: 「训」 笔记(8)：微服务框架
category_bar: true
date: 2023-04-11 15:48:43
tags:
categories: 字节青训
banner_img:
---

微服务框架 —— 不变的基建

<!-- more -->

## 1 微服务架构介绍

### 1.1 系统架构的演进历史

![演变历史](1.png)

* 单体架构：All in one process
* 垂直应用架构：按照业务线垂直划分
* 分布式架构：抽出与业务无关的公共模块
* SOA 架构：面向服务
* 微服务架构：彻底的服务化

### 1.2 微服务架构概览

![架构](2.png)

### 1.3 微服务架构的三大要素

* 服务治理：服务注册、服务发现、负载均衡、扩缩容、流量治理、稳定性治理

* 可观测性：日志采集、日志分析、监控打点、监控大盘、异常报警、链路追踪

* 安全：身份验证、认证授权、访问令牌、审计、传输加密、黑产攻击

## 2 微服务架构原理及特征

### 2.1 基本概念及组件

![基本概念](3.png)

* **服务**（service）：一组具有相同逻辑的运行实体

* **实例**（instance）：一个服务中的每个运行实体都为一个实例

* **集群**（cluster）：通常指服务内部的逻辑划分，包含多个实例

* 实例与进程的关系：没有必然对应关系，一般一对一或者一对多

* 常见的实例承载形式：进程、VM、k8s pod ...

### 2.2 服务间通信

对于单体服务，不同模块通信只是简单的函数调用。
微服务之间通过网络进行通信，常见的通信协议包括 HTTP、RPC。

![通信](4.png)

### 2.3 服务注册及服务发现

**基本问题**：服务间调用中，如何指定下游服务实例的地址？

**简单方案**：

  * 直接指定 ip:port

    ![Hardcode](5.png)

    * 没有任何动态能力
    * 有多个实例下游实例怎么办？

  * 使用 DNS

    ![DNS](6.png)

    * 本地 DNS 存在缓存，导致延迟
    * DNS 没有负载均衡
    * 不支持服务探活检查
    * DNS 不能指定端口

**服务注册发现**

![服务注册中心](7.png)

  * 新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系
  * 旧服务实例下线前，从服务注册中心删除该实例，下线流量
  * 新服务实例上线后，在服务注册中心注册该实例，上线流量

**微服务流量特征**

![流量特征](8.png)

  * 统一网关入口
  * 外网通信多数采用 HTTP，内网通信多数采用 RPC（Thrift, gRPC）

## 3 核心服务治理功能

### 3.1 服务发布

服务发布（deployment）是让一个服务升级运行新的代码的过程。

**难点**：服务不可用、服务抖动、服务回滚

**蓝绿部署**

![蓝绿部署](9.png)

  * 将服务分成两个部分，分别先后发布
  * 简单、稳定
  * 但需要两倍资源

**灰度发布（金丝雀发布）**

![灰度发布](10.png)

  * 先发布少部分实例，接着逐步增加发布比例
  * 不需要增加资源
  * 回滚难度大，基础设施要求高

### 3.2 流量治理

流量控制是在微服务架构中，可以从各个维度对端到端的流量在链路上进行精确控制。

控制维度：地区维度、集群维度、实例维度、请求维度

![流量治理](11.png)

### 3.3 负载均衡

负载均衡（Load Balance）负责分配请求在每个下游实例上的分布。

常见 LB 策略：
* Round Robin
* Random
* Ring Hash
* Least Request

### 3.4 稳定性治理

线上服务总是会出问题的，这与程序的正确性无关。

* 限流：限制服务处理的最大 QPS，拒绝过多请求。

* 熔断：中断请求路径，增加冷却时间从而让故障实例尝试恢复。

* 过载保护：在负载高的实例中，主动拒绝一部分请求，防止实例被打挂。

* 降级：服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求。

## 4 字节跳动服务治理实践

### 4.1 重试的意义

本地函数调用：通常没有重试意义。

远程函数调用：网络抖动、下游负载高、下游机器宕机... 重试是有意义的，可以避免偶发性的错误，提高 SLA（Service-Level Agreement）。

**意义**：

* 降低错误率
  * 假设单次请求的错误概率为0.01，那么连续两次错误概率则为0.0001。
* 降低长尾延时
  * 对于偶尔耗时较长的请求，重试请求有机会提前返回。
* 容忍暂时性错误
  * 某些时候系统会有暂时性异常（例如网络抖动），重试可以尽量规避。
* 避开下游故障实例
  * 一个服务中可能会有少量实例故障（例如机器故障），重试其他实例可以成功。

### 4.2 重试的难点

* 幂等性：多次请求可能会造成数据不一致。

* 重试风暴：随着调用链路的增加，重试次数呈指数级上升。

![重试风暴](12.png)

* 超时设置：假设调用时间一共 1s，经过多少时间开始重试？

### 4.3 重试的策略

* 限制重试比例：设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值。

* 防止链路重试：返回特殊的 status code，表示“请求失败，但别重试”。

* Hedged Requests：对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应。

![Hedged Requests](13.png)