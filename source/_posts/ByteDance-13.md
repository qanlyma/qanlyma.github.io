---
title: 「训」 Q & A
category_bar: true
date: 2023-07-15 19:20:30
tags:
categories: 字节青训
banner_img:
---

思考和总结的一些问题。

<!-- more -->

## Go 语言

#### Q：make 和 new 方法有什么区别

* make 用于初始化内置的数据结构，如数组、切片和 Channel 等。
* new 用于分配并创建一个指向对应类型的指针。

## 计算机网络

#### Q：HTTP 协议

是用于 web 服务器和本地浏览器之间传输文件的传输协议。

是一个基于请求与响应模式的、无状态的、应用层的协议。

是一个基于 TCP/IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）的协议。

HTTP 协议工作于客户端-服务端架构之上。浏览器作为 HTTP 客户端通过 URL，向 HTTP 服务端，即 web 服务器发送所有请求。web 服务器根据接收到的请求，向客户端发送响应信息。

#### Q：HTTP 工作流程

1. 客户端与服务器建立 TCP 连接。
2. 客户端向服务器发出请求。
3. 服务器接收到客户端的请求，根据请求返回响应内容。
4. 客户端接收服务器的响应内容，解析内容在前端展示，然后客户端与服务器断开连接。

#### Q：HTTP 协议特点

1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
2. 灵活: HTTP 允许传输任意类型的数据对象。
3. 无状态：协议对于事务处理没有记忆能力，如果后续处理需要前面的信息，则它必须重传。
4. 无连接的：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。
5. 支持 B/S 及 C/S 模式。
6. 默认端口 80。
7. 基于 TCP/IP 通信协议。

#### Q：Cookie 和 Session 的区别

* Cookie 是浏览器支持的一种本地存储机制。一般由服务端设置生成，在响应请求时被自动存储在浏览器中，用于辨别用户身份。
* 创建 Session 的时候， 服务端会在 http 协议中告诉客服端，需要在 Cookie 里记录一个 sessionid, 以后每次请求把这个 id 发送到服务器，就知道用户身份了。

**区别**： 

1. 存储位置：Cookie 是存储在客户端（浏览器）中的小型文本文件，而 Session 是存储在服务器上的数据结构。

2. 数据存储：Cookie 通常包含少量的用户数据，以键值对的形式存储在客户端。Session 可以存储更多的用户数据，可以包含复杂的对象和数据结构。

3. 安全性：Cookie 存储在客户端，可以被客户端修改或者删除。因此，对于敏感信息，需要谨慎处理。Session 数据存储在服务器端，相对来说更安全，客户端无法直接访问或修改。

4. 生命周期：Cookie 可以设置过期时间，可以在客户端存储一段时间，并在之后仍然有效。Session 通常在用户关闭浏览器或一段时间不活动后过期，或者通过在服务器上设置超时时间来控制。

5. 存储方式：Cookie 通过在 HTTP 响应头中的 Set-Cookie 字段发送给客户端，客户端将其存储在本地。之后，每次请求中都会通过 Cookie 头字段将 Cookie 发送回服务器。Session 通过在服务器上创建唯一的标识符（通常是会话 ID）来跟踪用户会话，并将该标识符存储在 Cookie 中或通过 URL 重写传递给客户端。

#### Q：什么是跨站脚本攻击 XSS 和 HttpOnly

XSS 是跨站脚本攻击（Cross Site Scripting）。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，Script 代码会被执行从而达到恶意攻击用户的目的。如，盗取用户 Cookie、破坏页面结构、重定向到其它网站（流量劫持）等。

HttpOnly 是一个标记，用于设置 HTTP Cookie 的属性。当设置了 HttpOnly 属性后，浏览器将限制该 Cookie 只能通过 HTTP 或 HTTPS 协议进行传输，禁止通过脚本（如 JavaScript）访问该 Cookie。

HttpOnly 属性的作用是增加 Web 应用程序的安全性，防止跨站脚本攻击（XSS）的一种方式。


#### Q：GET 和 POST 的区别

* GET 重点在从服务器上获取资源，一般用于获取/查询资源信息。是无副作用的，是幂等的，且可缓存。
* POST 重点在向服务器发送数据，一般用于更新资源信息。有副作用，非幂等，不可缓存。
* POST 比 GET 安全性更高。Get 通过 URL 来传输数据，因为 URL 是可见的，可能会泄露私密信息，如密码等。POST 通过 URL 和请求体 requrest body 传输数据，将字段与对应值封存在请求体中发送给服务器。在请求体中的数据，我们是无法直接观测到的。

#### Q：浏览器输入一个 URL 之后，网络各层发生了什么

1. 浏览器输入 URL，若协议为 HTTP：
2. 应用层 DNS 解析，返回对应的 ip 地址（DNS 协议，DNS 服务器是基于 UDP 的）
3. 应用层客户端发送 HTTP 请求（HTTP 协议）
4. 传输层传输报文建立 TCP 连接三次握手（TCP 协议）
5. 网络层 ip 查询 mac 地址（IP 协议，ARP 协议）
6. 数据到达数据链路层 
7. 物理层：物理传输 bit
8. 服务器发送 HTTP 响应报文。
9. 关闭连接，TCP 四次挥手
10. 客户端解析 HTTP 响应报文，浏览器开始显示 HTML

#### Q：HTTP 和 HTTPS 的区别

* HTTP 协议是以明文的方式在网络中传输数据，而 HTTPS 协议传输的数据则是使用密钥进行加密（经过 SSL/TLS 加密）的，所以 HTTPS 具有更高的安全性。
* HTTPS 部署成本高，HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买CA证书。
* HTTPS 握手阶段延时较高：HTTPS 在 TC P三次握手阶段之后，还需要进行 SSL/TLS 的握手。
* 由于采用 HTTPS 协议需要进行加解密的计算，占用 CPU 资源较多。

#### Q：TCP 怎么保证可靠性

* 校验和
* 序列号
* 确认应答
* 超时重传
* 连接管理
* 流量控制：滑动窗口机制基于接收方的反馈信息来动态调整发送方的发送速率
* 拥塞控制：慢启动、拥塞避免、快速重传、超时重传

#### Q：长连接与短连接的区别

长连接，也叫持久连接，在 TCP 层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息交互，直至连接的任意一方（客户端 OR 服务端）主动断开连接，此过程称为一次完整的长连接。

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，增加了通信开销。HTTP/1.1 最重要的新特性就是引入了长连接。

短连接，客户端收到服务端的响应后，立刻发送 FIN 消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互之后立刻断开连接的情况都称为短连接。

#### Q：Socket 套接字

Socket 套接字是在应用层和传输层之间的一个抽象层，用于实现应用程序之间的网络通信。它提供了一种编程接口，允许应用程序通过网络进行数据传输。

在网络通信中，Socket 套接字通过使用网络协议栈中的传输层协议（如 TCP 或 UDP）来实现数据的可靠传输或不可靠传输。只需要指定主机的 IP 地址，和一个端口号。

Socket 套接字是在操作系统内核中实现的，它负责处理网络通信的细节，如建立连接、数据的发送和接收、错误处理等。应用程序可以使用 Socket API（如套接字函数）来创建、配置和控制 Socket 套接字，从而实现网络通信。

#### Q：IPv4 和 IPv6 

* IPv4 是目前广泛使用的IP协议版本。它使用32位地址，通常表示为**点分十进制**格式（例如，192.168.0.1）。

* IPv6 是为了解决 IPv4 地址空间不足的问题而设计的下一代 IP 协议。IPv6 使用 128 位地址，通常表示为**冒号分隔的十六进制**格式（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。

#### Q：负载均衡

负载均衡是一种在计算机网络中分配工作负载（请求或流量）到多个服务器的技术。它旨在提高系统的性能、可扩展性和可靠性，通过均衡分配负载来避免单个服务器过载或故障引起的性能下降。

实现负载均衡的一种常见方法是通过负载均衡器（Load Balancer）。负载均衡器是位于客户端和服务器之间的网络设备或软件，它接收来自客户端的请求，并将这些请求分发到一组后端服务器上，以实现负载的均衡。

* Nginx 是七层（即应用层）负载均衡器 ，这意味着如果它要转发流量首先得和 client 建立一个 TCP 连接，并且转发的时候也要与转发到的上游 server 建立一个 TCP 连接，而我们知道建立 TCP 连接其实是需要耗费内存（TCP Socket，接收/发送缓存区等需要占用内存）的。所以 Nginx 的负载能力受限于机器 I/O，CPU 内存等一系列配置，一旦连接很多（比如达到百万）的话，Nginx 抗负载能力就会急剧下降。

* LVS 是四层（传输层）负载均衡器，LVS 只是单纯地转发包，不需要和上下游建立连接，相比于 Nginx 它的抗负载能力强、性能高，对内存和 cpu 资源消耗比较低。负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过负载均衡算法选择一个最佳的服务器，并对报文中目标 IP 地址进行修改（改为后端服务器 IP），直接转发给该服务器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。

## 数据库

#### Q：索引

数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B+ 树。

#### Q：索引的类型

* 普通索引（INDEX）：这是最基本的索引，它没有任何限制。
* 唯一索引（UNIQUE）：避免同一个表中某数据列中的值重复。
  * 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 
  * 与主键索引的区别：主键索引只能有一个，唯一索引可有多个。
* 主键索引（PRIMAY KEY）：特殊的唯一索引，不允许有空值。一个表只能有一个主键。 
* 联合索引
* 全文索引（FULLTEXT）：快速定位特定数据。

#### Q：为什么说 B+ 树更适合数据库索引

* B+ 树的磁盘读写代价更低：B+ 树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对 B 树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 IO 读写次数就降低了。

* B+ 树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

* B+ 树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是 B 树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 B+ 树更加适合在区间查询的情况，所以通常 B+ 树用于数据库索引。
















## Linux

#### Q：用户态和内核态有什么区别

通过系统调用将 Linux 整个体系分为用户态和内核态（或者说内核空间和用户空间）。

* 内核态是操作系统内核运行的一种模式，其中操作系统内核具有最高的特权级别和完全访问系统资源的权限。例如协调 CPU 资源，分配内存资源，并且提供稳定的环境供应用程序运行。
* 用户态是应用程序运行的一种模式，其中应用程序以及用户编写的代码在用户空间运行，无法直接访问或操作底层硬件设备和操作系统内核。

用户态的应用程序运行在操作系统提供的虚拟地址空间中，通过系统调用向内核请求服务和资源。

从用户态到内核态切换可以通过三种方式：

1. 系统调用：其实系统调用本身就是中断，但是软件中断，跟硬中断不同。
2. 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。
3. 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。

#### Q：kill -15 和 kill -9 的区别

* kill -9 PID 是操作系统从内核级别强制杀死一个进程。
* kill -15 PID 可以理解为操作系统发送一个通知告诉应用主动关闭。

因为 kill -15 信号只是通知对应的进程要进行"安全、干净的退出"，程序接到信号之后，退出前一般会进行一些"准备工作"，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。但是，如果在"准备工作"进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。这也就是为什么我们有的时候使用 kill 命令是没办法"杀死"应用的原因，因为默认的 kill 信号是 SIGTERM（15），而 SIGTERM（15）的信号是可以被阻塞和忽略的。和 kill -15 相比， kill -9 就相对强硬一点，系统会发出 SIGKILL 信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。所以，相比于 kill -15 命令，kill -9 在执行时，应用程序是没有时间进行"准备工作"的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。

#### Q：前台进程和后台进程区别

* 前台进程：是在终端中运行的命令，那么该终端就为进程的控制终端，一旦这个终端关闭，这个进程也随之消失。
* 后台进程：也叫守护进程（Daemon），是运行在后台的一种特殊进程，不受终端控制，它不需要终端的交互；Linux 的大多数服务器就是使用守护进程实现的。

#### Q：awk 命令

数据过滤工具 (类似于 grep，比 grep 强大)，属数据处理引擎，基于模式匹配检查输入文本，逐行处理并输出。通常用在 Shell 脚本中，获取指定的数据，单独使用时，可对文本数据做统计。

#### Q：scp 命令

在 linux 下 scp 命令主要用来在不同主机之间做数据的安全拷贝的。scp 命令使用安全加密的协议，所以在远程拷贝数据的时候会比较安全，不会被黑客截取。

#### Q：shell 脚本

第一行一定是 `#!/bin/bash` 它代表的意思是，该文件使用的是 bash 语法。如果不设置该行，那么你的 shell 脚本就不能被执行。

定义变量的格式为 `变量名=变量的值`。当在脚本中引用变量时需要加上 `$` 符号。

数学计算要用 '[]' 括起来并且外头要带一个 `$`。

## 测开

#### Q：软件生命周期的六个阶段

计划、需求、设计、编码、测试、运行与维护。

1. 问题定义及规划阶段：主要确定软件的开发目的及其可行性，制定开发计划。
2. 需求分析/评审阶段：在确定软件开发可行的情况下，将对软件需要实现的每个功能进行详细分析。
3. 软件设计阶段：在此阶段，将根据需求分析的结果来设计整个软件系统，例如系统框架设计，数据库设计等。软件设计一般分为总体设计和详细设计。
4. 软件编码阶段：开发人员任务、程序员编码。
5. 软件测试阶段：测试工程师的任务或开发的任务。
6. 软件运行维护阶段：版本、产品上线（版本的升级改进）BUG 的修复。

#### Q：介绍一下单元测试、集成测试、系统测试、验收测试、回归测试

* 单元测试：测试编码是否符合设计要求。软件中最小的测试单元，比如 go 中的一个函数。相关单元测试放在一起就是一个模块。
* 集成测试：就是接口测试，对接口是否能够实现进行测试，对接口实现后的结果进行测试。在单元测试的基础上将所有模块按照要求设计组装。测试不同模块之间是否按照预期工作，比如不同模块之间的数据传输。
* 系统测试：系统测试就是对可视化图形界面测试，对整个系统功能进行测。是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。
* 验收测试：验收测试就是模拟客户进行测试，确保软件各部分功能正常运行。确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括 Alpha 测试和 Beta 测试。
* 回归测试：在缺陷修复之后的检验测试，指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。

#### Q：黑盒测试和白盒测试

* 白盒测试又称为结构测试、逻辑驱动测试或基于程序本身的测试，着重于程序的内部结构及算法，通常不关心功能与性能指标。
  * 逻辑覆盖测试：语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖、路径覆盖
  * 基本路径覆盖测试：选择足够的测试用例，使得运行这些测试用例时，被测程序的每条可能执行的路径都至少经过一次。
* 黑盒测试又称为功能测试、数据驱动测试或基于规格说明的测试，实际上是站在最终用户的立场上，检验输入输出信息及系统性能指标是否符合规格说明书中有关功能需求及性能需求的规定。
  * 等价类划分法：主要解决穷举的问题
  * 边界值分析法：选取正好等于、刚好大于、刚好小于边界的值作为测试数据

#### Q：冒烟测试

确保开发人员修复了 bug 后，这个 bug 的修复没有影响到其他功能模块。

#### Q：接口测试

接口测试其实最主要的验证接口逻辑，可用性，边界值，异常检查。

主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。

#### Q：为什么要做接口测试

1. 现在很多系统前后端架构是分离的，因为不同端的工作进度不一样，所以我们要针对最开始出来的接口，以及需要调用其他公司的一些接口进行接口测试及验证数据。
2. 如今系统越来越复杂，传统的靠前端测试已经大大降低了效率，而且现在都推崇测试前移也叫测试左移，希望测试能更早的介入，那接口测试就是一种及早介入的方式。

#### Q：接口的组成

接口说明、调用 url（请求的地址）、请求方法（get/post）、请求参数、参数类型、参数说明。

#### Q：性能测试

测试软件性能方面的质量，它是一种非功能性的测试。

在整个测试中，应用程序的性能在预期的或更高的负载下进行评估。评估系统的不同性能属性，如响应时间（速度）、吞吐量、可靠性、资源使用率、可扩展性等。监控系统的各项指标，是否符合需求，如果不符合，就发现了系统的性能瓶颈。

   * 负载测试：通过在被测系统上不断加压（如逐渐增加模拟用户的数量），直到性能指标达到极限，来观察不同负载下系统的响应时间和数据吞吐量、系统占用的资源（如 CPU、内存）等。
   * 压力测试：系统在强负载下的测试，例如 CPU、内存在饱和使用情况下，看系统在峰值使用情况下是否稳定，看系统处理会话的能力以及哪里会出问题。
   * 容量测试：通过测试预先分析出系统某项指标的极限值（如最大并发用户数、数据库记录数等）。
   * 并发测试：模拟多用户并发访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题。
   * 配置测试：通过对被测系统软硬件环境的调整，了解各种不同环境对系统性能影响的程度，从而找到系统各项资源的最优分配原则。
   * 可靠性测试(持久性测试)：给系统施加一定的业务压力，让其持续运行一段时间，测试在这种条件下能否稳定运行。

#### Q：性能测试常用指标

并发数、响应时间、吞吐量、资源利用率。

#### Q：测试用例八大要素

编号、标题、模块、前置条件、优先级、测试步骤、测试数据、预期结果。














