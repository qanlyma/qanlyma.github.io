---
title: 「训」 Q & A
category_bar: true
date: 2023-07-15 19:20:30
tags:
categories: 字节青训
banner_img:
---

思考和总结的一些问题。

<!-- more -->

## Go 语言

#### Q：make 和 new 方法有什么区别

* make 用于初始化内置的数据结构，如数组、切片和 Channel 等。
* new 用于分配并创建一个指向对应类型的指针。

#### Q：Go 当中同步锁有什么特点，作用是什么

Go 语言中的同步锁是一种机制，用于控制对共享资源的访问，以确保在同一时间只有一个协程（goroutine）可以访问该资源。同步锁的作用是防止多个协程同时对共享资源进行修改，从而避免数据竞争和不一致的结果。

#### Q：使用 Channel 时需要注意什么

* 当尝试从一个 nil 的通道接收数据时，会导致程序的阻塞。
* 如果向 nil 的通道发送数据，会导致程序运行时恐慌（panic）。
* 当从一个已关闭的通道接收数据时，会立即获得通道中的零值。
* 如果向已经关闭的通道发送数据，会导致程序运行时恐慌（panic）。

#### Q：Go 语言当中 Channel 缓冲有什么特点

无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的。

#### Q：Printf(), Sprintf(), 和 Fprintf() 有什么不同

* Printf() 函数用于将格式化的字符串输出到标准输出（控制台）。
* Sprintf() 函数将格式化的字符串保存到一个字符串变量中，而不是输出到标准输出。
* Fprintf() 函数用于将格式化的字符串输出到指定的 io.Writer 接口（文件）。

#### Q：数组和切片的区别

* 固定长度 vs 可变长度：数组具有固定长度，定义时需要指定其长度，而且长度在数组的整个生命周期中保持不变。切片则是对数组的一个动态窗口或视图，长度可以动态改变。

* 值类型 vs 引用类型：数组是值类型，直接存储数据本身。对数组进行赋值或传递给函数时，会进行值的拷贝。切片是引用类型，实际上是对底层数组的引用。对切片进行赋值或传递给函数时，会共享底层数组，而不进行拷贝。
  * 值传递只会把参数的值复制一份放进对应的函数，两个变量的地址不同，不可相互修改。
  * 地址传递（引用传递）会将变量本身传入对应的函数，在函数中可以对该变量进行值内容的修改。

* 内存管理：数组在内存中是连续存储的，大小固定，不会随着元素的增加而改变。切片通过指针引用底层数组，可以动态增长和缩减，当切片的长度超过底层数组的容量时，会重新分配更大的底层数组。

#### Q：defer 的作用和特点是什么

defer 是一个用于延迟执行函数调用的关键字。它可以将一个函数或方法的执行推迟到当前函数返回之前或所在的代码块执行结束之前。

defer 常用于资源的释放和清理操作，如关闭文件、释放锁、释放数据库连接等。通过将资源释放操作延迟执行，可以确保在函数退出之前进行必要的清理，无论函数是正常返回还是异常退出。

当有多个 defer 语句出现时，它们的执行顺序类似于栈（先进后出）的方式。也就是说，最后一个推迟的函数调用将最先执行，而第一个推迟的函数调用将最后执行。

#### Q：扩容前后的切片是否相同

切片的容量足够则相同。

当切片的容量不足以容纳新增的元素时，Go 语言会自动扩容切片。扩容的过程中，Go 语言会重新分配一个更大的底层数组，并将原始切片中的元素复制到新的底层数组中。由于底层数组的改变，扩容前后的切片实际引用了不同的底层数组，因此它们是不相同的。























## 计算机网络

#### Q：HTTP 协议

是用于 web 服务器和本地浏览器之间传输文件的传输协议。

是一个基于请求与响应模式的、无状态的、应用层的协议。

是一个基于 TCP/IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）的协议。

HTTP 协议工作于客户端-服务端架构之上。浏览器作为 HTTP 客户端通过 URL，向 HTTP 服务端，即 web 服务器发送所有请求。web 服务器根据接收到的请求，向客户端发送响应信息。

#### Q：HTTP 工作流程

1. 客户端与服务器建立 TCP 连接。
2. 客户端向服务器发出请求。
3. 服务器接收到客户端的请求，根据请求返回响应内容。
4. 客户端接收服务器的响应内容，解析内容在前端展示，然后客户端与服务器断开连接。

#### Q：HTTP 协议特点

1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
2. 灵活: HTTP 允许传输任意类型的数据对象。
3. 无状态：协议对于事务处理没有记忆能力，如果后续处理需要前面的信息，则它必须重传。
4. 无连接的：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。
5. 支持 B/S 及 C/S 模式。
6. 默认端口 80。
7. 基于 TCP/IP 通信协议。

#### Q：Cookie 和 Session 的区别

* Cookie 是浏览器支持的一种本地存储机制。一般由服务端设置生成，在响应请求时被自动存储在浏览器中，用于辨别用户身份。
* 创建 Session 的时候， 服务端会在 http 协议中告诉客服端，需要在 Cookie 里记录一个 sessionid, 以后每次请求把这个 id 发送到服务器，就知道用户身份了。

**区别**： 

1. 存储位置：Cookie 是存储在客户端（浏览器）中的小型文本文件，而 Session 是存储在服务器上的数据结构。

2. 数据存储：Cookie 通常包含少量的用户数据，以键值对的形式存储在客户端。Session 可以存储更多的用户数据，可以包含复杂的对象和数据结构。

3. 安全性：Cookie 存储在客户端，可以被客户端修改或者删除。因此，对于敏感信息，需要谨慎处理。Session 数据存储在服务器端，相对来说更安全，客户端无法直接访问或修改。

4. 生命周期：Cookie 可以设置过期时间，可以在客户端存储一段时间，并在之后仍然有效。Session 通常在用户关闭浏览器或一段时间不活动后过期，或者通过在服务器上设置超时时间来控制。

5. 存储方式：Cookie 通过在 HTTP 响应头中的 Set-Cookie 字段发送给客户端，客户端将其存储在本地。之后，每次请求中都会通过 Cookie 头字段将 Cookie 发送回服务器。Session 通过在服务器上创建唯一的标识符（通常是会话 ID）来跟踪用户会话，并将该标识符存储在 Cookie 中或通过 URL 重写传递给客户端。

#### Q：什么是跨站脚本攻击 XSS 和 HttpOnly

XSS 是跨站脚本攻击（Cross Site Scripting）。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，Script 代码会被执行从而达到恶意攻击用户的目的。如，盗取用户 Cookie、破坏页面结构、重定向到其它网站（流量劫持）等。

HttpOnly 是一个标记，用于设置 HTTP Cookie 的属性。当设置了 HttpOnly 属性后，浏览器将限制该 Cookie 只能通过 HTTP 或 HTTPS 协议进行传输，禁止通过脚本（如 JavaScript）访问该 Cookie。

HttpOnly 属性的作用是增加 Web 应用程序的安全性，防止跨站脚本攻击（XSS）的一种方式。


#### Q：GET 和 POST 的区别

* GET 重点在从服务器上获取资源，一般用于获取/查询资源信息。是无副作用的，是幂等的，且可缓存。
* POST 重点在向服务器发送数据，一般用于更新资源信息。有副作用，非幂等，不可缓存。
* POST 比 GET 安全性更高。Get 通过 URL 来传输数据，因为 URL 是可见的，可能会泄露私密信息，如密码等。POST 通过 URL 和请求体 requrest body 传输数据，将字段与对应值封存在请求体中发送给服务器。在请求体中的数据，我们是无法直接观测到的。

#### Q：浏览器输入一个 URL 之后，网络各层发生了什么

1. 浏览器输入 URL，若协议为 HTTP：
2. 应用层 DNS 解析，返回对应的 ip 地址（DNS 协议，DNS 服务器是基于 UDP 的）
3. 应用层客户端发送 HTTP 请求（HTTP 协议）
4. 传输层传输报文建立 TCP 连接三次握手（TCP 协议）
5. 网络层 ip 查询 mac 地址（IP 协议，ARP 协议）
6. 数据到达数据链路层 
7. 物理层：物理传输 bit
8. 服务器发送 HTTP 响应报文。
9. 关闭连接，TCP 四次挥手
10. 客户端解析 HTTP 响应报文，浏览器开始显示 HTML

#### Q：HTTP 和 HTTPS 的区别

* HTTP 协议是以明文的方式在网络中传输数据，而 HTTPS 协议传输的数据则是使用密钥进行加密（经过 SSL/TLS 加密）的，所以 HTTPS 具有更高的安全性。
* HTTPS 部署成本高，HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买CA证书。
* HTTPS 握手阶段延时较高：HTTPS 在 TC P三次握手阶段之后，还需要进行 SSL/TLS 的握手。
* 由于采用 HTTPS 协议需要进行加解密的计算，占用 CPU 资源较多。

#### Q：TCP 怎么保证可靠性

* 校验和
* 序列号
* 确认应答
* 超时重传
* 连接管理
* 流量控制：滑动窗口机制基于接收方的反馈信息来动态调整发送方的发送速率
* 拥塞控制：慢启动、拥塞避免、快速重传、超时重传

#### Q：长连接与短连接的区别

长连接，也叫持久连接，在 TCP 层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息交互，直至连接的任意一方（客户端 OR 服务端）主动断开连接，此过程称为一次完整的长连接。

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，增加了通信开销。HTTP/1.1 最重要的新特性就是引入了长连接。

短连接，客户端收到服务端的响应后，立刻发送 FIN 消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互之后立刻断开连接的情况都称为短连接。

#### Q：Socket 套接字

Socket 套接字是在应用层和传输层之间的一个抽象层，用于实现应用程序之间的网络通信。它提供了一种编程接口，允许应用程序通过网络进行数据传输。

在网络通信中，Socket 套接字通过使用网络协议栈中的传输层协议（如 TCP 或 UDP）来实现数据的可靠传输或不可靠传输。只需要指定主机的 IP 地址，和一个端口号。

Socket 套接字是在操作系统内核中实现的，它负责处理网络通信的细节，如建立连接、数据的发送和接收、错误处理等。应用程序可以使用 Socket API（如套接字函数）来创建、配置和控制 Socket 套接字，从而实现网络通信。

#### Q：IPv4 和 IPv6 

* IPv4 是目前广泛使用的IP协议版本。它使用32位地址，通常表示为**点分十进制**格式（例如，192.168.0.1）。

* IPv6 是为了解决 IPv4 地址空间不足的问题而设计的下一代 IP 协议。IPv6 使用 128 位地址，通常表示为**冒号分隔的十六进制**格式（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。

#### Q：负载均衡

负载均衡是一种在计算机网络中分配工作负载（请求或流量）到多个服务器的技术。它旨在提高系统的性能、可扩展性和可靠性，通过均衡分配负载来避免单个服务器过载或故障引起的性能下降。

实现负载均衡的一种常见方法是通过负载均衡器（Load Balancer）。负载均衡器是位于客户端和服务器之间的网络设备或软件，它接收来自客户端的请求，并将这些请求分发到一组后端服务器上，以实现负载的均衡。

* Nginx 是七层（即应用层）负载均衡器 ，这意味着如果它要转发流量首先得和 client 建立一个 TCP 连接，并且转发的时候也要与转发到的上游 server 建立一个 TCP 连接，而我们知道建立 TCP 连接其实是需要耗费内存（TCP Socket，接收/发送缓存区等需要占用内存）的。所以 Nginx 的负载能力受限于机器 I/O，CPU 内存等一系列配置，一旦连接很多（比如达到百万）的话，Nginx 抗负载能力就会急剧下降。

* LVS 是四层（传输层）负载均衡器，LVS 只是单纯地转发包，不需要和上下游建立连接，相比于 Nginx 它的抗负载能力强、性能高，对内存和 cpu 资源消耗比较低。负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过负载均衡算法选择一个最佳的服务器，并对报文中目标 IP 地址进行修改（改为后端服务器 IP），直接转发给该服务器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。

#### Q：什么是 SYN 攻击

在 TCP 协议中，建立连接的过程涉及三次握手：客户端发送一个 SYN 包（同步请求）给服务器，服务器回复一个 SYN-ACK 包（同步应答），最后客户端发送一个 ACK 包（确认）。这个过程用于确保客户端和服务器之间的连接正常建立。

SYN 攻击利用了这个连接建立的过程中的漏洞。攻击者发送大量的伪造的 SYN 包给目标服务器，但是攻击者并不回复服务器的 SYN-ACK 包。服务器在等待超时后会关闭这个半连接状态，释放资源。攻击者不断发送大量的伪造 SYN 包，占用服务器的连接资源，导致服务器无法处理正常的连接请求。

#### Q：常见的网络劫持

* DNS 劫持：攻击者篡改 DNS 的解析过程，使得用户在输入网址时被重定向到恶意网站，从而窃取用户的信息或进行其他恶意活动。

* ARP 劫持：攻击者在本地网络中伪造或篡改 ARP 响应，将目标主机的 IP 地址映射到攻击者的 MAC 地址，从而导致网络通信被重定向到攻击者控制的主机。

* BGP 劫持：攻击者通过篡改 BGP 路由表信息，使得网络流量被重定向到攻击者控制的路径，从而可以窃取、拦截或篡改网络通信。

* HTTP 劫持：攻击者劫持 HTTP 通信过程，例如通过中间人攻击（Man-in-the-Middle Attack）获取或篡改 HTTP 请求和响应，从而窃取用户的敏感信息或操纵通信内容。

* Wi-Fi 劫持：攻击者在公共 Wi-Fi 网络中进行劫持，例如通过伪造热点或中间人攻击来窃取用户的网络流量和敏感信息。

## 操作系统

#### Q：进程、线程和协程

* 进程（Process）：进程是**操作系统分配资源的最小单位**，是一个正在执行中的程序的实例。每个进程都有独立的内存空间和执行环境，它们之间相互隔离。进程之间通常通过进程间通信（IPC）机制进行通信，如管道、共享内存、消息队列等。多进程可以同时执行不同的任务，实现并发处理。

* 线程（Thread）：线程是**进程内的执行单元**，是 **CPU 调度的最小单位**。一个进程可以包含多个线程，共享相同的内存空间和上下文环境。不同线程之间可以并发执行，通过共享内存来进行数据通信，但也需要注意同步和互斥问题。线程之间的切换开销相对较小，适合执行密集的计算和并发任务。

* 协程（Coroutine）：协程是一种**用户态的轻量级线程**，由程序员主动切换执行，而不依赖于操作系统的调度。协程在执行过程中可以主动挂起和恢复，控制权的切换由程序自身控制，通常不涉及内核态的切换。协程适用于高并发、IO 密集型任务，可以提高程序的性能和响应能力。

系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等。在进行进程切换时，涉及到整个 CPU 环境的保存以及新 CPU 环境的设置。而线程切换只须保存和设置少量寄存器的内容，所以进程切换的开销也远大于线程切换的开销。

通信开销：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现变得比较容易，可以直接读写进程数据段（如全局变量）来进行通信，也需要进行同步和互斥来保证数据的一致性。。进程间通信 IPC：管道、共享内存、消息队列、信号量、套接字。

进程间相互独立，不会相互影响；一个线程挂掉可能会导致整个进程挂掉。

#### Q：进程间通信

* 管道（Pipe）：管道是一种半双工的通信方式，分为匿名管道和命名管道。匿名管道用于父子进程之间的通信，而命名管道则可以用于无关进程之间的通信。

* 命名管道（Named Pipe）：命名管道是一种具有名称的管道，可以用于不相关的进程之间进行通信。命名管道可以在文件系统中创建，并且可以由多个进程共享。

* 共享内存（Shared Memory）：共享内存是一种进程间共享内存空间的方式。多个进程可以访问同一块内存区域，从而实现高效的数据交换。需要进行同步和互斥来保证数据的一致性。

* 消息队列（Message Queue）：消息队列是一种进程间传递消息的方式。进程可以将消息发送到消息队列，其他进程可以从队列中接收消息。消息队列提供了一种异步的通信方式。

* 信号量（Semaphore）：信号量是一种用于进程同步和互斥的机制。多个进程可以通过信号量来进行临界区的互斥访问，以及进程之间的同步操作。

* 套接字（Socket）：套接字是一种网络通信的方式，用于在不同的主机之间进行进程间通信。套接字提供了一种通用的、可移植的通信机制，可以在不同计算机之间进行通信。

#### Q：线程的五种状态

1. 新建（New）：当创建线程对象时，线程处于新建状态。此时线程还没有开始执行，尚未分配系统资源。

2. 可运行（Runnable）：线程进入可运行状态后，可以被线程调度器调度执行。在可运行状态下，线程已经分配了系统资源，但尚未获得 CPU 的执行时间片。

3. 运行（Running）：当线程获得 CPU 的执行时间片后，进入运行状态，开始执行线程的任务代码。

4. 阻塞（Blocked）：线程可能由于某些原因而暂时停止执行，进入阻塞状态。例如，线程在等待某个资源的时候，可以进入阻塞状态。当所需资源就绪后，线程将退出阻塞状态并进入可运行状态。

5. 终止（Terminated）：线程的执行任务结束后，或者由于异常等原因导致线程终止，线程进入终止状态。终止状态的线程不再执行，且无法转换到其他状态。

#### Q：消息队列的作用

* 异步通信：消息队列允许发送者发送消息后立即返回，而无需等待接收者的响应。这样可以实现异步通信，提高系统的响应性能和并发性。

* 解耦应用组件：通过消息队列，不同的应用组件可以解耦并独立演化。发送者和接收者之间不需要直接的依赖关系，它们只需要通过共享的消息队列来进行通信。这样，应用组件可以独立开发、部署和升级，而不会对其他组件产生影响。

* 缓冲和削峰填谷：消息队列可以作为缓冲区，当消息发送的速度超过接收的速度时，消息可以暂时存储在队列中，避免消息丢失或系统过载。同时，在高负载时，消息队列可以平滑处理峰值流量，保护系统免受过高的请求压力。

* 可靠性和持久化：许多消息队列提供持久化机制，确保即使在消息传递过程中出现故障或重启，消息也不会丢失。消息队列还可以提供消息的投递确认和重试机制，确保消息的可靠传递。

* 扩展性和可伸缩性：消息队列可以用于构建分布式系统，并支持水平扩展。通过增加消息队列的实例或增加消费者的数量，可以提高系统的处理能力和可伸缩性。

## Linux

#### Q：用户态和内核态有什么区别

通过系统调用将 Linux 整个体系分为用户态和内核态（或者说内核空间和用户空间）。

* 内核态是操作系统内核运行的一种模式，其中操作系统内核具有最高的特权级别和完全访问系统资源的权限。例如协调 CPU 资源，分配内存资源，并且提供稳定的环境供应用程序运行。
* 用户态是应用程序运行的一种模式，其中应用程序以及用户编写的代码在用户空间运行，无法直接访问或操作底层硬件设备和操作系统内核。

用户态的应用程序运行在操作系统提供的虚拟地址空间中，通过系统调用向内核请求服务和资源。

从用户态到内核态切换可以通过三种方式：

1. 系统调用：其实系统调用本身就是中断，但是软件中断，跟硬中断不同。
2. 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。
3. 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。

#### Q：kill -15 和 kill -9 的区别

* kill -9 PID 是操作系统从内核级别强制杀死一个进程。
* kill -15 PID 可以理解为操作系统发送一个通知告诉应用主动关闭。

因为 kill -15 信号只是通知对应的进程要进行"安全、干净的退出"，程序接到信号之后，退出前一般会进行一些"准备工作"，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。但是，如果在"准备工作"进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。这也就是为什么我们有的时候使用 kill 命令是没办法"杀死"应用的原因，因为默认的 kill 信号是 SIGTERM（15），而 SIGTERM（15）的信号是可以被阻塞和忽略的。和 kill -15 相比， kill -9 就相对强硬一点，系统会发出 SIGKILL 信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。所以，相比于 kill -15 命令，kill -9 在执行时，应用程序是没有时间进行"准备工作"的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。

#### Q：前台进程和后台进程区别

* 前台进程：是在终端中运行的命令，那么该终端就为进程的控制终端，一旦这个终端关闭，这个进程也随之消失。
* 后台进程：也叫守护进程（Daemon），是运行在后台的一种特殊进程，不受终端控制，它不需要终端的交互；Linux 的大多数服务器就是使用守护进程实现的。

#### Q：awk 命令

数据过滤工具 (类似于 grep，比 grep 强大)，属数据处理引擎，基于模式匹配检查输入文本，逐行处理并输出。通常用在 Shell 脚本中，获取指定的数据，单独使用时，可对文本数据做统计。

#### Q：scp 命令

在 linux 下 scp 命令主要用来在不同主机之间做数据的安全拷贝的。scp 命令使用安全加密的协议，所以在远程拷贝数据的时候会比较安全，不会被黑客截取。

#### Q：shell 脚本

第一行一定是 `#!/bin/bash` 它代表的意思是，该文件使用的是 bash 语法。如果不设置该行，那么你的 shell 脚本就不能被执行。

定义变量的格式为 `变量名=变量的值`。当在脚本中引用变量时需要加上 `$` 符号。

数学计算要用 '[]' 括起来并且外头要带一个 `$`。

## 数据库

#### Q：索引

数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B+ 树。

#### Q：索引的类型

* 普通索引（INDEX）：这是最基本的索引，它没有任何限制。
* 唯一索引（UNIQUE）：避免同一个表中某数据列中的值重复。
  * 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 
  * 与主键索引的区别：主键索引只能有一个，唯一索引可有多个。
* 主键索引（PRIMAY KEY）：特殊的唯一索引，不允许有空值。一个表只能有一个主键。 
* 联合索引
* 全文索引（FULLTEXT）：快速定位特定数据。

#### Q：为什么说 B+ 树更适合数据库索引

* B+ 树的磁盘读写代价更低：B+ 树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对 B 树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 IO 读写次数就降低了。

* B+ 树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

* B+ 树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是 B 树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 B+ 树更加适合在区间查询的情况，所以通常 B+ 树用于数据库索引。

#### Q：事务并发问题

1. 脏读（Dirty Reads）：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
2. 不可重复读（Non-Repeatable Reads）：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
3. 幻读（Phantom Reads）：事务 A 修改全表的数据，在事务 A 未提交时，事务 B 向表中插入或删除数据并提交，导致事务 A 读取的数据与需要修改的数据不一致。

不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

实现事物隔离性主要有两种方式：读写锁和 MVCC。

#### Q：数据库四种隔离等级

1. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
   * 完全的串行化读，所有 SELECT 语句都被隐式的转换成 SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。
   * 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。
2. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
   * 在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。(写锁，等读完)
3. Read committed (读已提交、不可重复读)：可避免脏读的发生。
   * 只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。（读锁，等写完）
4. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
   * 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。

#### Q：MySQL 和 Redis 两种数据库有什么区别

* MySQL 是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。但是不受空间容量限制，性价比高。
* Redis 是内存数据库，即将数据存储在缓存中，用于存储使用频繁的数据，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。

#### Q：为什么要用 Redis

主要考虑两个角度：性能和并发

如果说数据要去硬盘上读取，那么过程会比较慢。如果将频繁使用的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。

在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 Redis 做一个缓冲操作。直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，让请求到 Redis 这里而不用经过数据库。

#### Q：单线程的 Redis 为什么这么快

单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。
1. 绝大部分请求是纯粹的内存操作
2. 采用单线程，避免了不必要的上下文切换和竞争条件
3. 采用了非阻塞 I/O 多路复用机制

#### Q：RDB 和 AOF

* RDB：Redis DataBase，Redis 默认的持久化方式，每隔一定的时间将内存的数据以快照的形式保存到硬盘中。
* AOF：开启 AOF 持久化后每执行一条更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。

**区别**：

* AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。
* AOF 比 RDB 更安全，但 AOF 文件比 RDB 文件大，且恢复速度慢。
* RDB 性能比 AOF 好，数据集大的时候，AOF 比 RDB 启动效率低。
* 当两种方式同时开启时，数据恢复 Redis 会优先选择 AOF 恢复。

#### Q：跳跃表在 Redis 中主要用在哪些地方

zset 有序集合就是用跳表来实现的。可以实现范围查找，排行榜功能或者 topN 功能。

跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。以空间换时间的方式提升了查找速度。

#### Q：Redis 中过期键的删除策略

* 定时过期：每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

* 惰性过期：只有当客户端访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。

* 定期过期：Redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。

#### Q：Redis 的内存淘汰策略

Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。

* 全局的键空间选择性移除
  * noeviction：新写入操作会报错。
  * allkeys-lru：首先通过 LRU 算法驱逐最久没有使用的键。
  * allkeys-random：随机移除某个 key。
  * allkeys-lfu：从所有键中驱逐使用频率最少的键。

* 设置过期时间的键空间选择性移除
  * volatile-lru：在设置了过期时间的键空间中，移除最久没有使用的 key。
  * volatile-random：在设置了过期时间的键空间中，随机移除某个 key。
  * volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。
  * volatile-lfu：从所有配置了过期时间的键中，驱逐使用频率最少的键。

## 测试

#### Q：软件生命周期的六个阶段

计划、需求、设计、编码、测试、运行与维护。

1. 问题定义及规划阶段：主要确定软件的开发目的及其可行性，制定开发计划。
2. 需求分析/评审阶段：在确定软件开发可行的情况下，将对软件需要实现的每个功能进行详细分析。
3. 软件设计阶段：在此阶段，将根据需求分析的结果来设计整个软件系统，例如系统框架设计，数据库设计等。软件设计一般分为总体设计和详细设计。
4. 软件编码阶段：开发人员任务、程序员编码。
5. 软件测试阶段：测试工程师的任务或开发的任务。
6. 软件运行维护阶段：版本、产品上线（版本的升级改进）BUG 的修复。

#### Q：介绍一下单元测试、集成测试、系统测试、验收测试、回归测试

* 单元测试：测试编码是否符合设计要求。软件中最小的测试单元，比如 go 中的一个函数。相关单元测试放在一起就是一个模块。
* 集成测试：就是接口测试，对接口是否能够实现进行测试，对接口实现后的结果进行测试。在单元测试的基础上将所有模块按照要求设计组装。测试不同模块之间是否按照预期工作，比如不同模块之间的数据传输。
* 系统测试：系统测试就是对可视化图形界面测试，对整个系统功能进行测。是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。
* 验收测试：验收测试就是模拟客户进行测试，确保软件各部分功能正常运行。确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括 Alpha 测试和 Beta 测试。
* 回归测试：在缺陷修复之后的检验测试，指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。

#### Q：黑盒测试和白盒测试

* 白盒测试又称为结构测试、逻辑驱动测试或基于程序本身的测试，着重于程序的内部结构及算法，通常不关心功能与性能指标。
  * 逻辑覆盖测试：语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖、路径覆盖
  * 基本路径覆盖测试：选择足够的测试用例，使得运行这些测试用例时，被测程序的每条可能执行的路径都至少经过一次。

* 黑盒测试又称为功能测试、数据驱动测试或基于规格说明的测试，实际上是站在最终用户的立场上，检验输入输出信息及系统性能指标是否符合规格说明书中有关功能需求及性能需求的规定。
  * 等价类划分法：主要解决穷举的问题
  * 边界值分析法：选取正好等于、刚好大于、刚好小于边界的值作为测试数据

* 灰盒测试是综合运用黑盒测试和白盒测试技术的一种混合测试方法。

#### Q：冒烟测试

确保开发人员修复了 bug 后，这个 bug 的修复没有影响到其他功能模块。

#### Q：接口测试

接口测试其实最主要的验证接口逻辑，可用性，边界值，异常检查。

主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。

#### Q：为什么要做接口测试

1. 现在很多系统前后端架构是分离的，因为不同端的工作进度不一样，所以我们要针对最开始出来的接口，以及需要调用其他公司的一些接口进行接口测试及验证数据。
2. 如今系统越来越复杂，传统的靠前端测试已经大大降低了效率，而且现在都推崇测试前移也叫测试左移，希望测试能更早的介入，那接口测试就是一种及早介入的方式。

#### Q：接口的组成

接口说明、调用 url（请求的地址）、请求方法（get/post）、请求参数、参数类型、参数说明。

#### Q：性能测试

测试软件性能方面的质量，它是一种非功能性的测试。

在整个测试中，应用程序的性能在预期的或更高的负载下进行评估。评估系统的不同性能属性，如响应时间（速度）、吞吐量、可靠性、资源使用率、可扩展性等。监控系统的各项指标，是否符合需求，如果不符合，就发现了系统的性能瓶颈。

   * 负载测试：通过在被测系统上不断加压（如逐渐增加模拟用户的数量），直到性能指标达到极限，来观察不同负载下系统的响应时间和数据吞吐量、系统占用的资源（如 CPU、内存）等。
   * 压力测试：系统在强负载下的测试，例如 CPU、内存在饱和使用情况下，看系统在峰值使用情况下是否稳定，看系统处理会话的能力以及哪里会出问题。
   * 容量测试：通过测试预先分析出系统某项指标的极限值（如最大并发用户数、数据库记录数等）。
   * 并发测试：模拟多用户并发访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题。
   * 配置测试：通过对被测系统软硬件环境的调整，了解各种不同环境对系统性能影响的程度，从而找到系统各项资源的最优分配原则。
   * 可靠性测试（持久性测试）：给系统施加一定的业务压力，让其持续运行一段时间，测试在这种条件下能否稳定运行。

#### Q：性能测试常用指标

并发数、响应时间、吞吐量、资源利用率。

#### Q：测试用例八大要素

编号、标题、模块、前置条件、优先级、测试步骤、测试数据、预期结果。

#### Q：

#### Q：驱动模块和桩模块

驱动模块和桩模块的设计模式有助于实现模块间的解耦、模块的独立开发和测试，以及提高系统的可维护性和可测试性。

* 驱动模块（Driver）：
    驱动模块是指在软件系统中用于驱动或控制其他模块或组件的模块。它通常作为系统的入口点，负责协调和调用其他模块的功能。驱动模块可以是一个主程序、主服务或主类，它负责初始化系统，处理用户输入，协调各个模块之间的交互等。可以通过模拟一系列用户操作行为，比如选择用户界面上的某一个选项或者按下某个按钮等，自动调用被测试模块中的函数。

* 桩模块（Stub）：
    桩模块是指在软件开发中用于模拟或代替其他模块或组件的模块。它通常用于测试、仿真或替代系统中的某个模块，以便进行单元测试、集成测试或模块开发的并行工作。桩模块的设计目标是提供与实际模块相同的接口，但实现逻辑通常是简化的或者是空实现的。桩模块可以模拟其他模块的行为，返回预定义的数据或固定的结果，以便进行测试和验证。

#### Q：软件测试的关键点

* 尽早发现缺陷：伴随软件开发的各个环节，及时发现问题解决问题，避免最后问题堆积导致无法解决或解决工程量巨大。
* 用尽量少的测试用例发现尽可能多的缺陷。
* 提升发现缺陷的效率。

#### Q：自动化测试的流程

1. 分析自动化测试需求，一般在手工测试之后开始
2. 根据项目的特点、选择合适的自动化测试工具，并搭建测试环境
3. 测试用例设计和开发：设计测试用例；或提取手工测试的测试用例，转化为自动化测试用例
4. 开发自动化软件测试框架和测试脚本
5. 执行：通过工具、代码实现自动化的构造输入、自动检测输出结果是否满足预期
6. 生成自动测试报告
7. 持续改进、脚本优化

#### Q：登陆界面测试

* 功能测试
  1. 输入正确的用户名和密码，点击提交按钮，验证是否能正确登录
  2. 输入错误的用户名或者密码,验证登录会失败，并且提示相应的错误信息
  3. 登录成功后能否能否跳转到正确的页面
  4. 用户名和密码，如果太短或者太长，应该怎么处理
  5. 用户名和密码，中有特殊字符（比如空格），和其他非英文的情况
  6. 记住用户名的功能
  7. 登陆失败后，不能记录密码的功能
  8. 用户名和密码前后有空格的处理
  9. 密码是否非明文显示显示，使用星号圆点等符号代替。
  10. 登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确
  11. 输入密码的时候，大写键盘开启的时候要有提示信息。
  12. 什么都不输入，点击提交按钮，检查提示信息。

* 性能测试
  1. 打开登录页面，需要的时间是否在需求要求的时间内
  2. 输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内
  3. 模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转

* 兼容性测试
  1. 不同浏览器下能否显示正常且功能正常
  2. 同种浏览器不同版本下能否显示正常且功能正常
  3. 不同的平台是否能正常工作，比如 Windows，Mac
  4. 移动设备上是否正常工作，比如 Iphone，Andriod
  5. 不同的分辨率下显示是否正常

* 界面测试
  1. 布局是否合理，testbox 和按钮是否整齐
  2. testbox 和按钮的长度，高度是否复合要求
  3. 界面的设计风格是否与UI的设计风格统一
  4. 界面中的文字简洁易懂，没有错别字

* 可用性测试
  1. 是否可以全用键盘操作，是否有快捷键
  2. 输入用户名，密码后按回车，是否可以登陆
  3. 输入框能否可以以 Tab 键切换

* 安全性测试
  1. 登录成功后生成的 Cookie，是否是 httponly
  2. 用户名和密码是否通过加密的方式，发送给 Web 服务器
  3. 用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用 javascript 验证
  4. 用户名和密码的输入框，应该屏蔽 SQL 注入攻击
  5. 用户名和密码的的输入框，应该禁止输入脚本
  6. 防止暴力破解，检测是否有错误登陆的次数限制
  7. 是否支持多用户在同一机器上登录
  8. 同一用户能否在多台机器上登录