<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「训」 笔记(8)：微服务框架</title>
    <link href="/ByteDance-8/"/>
    <url>/ByteDance-8/</url>
    
    <content type="html"><![CDATA[<p>微服务框架 —— 不变的基建</p><span id="more"></span><h2 id="微服务架构介绍"><a href="#微服务架构介绍" class="headerlink" title="微服务架构介绍"></a>微服务架构介绍</h2><h3 id="系统架构的演进历史"><a href="#系统架构的演进历史" class="headerlink" title="系统架构的演进历史"></a>系统架构的演进历史</h3><p><img src="/ByteDance-8/1.png" alt="演变历史"></p><ul><li>单体架构：All in one process</li><li>垂直应用架构：按照业务线垂直划分</li><li>分布式架构：抽出与业务无关的公共模块</li><li>SOA 架构：面向服务</li><li>微服务架构：彻底的服务化</li></ul><h3 id="微服务架构概览"><a href="#微服务架构概览" class="headerlink" title="微服务架构概览"></a>微服务架构概览</h3><p><img src="/ByteDance-8/2.png" alt="架构"></p><h3 id="微服务架构的三大要素"><a href="#微服务架构的三大要素" class="headerlink" title="微服务架构的三大要素"></a>微服务架构的三大要素</h3><ul><li><p>服务治理：服务注册、服务发现、负载均衡、扩缩容、流量治理、稳定性治理</p></li><li><p>可观测性：日志采集、日志分析、监控打点、监控大盘、异常报警、链路追踪</p></li><li><p>安全：身份验证、认证授权、访问令牌、审计、传输加密、黑产攻击</p></li></ul><h2 id="微服务架构原理及特征"><a href="#微服务架构原理及特征" class="headerlink" title="微服务架构原理及特征"></a>微服务架构原理及特征</h2><h3 id="基本概念及组件"><a href="#基本概念及组件" class="headerlink" title="基本概念及组件"></a>基本概念及组件</h3><p><img src="/ByteDance-8/3.png" alt="基本概念"></p><ul><li><p><strong>服务</strong>（service）：一组具有相同逻辑的运行实体</p></li><li><p><strong>实例</strong>（instance）：一个服务中的每个运行实体都为一个实例</p></li><li><p><strong>集群</strong>（cluster）：通常指服务内部的逻辑划分，包含多个实例</p></li><li><p>实例与进程的关系：没有必然对应关系，一般一对一或者一对多</p></li><li><p>常见的实例承载形式：进程、VM、k8s pod …</p></li></ul><h3 id="服务间通信"><a href="#服务间通信" class="headerlink" title="服务间通信"></a>服务间通信</h3><p>对于单体服务，不同模块通信只是简单的函数调用。<br>微服务之间通过网络进行通信，常见的通信协议包括 HTTP、RPC。</p><p><img src="/ByteDance-8/4.png" alt="通信"></p><h3 id="服务注册及服务发现"><a href="#服务注册及服务发现" class="headerlink" title="服务注册及服务发现"></a>服务注册及服务发现</h3><p><strong>基本问题</strong>：服务间调用中，如何指定下游服务实例的地址？</p><p><strong>简单方案</strong>：</p><ul><li><p>直接指定 ip:port？</p><p><img src="/ByteDance-8/5.png" alt="Hardcode"></p><ul><li>没有任何动态能力</li><li>有多个实例下游实例怎么办？</li></ul></li><li><p>使用 DNS？</p><p><img src="/ByteDance-8/6.png" alt="DNS"></p><ul><li>本地 DNS 存在缓存，导致延迟</li><li>DNS 没有负载均衡</li><li>不支持服务探活检查</li><li>DNS 不能指定端口</li></ul></li></ul><p><strong>服务注册发现</strong></p><p><img src="/ByteDance-8/7.png" alt="服务注册中心"></p><ul><li>新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系</li><li>旧服务实例下线前，从服务注册中心删除该实例，下线流量</li><li>新服务实例上线后，在服务注册中心注册该实例，上线流量</li></ul><p><strong>微服务流量特征</strong></p><p><img src="/ByteDance-8/8.png" alt="流量特征"></p><ul><li>统一网关入口</li><li>外网通信多数采用 HTTP，内网通信多数采用 RPC（Thrift, gRPC）</li></ul><h2 id="核心服务治理功能"><a href="#核心服务治理功能" class="headerlink" title="核心服务治理功能"></a>核心服务治理功能</h2><h3 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h3><p>服务发布（deployment）是让一个服务升级运行新的代码的过程。</p><p><strong>难点</strong>：服务不可用、服务抖动、服务回滚</p><p><strong>蓝绿部署</strong></p><p><img src="/ByteDance-8/9.png" alt="蓝绿部署"></p><ul><li>将服务分成两个部分，分别先后发布</li><li>简单、稳定</li><li>但需要两倍资源</li></ul><p><strong>灰度发布（金丝雀发布）</strong></p><p><img src="/ByteDance-8/10.png" alt="灰度发布"></p><ul><li>先发布少部分实例，接着逐步增加发布比例</li><li>不需要增加资源</li><li>回滚难度大，基础设施要求高</li></ul><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><p>流量控制是在微服务架构中，可以从各个维度对端到端的流量在链路上进行精确控制。</p><p>控制维度：地区维度、集群维度、实例维度、请求维度</p><p><img src="/ByteDance-8/11.png" alt="流量治理"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡（Load Balance）负责分配请求在每个下游实例上的分布。</p><p>常见 LB 策略：</p><ul><li>Round Robin</li><li>Random</li><li>Ring Hash</li><li>Least Request</li></ul><h3 id="稳定性治理"><a href="#稳定性治理" class="headerlink" title="稳定性治理"></a>稳定性治理</h3><p>线上服务总是会出问题的，这与程序的正确性无关。</p><ul><li><p>限流：限制服务处理的最大 QPS，拒绝过多请求。</p></li><li><p>熔断：中断请求路径，增加冷却时间从而让故障实例尝试恢复。</p></li><li><p>过载保护：在负载高的实例中，主动拒绝一部分请求，防止实例被打挂。</p></li><li><p>降级：服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求。</p></li></ul><h2 id="字节跳动服务治理实践"><a href="#字节跳动服务治理实践" class="headerlink" title="字节跳动服务治理实践"></a>字节跳动服务治理实践</h2><h3 id="重试的意义"><a href="#重试的意义" class="headerlink" title="重试的意义"></a>重试的意义</h3><p>本地函数调用：通常没有重试意义。</p><p>远程函数调用：网络抖动、下游负载高、下游机器宕机… 重试是有意义的，可以避免偶发性的错误，提高 SLA（Service-Level Agreement）。</p><p><strong>意义</strong>：</p><ul><li>降低错误率<ul><li>假设单次请求的错误概率为0.01，那么连续两次错误概率则为0.0001。</li></ul></li><li>降低长尾延时<ul><li>对于偶尔耗时较长的请求，重试请求有机会提前返回。</li></ul></li><li>容忍暂时性错误<ul><li>某些时候系统会有暂时性异常（例如网络抖动），重试可以尽量规避。</li></ul></li><li>避开下游故障实例<ul><li>一个服务中可能会有少量实例故障（例如机器故障），重试其他实例可以成功。</li></ul></li></ul><h3 id="重试的难点"><a href="#重试的难点" class="headerlink" title="重试的难点"></a>重试的难点</h3><ul><li><p>幂等性：多次请求可能会造成数据不一致。</p></li><li><p>重试风暴：随着调用链路的增加，重试次数呈指数级上升。</p></li></ul><p><img src="/ByteDance-8/12.png" alt="重试风暴"></p><ul><li>超时设置：假设调用时间一共 1s，经过多少时间开始重试？</li></ul><h3 id="重试的策略"><a href="#重试的策略" class="headerlink" title="重试的策略"></a>重试的策略</h3><ul><li><p>限制重试比例：设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值。</p></li><li><p>防止链路重试：返回特殊的 status code，表示“请求失败，但别重试”。</p></li><li><p>Hedged Requests：对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应。</p></li></ul><p><img src="/ByteDance-8/13.png" alt="Hedged Requests"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(7)：分布式理论</title>
    <link href="/ByteDance-7/"/>
    <url>/ByteDance-7/</url>
    
    <content type="html"><![CDATA[<p>分布式理论 —— 现代架构的基石。</p><span id="more"></span><h2 id="分布式概述"><a href="#分布式概述" class="headerlink" title="分布式概述"></a>分布式概述</h2><ul><li><p>什么是分布式？</p><ul><li>分布式系统定义：跨多个节点的计算机程序的集合</li><li>使用分布式系统的五大优势：去中心化、低成本、弹性、资源共享、可靠性高</li><li>分布式系统的挑战：节点故障、不可靠的网络、异构的机器与硬件环境、安全</li></ul></li><li><p>常见的分布式系统</p><ul><li>分布式存储：GFS、Ceph、HDFS、Zookeeper</li><li>分布式数据库：Spanner、TiDB、HBase、MangoDB</li><li>分布式计算：Hadoop、YARN、Spark</li></ul></li></ul><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><h3 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h3><ul><li><p>六种故障模型，从处理的难易程度分类</p><ul><li>Byzantine failure：节点可以任意篡改发送给其他节点的数据，是最难处理的故障</li><li>Authentication detectable byzantine failure (ADB)：节点可以篡改数据，但不能伪造其他节点的数据</li><li>Performance failure：节点未在特定时间段内收到数据，即时间太早或太晚</li><li>Omission failure：节点收到数据的时间无限晚，即收不到数据</li><li>Crash failure：节点停止响应，持续性的故障</li><li>Fail-stop failure：错误可检测，是最容易处理的故障</li></ul></li><li><p>故障模型举例</p></li></ul><p><img src="/ByteDance-7/1.png" alt="故障模型"></p><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><ul><li><p>两将军问题</p><p>  定义：两支军队的将军只能派信使穿越敌方领土互相通信，以此约定进攻时间。该问题希望求解如何在两名将军派出的任何信使都可能被俘虏的情况下，就进攻时间达成共识。</p><p>  结论：两将军问题是被证实无解的电脑通信问题，两支军队理论上永远无法达成共识。</p><p>  TCP是两将军问题的一个工程解。</p></li><li><p>三将军问题：</p><p>  两个“忠将” A 和 B，一个“叛徒” C，互相传递消息，消息可能丢失，也可能被篡改，当有一个将军是“叛徒”（即出现拜占庭故障）时，整个系统无法达成一致。</p><p>  由于“叛徒” C 的存在，将军 A 和将军 B 获得不同的信息。这样将军 A 获得 2 票进攻 1 票撤退的信息，将军 B 获得 1 票进攻 2 票撤退的信息，产生了不一致。</p></li><li><p>四将军问题：</p><p>  将军 D 作为消息分发中枢，约定如果没收到消息则执行撤退。</p><p>  如果 D 为“叛徒”，ABC 无论收到任何消息，总能达成一致。D 为“忠将”，ABC 有 2 人将 D 的消息进行正确的传递，同样能保证最终决策符合大多数。</p><p>  进而能够证明，当有 3m+1 个将军，m 个“叛徒”时，可以进行 m 轮协商，最终达成一致。</p></li></ul><h3 id="共识和一致性"><a href="#共识和一致性" class="headerlink" title="共识和一致性"></a>共识和一致性</h3><p>不同客户端A和B看到客户端C写入，因为时机的不同，产生数据读取的偏差。</p><ul><li>Eventuallyconsistent（最终一致性）<br>  客户端 A 读到 x&#x3D;0，当客户端 C 正在写入时，客户端 A 和 B 可能读到 0 或者 1。但是当 C 写入完成后，A 和 B 最终能读到一致的数据。</li></ul><p><img src="/ByteDance-7/2.png" alt="读请求和写请求并发时可能读到旧值"></p><p>要保证所有客户端看到相同的值，需要多节点进行“协商”，达成共识，来保证线性一致性。</p><ul><li>Linearizability（线性一致性）<br>  当客户端 A 读到更新的版本 x&#x3D;1 后，及时将消息同步给其他客户端，这样其他客户端立即能获取到 x&#x3D;1。</li></ul><p><img src="/ByteDance-7/3.png" alt="一旦某个读获取到新值，所有客户端都必须返回新值"></p><p>一致性和可用性是对矛盾，如果要保证“线性”一致性，多个节点间势必需要进行协商，以寻求一致。这样增加了延迟，系统可用性便会受损。</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>一致性、可用性、分区容错性，三者无法同时达到</p><ul><li>C (Consistence)：一致性，指数据在多个副本之间能够保持一致的特性（严格的一致性）。</li><li>A (Availability)：可用性，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。</li><li>P (Partitioning)：分区容错性，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。</li></ul><p>CAP 诞生了<strong>三类系统</strong>：</p><ul><li>CA 系统：传统单机数据库的代表</li><li>AP 系统：放弃<strong>强</strong>一致性，保证高可用，不少 nosql 存储系统采用，注重用户体验</li><li>CP 系统：放弃可用性，保证数据一致性，注重系统安全</li></ul><h3 id="ACID-理论"><a href="#ACID-理论" class="headerlink" title="ACID 理论"></a>ACID 理论</h3><p>ACID 理论是针对 CA 系统而言的，通常在数据库中具有广泛意义。</p><p>事务是数据库系统中非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全都不执行。</p><p>数据库事务拥有<strong>四个特性</strong>：</p><ul><li>原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li><li>一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li><li>隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 理论是针对 AP 系统而言的，其来源于对大型互联网分布式实践的总结。</p><ul><li>Basically Available(基本可用)：假设系统，出现了不可预知的故障，但还是能用。</li><li>Soft state（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性。</li><li>Eventually consistent（最终一致性）：数据最终一定能够达到一致的状态。</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="二阶段提交（Two-phase-Commit）"><a href="#二阶段提交（Two-phase-Commit）" class="headerlink" title="二阶段提交（Two-phase Commit）"></a>二阶段提交（Two-phase Commit）</h3><p>为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种演算法。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者提交操作还是中止操作。</p><p><strong>三个假设</strong>：</p><ol><li>协调者和参与者进行通信</li><li>预写式日志被保持在可靠的存储设备上</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复</li></ol><p><img src="/ByteDance-7/4.png" alt="2PC"></p><p>正常流程：Prepare 阶段和 Commit 阶段</p><p>异常流程：Prepare 阶段失败 -&gt; 回滚；协调者宕机 -&gt; 重新启用新的协调者；双故障重启 -&gt; 数据库管理员介入</p><p><strong>两阶段提交需解决的问题</strong>：</p><ul><li>性能问题：需要多次网络通信，资源需要等待并锁定</li><li>新协调者：如何确定状态选出新协调者</li><li>Commit 阶段网络分区带来的数据不一致：非所有节点都收到 Commit 请求</li></ul><h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><p>针对两阶段提交的补充，将两阶段提交中的 Prepare 阶段，拆成两部分：CanCommit 和 PreCommit</p><ul><li>CanCommit 阶段：询问是否可以执行</li><li>PreCommit 阶段：重新确认是否可以执行</li><li>DoCommit 阶段：向所有人提交事务</li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>多版本并发控制的方法。维持一个数据的多个版本使读写操作没有冲突。所以既不会阻塞写，也不阻塞读。提高并发性能的同时也解决了脏读的问题。</p><ul><li>悲观锁：操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li><li>乐观锁：不会上锁，只是在执行更新时判断别人是否修改数据，只有冲突时才放弃操作。</li></ul><p>版本的选取：</p><ul><li>物理时钟：提供 TrueTime API，有 Master 节点维持一个绝对时间，保证各个服务器之间时钟误差控制在 ϵ 内，通常 ϵ &lt; 7ms。</li><li>逻辑时钟：中心化授时的方式——时间戳预言机（TSO），好处是无需硬件的支持。</li></ul><h2 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h2><h3 id="Quorum-NWR-模型"><a href="#Quorum-NWR-模型" class="headerlink" title="Quorum NWR 模型"></a>Quorum NWR 模型</h3><ul><li>N：在分布式存储系统中，有多少份备份数据。</li><li>W：代表一次成功的更新操作要求至少有 w 份数据写入成功。</li><li>R：代表一次成功的读数据操作要求至少有 R 份数据成功读取。</li></ul><p><strong>为了保证强一致性，需要保证 W + R &gt; N</strong></p><p>Quorum NWR 模型将 CAP 的选择交给用户，是一种简化版的一致性模型。</p><h3 id="RAFT-协议"><a href="#RAFT-协议" class="headerlink" title="RAFT 协议"></a>RAFT 协议</h3><p>Raft 协议是一种分布式一致性算法（共识算法），即使出现部分节点故障，网络延时等情况，也不影响各节点，进而提高系统的整体可用性。</p><p><img src="/ByteDance-7/5.png" alt="RAFT"></p><ul><li>Log（日志）：节点之间同步的信息，以只追加写的方式进行同步，解决了数据被覆盖的问题。</li><li>Term（任期号）：单调递增，每个 Term 内最多只有一个 Leader。</li><li>Committed：日志被复制到多数派节点，即可认为已经被提交。</li><li>Applied：日志被应用到本地状态机，即执行了log中命令，修改了内存状态。</li></ul><p><img src="/ByteDance-7/6.png" alt="状态转移"></p><ul><li>Leader - 领导者：Leader 负责处理所有的客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后，通知 Follower 提交日志。</li><li>Follower - 跟随者：接受并持久化 Leader 同步的日志，在 Leader 告知日志可以提交后，提交日志。</li><li>Candidate - 备选者：Leader 选举过程中的临时角色，向其他节点发送请求投票信息。</li></ul><p><strong>Leader 选举过程</strong>：</p><ol><li>初始全部为Follower</li><li>Current Term + 1</li><li>选举自己</li><li>向其它参与者发起 RequestVote 请求，retry 直到：<ul><li>收到多数派请求，成为 Leader，并发送心跳</li><li>收到其它 Leader 的请求，转为 Follower，更新自己的 Term</li><li>收到部分，但未达到多数派，选举超时，随机 timeout 开始下一轮</li></ul></li></ol><p><strong>切主</strong>：当Leader出现问题时，就需要进行重新选举</p><ol><li>Leader 发现失去 Follower 的响应，失去 Leader 身份</li><li>两个 Follower 之间一段时间未收到心跳，重新进行选举，选出新的 Leader，此时发生了切主</li><li>Leader 自杀重启，以 Follower 的身份加入进来</li></ol><h3 id="Paxos-协议"><a href="#Paxos-协议" class="headerlink" title="Paxos 协议"></a>Paxos 协议</h3><p><strong>Paxos 算法与 RAFT 算法区别</strong>：</p><ul><li><p>Multi-Paxos 可以并发修改日志，而Raft写日志操作必须是连续的</p></li><li><p>Multi-Paxos 可以随机选主，不必最新最全的节点当选 Leader</p></li><li><p>优势：写入并发性能高，所有节点都能写</p></li><li><p>劣势：没有一个节点有完整的最新的数据，恢复流程复杂，需要同步历史记录</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Utilizing Parallelism in Smart Contracts on Decentralized Blockchains by Taming Application-Inherent Conflicts</title>
    <link href="/Taming-Conflicts/"/>
    <url>/Taming-Conflicts/</url>
    
    <content type="html"><![CDATA[<p>区块链系统随着共识技术的发展，性能已经大大提高，交易执行成为一个新的性能瓶颈。我们观察到应用内在的冲突是限制并行执行的主要因素。本文提出使用<strong>分区计数器</strong>和特殊的<strong>可交换指令</strong>来打破应用程序冲突链，以最大化性能。我们还提出了 <strong>OCC-DA</strong>，一个具有确定性中止的乐观并发控制调度器，使得在<strong>公链</strong>中使用 OCC 调度成为可能。</p><span id="more"></span><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>我们的发现：</p><ol><li>与串行执行相比，并行可实现的总体加速限制约为 4 倍。虽然有许多块的执行速度随着线程数量的增加而增大，但很大一部分块的执行情况要差得多。</li><li>大多数块都被单个交易依赖链所阻塞，这些交易需要串行执行，因此影响了总体的执行时间。</li><li>对瓶颈交易的人工检查显示，它们中的大多数在单个计数器或数组上发生冲突。从应用程序的角度来看，大多数瓶颈交易可以分为三类：代币分发、收藏品和去中心化金融。</li></ol><p>研究结果表明，我们工作的重点应该是消除智能合约中这些常见的争用源，而不是优化调度器的实现。本文提出了三种独立的技术来消除上述瓶颈：</p><ol><li><p>最简单方法是使用多个发送方地址。手动将单个发送方的一组交易划分为多个不相交的交易集。</p></li><li><p>第二种方法是使用分区计数器（partitioned counters），类似于 Sloppy Counters。在这种方法中，我们维护几个子计数器，它们的总和构成原始计数器的值。写入基于某些属性（例如发送方地址）被路由到不同的子计数器并在其上操作。分区计数器可以减少任何两个写入交易冲突的概率。</p></li><li><p>第三种方法是消除由虚拟机级别的交换更新引起的可避免冲突。两个增加计数器但不使用其原始值的交易在语义上是可交换的。然而，在当前的以太坊虚拟机语义下，这些增量被转换为读取（SLOAD）和写入（SSTORE）指令，这将导致读写冲突。我们提出了一个名为 CADD（commutative add）的新指令。在给定状态条目上没有其他读写操作，而只有 CADD 操作的两个交易被视为不冲突。增量在交易提交期间逐个应用。</p></li></ol><p>此外，为了解决并行执行导致节点状态不一致问题，我们引入了一种具有确定性事务中止的乐观调度器。这种方法允许我们引入并行性的激励措施，以换取可接受的性能影响。</p><h2 id="2-BACKGROUND-AND-MOTIVATION"><a href="#2-BACKGROUND-AND-MOTIVATION" class="headerlink" title="2 BACKGROUND AND MOTIVATION"></a>2 BACKGROUND AND MOTIVATION</h2><p>为了解决 Bitcoin 和 Ethereum 的性能瓶颈，大家都做了很多努力。</p><p>在并行执行研究上，通过调查以太坊的历史工作负载，我们发现必须按顺序执行的一系列交易的许多关键路径都是由<strong>共享全局计数器</strong>的使用引起的。我们认为，进一步提高实际工作负载并行性的重要方法是引入更好的编程范式，使开发人员能够更容易地表达并行性，同时保持原始语义。并且需要对激励机制进行一些新的设计，以使该范式适用于现实世界的应用。</p><h2 id="3-EMPIRICAL-STUDY"><a href="#3-EMPIRICAL-STUDY" class="headerlink" title="3 EMPIRICAL STUDY"></a>3 EMPIRICAL STUDY</h2><h3 id="3-1-Methodology"><a href="#3-1-Methodology" class="headerlink" title="3.1 Methodology"></a>3.1 Methodology</h3><p>我们使用以太坊历史交易对现实世界数据集（2018 年 1 月 1 日到 2018 年 5 月 28 日共 8582236 个区块）中存在的并行性进行了实证研究。本实验的主题是智能合约存储冲突，即同一块内的两个交易访问状态树中的同一条目，并且这些访问中至少有一个是写入。</p><p>考虑到交易的执行时间是未知的，并且可能因节点而异，我们使用从交易收据中获得的 gas 成本作为近似值。</p><p>从交易的状态访问跟踪和 gas 成本导出的依赖性，我们为每个块构建了一个依赖图。然后，模拟在 2、4、8、16 和 32 个线程上的非抢占式执行，我们为每个块构建了一个最优调度。确保不需要中止任何交易的调度，同时最大限度地提高线程利用率。在这种执行模型下，该计划的总体执行成本为我们能够实现的潜在加速设定了上限。</p><h3 id="3-2-Results-and-Findings"><a href="#3-2-Results-and-Findings" class="headerlink" title="3.2 Results and Findings"></a>3.2 Results and Findings</h3><ul><li><p><em>Execution Bottlenecks.</em> 该实验揭示了我们在并行执行以太坊交易时可以实现的加速限制。我们发现，与串行执行相比，观察到的总体加速仅为 4 倍，考虑到我们有 8 个、16 个甚至更多的线程可用，这一结果并不令人满意。许多区块的加速效率很高，但也有相当一部分区块的性能很差。</p><p>  <img src="/Taming-Conflicts/1.png" alt="Distribution of parallel speedup bounds"></p><p>  将一个块的执行成本与其依赖图中最重路径的执行成本进行比较时，我们发现这两者经常重合，这意味着性能瓶颈在最重路径的执行上。</p></li><li><p><em>Classification of Smart Contract Conflicts.</em> 我们确定了三大类：ERC20 代币（代币分发、空投）占样本瓶颈的 60%，去中心化金融（DeFi）应用程序占 29%，而游戏和收藏品（不可替代代币、NFT）占 10%。</p></li><li><p><em>Bottleneck Code Examples.</em></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs code">function transfer(address _to , uint256 _val) /* ... */ &#123;<br>    balances[msg.sender] -= _val ; // &lt;&lt;&lt;<br>    balances[_to] += _val ;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用 transfer 时，发送者的余额被记 debited，而接收者的余额被记 credited。发送方的余额对应于状态树中的一个特定存储位置。借记操作将编译为加载（SLOAD）、添加（ADD）和存储（SSTORE）操作等。当两个交易同时从同一个发送方地址触发此函数时，将导致冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs code">function _createKitty(/* ... */) /* ... */ &#123;<br>    uint256 newKittenId = kitties.push(_kitty) - 1; // &lt;&lt;&lt;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在以太坊流行的 CryptoKitties 游戏中，每个新的收藏品都存储在一个数组中。Solidity 数组上的 push 操作将修改两个存储条目：首先，它将把新项目存储在从数组长度导出的位置，其次，它将增加数组长度。两个并发交易都会修改数组长度，因此它们会发生冲突。</p><h3 id="3-3-Generalizability-of-the-Observations"><a href="#3-3-Generalizability-of-the-Observations" class="headerlink" title="3.3 Generalizability of the Observations"></a>3.3 Generalizability of the Observations</h3><p>我们相信所选择的时间段代表了当今以太坊的工作量，因此我们的发现是普遍的。</p><h2 id="4-AVOIDING-APPLICATION-INHERENT-CONFLICTS"><a href="#4-AVOIDING-APPLICATION-INHERENT-CONFLICTS" class="headerlink" title="4 AVOIDING APPLICATION INHERENT CONFLICTS"></a>4 AVOIDING APPLICATION INHERENT CONFLICTS</h2><p>由第三章可以看出，很大一部分存储冲突与计数器或数组的存储槽相关联。这里所说的计数器（counter）是指一个变量，无论其当前值如何，都可以通过递增或递减来跟踪一个量。Solidity 中的数组（Arrays）是一种简单的数据结构，用于存储元素序列和元素数量。</p><p>为了减轻交易瓶颈链的影响，我们需要通过消除所涉及的交易子集之间的依赖关系，将它们分解为多个较短的链：</p><p><img src="/Taming-Conflicts/2.png" alt="Breaking up a conflict chain into multiple disjoint conflict chains"></p><ul><li><p><em><strong>Technique 1: Conflict-Aware Token Distribution.</strong></em> 我们发现代币分发是迄今为止瓶颈冲突最常见的来源。在大多数情况下，冲突的来源是存储发送者帐户当前余额的条目。</p><p>  最简单方法是使用多个发送者地址。通过将初始资金（在适用的情况下）分配给一组发送方账户，而不是单个账户，并对连续的交易使用不同的发送方地址，我们可以将瓶颈交易集划分为不相交的冲突交易集，每个交易集都不太可能形成瓶颈。</p></li><li><p><em><strong>Technique 2: Partitioned Counters.</strong></em> 使用一种类似于 Linux 内核中 sloppy counters 的技术，我们提出了一种将同一计数器上的多个写入路由到多个不同存储条目的方法。由于对不同存储条目的写入不会发生冲突，因此可以大幅降低冲突率。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs code">contract PartitionedCounter &#123; // LEN = 3<br>    int256[LEN] public cnt;<br><br>    function add(uint32 n) internal &#123;<br>        uint8 slot = uint8(tx.origin) % LEN<br>        cnt[slot] += n;<br>    &#125;<br><br>    function get() internal view returns (int256 sum) &#123;<br>        for (uint8 i = 0; i &lt; LEN; ++i) &#123;sum += cnt[i];&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里我们有一个单独的合约，它代表一个计数器实例。计数器的值实际上保存在 3 个称为子计数器的独立存储条目上。每次交易修改计数器的值时，我们都会根据发送方地址分配一个子计数器。由于地址是使用加密哈希导出的，因此可以将其视为伪随机子计数器分配。读取计数器的值时，将访问所有子计数器，并对其值进行求和。</p><p>  给定交易的写入操作即使多次递增计数器也都将在单个存储条目上进行，因为在整个交易执行过程中，发送方地址不会更改。来自两个不同发送方地址的两个交易都增加了计数器，但在同一子计数器上操作的机会大大减少，因此通常可以避免冲突。也可以根据计数器使用频率分派不同的子计数器数量和路由规则（本例是根据发送方地址）。</p><p>  此方案的缺点在于虽然我们只需要访问一个存储条目来写入计数器，但读取它将涉及到所有子计数器。因此，任何读取计数器的交易都将与所有写入交易发生冲突。因此，这种技术适用于 write-heavy 计数器。幸运的是，我们分析的许多计数器从来都不是通过交易读取的。其次，分区计数器可能比内置整数开销大得多，尤其是在读取计数器时。分区计数器提供的并行加速抵消了这一缺点。</p></li><li><p><em><strong>Technique 3: Commutative EVM Instructions.</strong></em> 我们已经讨论了两种方法。一种是在应用程序级别，通过引入与应用程序交互的特定方式来解决冲突。另一种是在智能合约层面上，通过向合约开发人员提供工具来避免冲突。第三种方法是通过使用具有更好的冲突容忍度的新指令来扩展协议，从而在虚拟机级别上解决冲突。</p><p>  当以太坊虚拟机（EVM）执行增量操作时，它首先将存储条目的当前值加载到内存中（SLOAD），然后修改该值（ADD），最后将最终结果存储回存储条目中（SSTORE）。两个交易递增同一计数器将同时读取和写入同一存储条目，因此它们将发生冲突。</p><p>  对于计数器增量，当前值仅用于计算新值，所以与其他读写冲突不同，增量是可交换的（commutative），即递增同一计数器但不使用其值的两个交易可以按任何顺序执行。然而，在 EVM 的当前语义下，这样的交易将发生冲突。</p><p>  我们引入了特殊的语义，用于以不会导致冲突的方式执行增量。将增量编译成一条代表交换加法的 CADD 指令，而不是编译成 SSLOAD 和 SSTORE 指令。此指令以一个存储位置和一个值作为其参数。当虚拟机遇到 CADD 指令时，它不会立即执行加法，而是将此操作记录在内存临时存储器中。如果虚拟机遇到 SSTORE 操作，则会移除同一存储位置上挂起的 CADD 指令，因为它们已经被覆盖。如果虚拟机遇到 SLOAD 操作，它将首先在同一存储位置上执行所有挂起的 CADD 操作，然后将结果用于此 SLOAD。</p><p>  在交易被执行之后，调度程序继续检查冲突。对同一存储位置的并发读取和写入构成冲突，但是如果两个交易在一个存储位置上只有 CADD 操作，而没有其他读取操作，则不认为它们有冲突。在这种情况下，这些 CADD 操作是在提交阶段是串行执行的。引入 CADD 指令以向 VM 发送交换操作的信号，使我们能够避免源自单个计数器上的主要交易冲突。</p></li></ul><h2 id="5-OCC-WITH-DETERMINISTIC-ABORTS"><a href="#5-OCC-WITH-DETERMINISTIC-ABORTS" class="headerlink" title="5 OCC WITH DETERMINISTIC ABORTS"></a>5 OCC WITH DETERMINISTIC ABORTS</h2><h3 id="5-1-Incentives-in-Parallel-Scheduling"><a href="#5-1-Incentives-in-Parallel-Scheduling" class="headerlink" title="5.1 Incentives in Parallel Scheduling"></a>5.1 Incentives in Parallel Scheduling</h3><p>并行调度器的效率取决于各种因素，其中一些因素在用户的控制之下。因此，并行执行必须有一套激励措施，以最大限度地提高其有效性。这种激励制度的详细设计超出了本文的范围。</p><p>基于 OCC 的并行执行不可避免地会导致一些事务中止和重新执行。如果允许用户在没有任何惩罚的情况下故意触发中止，就会导致调度器的 DoS 漏洞。因此，我们的目标是定义一个执行框架，允许调度器通过对交易的重新执行进行确定性定价。</p><h3 id="5-2-Levels-of-Determinism"><a href="#5-2-Levels-of-Determinism" class="headerlink" title="5.2 Levels of Determinism"></a>5.2 Levels of Determinism</h3><p>因为交易的精确时间可能因节点而异，并行调度器在执行中引入了一定程度的非确定性。这与共识机制依赖于节点严格收敛到相同状态的要求直接冲突。因此区块链系统与传统算法相比，并行调度器必须保持更高水平的确定性。我们在乐观事务执行中定义了以下三个确定性级别：</p><ol><li><p><strong>Classic OCC</strong>： first-come-first-served 的执行方式。没有确定性保证，交易在执行完后立即提交，不考虑其在区块中的顺序，不同节点最终结果可能不一致。</p></li><li><p><strong>OCC with deterministic commit order</strong>：交易的提交操作会延迟到区块中前一个交易提交后。这意味着不同节点上的最终执行结果将是相等的，即使实际执行顺序可能不同。通过严格按照块交易顺序提交，或者根据依赖图进行调度，可以满足这一要求。</p></li><li><p><strong>OCC with deterministic aborts</strong>：交易只能看到在执行之前决定的状态版本（即使有更新的版本可用）。交易的每次执行都将在所有节点上提交或中止。虽然确定性顺序保证所有节点的可观察输出（结果状态）相同，但实际执行可能仍然不同：由于交易的时间不同，交易可能在一个节点上提交，而在另一个节点则中止。如果协议依赖于此提交&#x2F;中止决定来惩罚中止并避免 DoS 攻击，这将导致不同的状态。所以我们的目标是中止本身具有确定性：如果交易在一个节点上中止一次，那么在所有其他节点上也会中止一次。</p></li></ol><h3 id="5-3-OCC-DA-OCC-with-Deterministic-Aborts"><a href="#5-3-OCC-DA-OCC-with-Deterministic-Aborts" class="headerlink" title="5.3 OCC-DA: OCC with Deterministic Aborts"></a>5.3 OCC-DA: OCC with Deterministic Aborts</h3><p>我们的执行模型基于快照隔离（snapshot isolation）的 OCC。交易被安排在一组线程上执行，已执行的交易是根据块交易顺序提交的。在执行开始时，每个交易都会接收对应于存储版本的快照，此快照在交易执行过程中不会更改。</p><p>例如，假设交易 #1 已经被提交，交易 #2 正在一个线程上执行，而我们正在另一个线程调度交易 #3。在这种情况下，#3 可以看到存储版本 #1（直到并包括 #1 的写入的存储内容）。如果在 #3 的执行过程中，#2 修改了一些存储值，那么这些更新对 #3 来说是不可见的。如果在 #3 的提交期间，调度器检测到 #3 读取的一些值被 #2 同时修改，即 #3 对过时的值进行了操作，#3 将中止并被重新执行。</p><p><strong>OCC-DA 定义如下</strong>：<br>在执行之前，我们为每个交易的每次执行分配一个存储版本（storage version）：<code>(𝑡𝑥𝑛,𝑖) → 𝑠𝑣𝑛,𝑖</code>。<code>(𝑡𝑥𝑛,𝑖)</code> 代表 𝑖 次执行交易 #n，其中 𝑖 &#x3D; 0, 1, 2, … 根据调度程序的实现，交易可以执行两次或多次。最后一次执行必须提交，而之前的所有执行都将中止。对于在执行单元中（例如在块中）的所有交易 #n 的所有可能的执行，<code>𝑠𝑣𝑛,𝑖</code> 在所有节点上统一定义，并且在执行之前进行定义，从而不受不确定性的执行影响。对于任何 <code>(𝑡𝑥𝑛,𝑖)</code>, 交易 #n 将在所有节点上中止或提交。</p><p>在 <code>(𝑡𝑥𝑛,𝑖)</code> 执行过程中, 调度程序必须允许交易访问 <code>𝑠𝑣𝑛,𝑖</code> 之前且包括此交易写入的存储条目。调度程序不得允许交易访问由 id 高于 <code>𝑠𝑣𝑛,𝑖</code> 的交易写入的存储条目。如果 <code>𝑠𝑣𝑛,𝑖</code> 尚未提交，交易无法开始执行，必须等待。</p><h3 id="5-4-Example"><a href="#5-4-Example" class="headerlink" title="5.4 Example"></a>5.4 Example</h3><p>有 4 笔交易，标记为 #1 到 #4。#1 和 #3 存在存储冲突：#1 写入由 #3 读取的存储条目。然后，让我们在不同的决定论保证下，在两个不同的节点上调度这四个交易，每个节点有2个线程。</p><p><img src="/Taming-Conflicts/3.png" alt="三个级别"></p><ul><li><p>左图是使用经典 OCC 的调度示例。这种方法没有确定性的保证。特别地，我们可以看到节点 A 上的提交顺序是 #1-#2-#3-#4，而节点B上是 #3-#2-#1-#4。两个冲突交易的不同相对顺序（#1-#3，#3-#1）可能导致两个节点的状态不一致。虽然 #1 和 #3 冲突，但在本例中，它们不是同时执行的，因此都不需要中止。</p></li><li><p>中间的图中，我们看到了一个具有确定性提交顺序的 OCC 示例。在节点 B 上，#3 在 #1 之前完成执行，此时检测到冲突并中止 #3，直到 #1 完成之后才提交。节点 A 和 B 上的最终提交顺序是 #1-#2-#3-#4。由于 #1 和 #3 在两个节点上执行的相对顺序不同，#3 的第一次执行在节点 A 上提交，而在节点 B 上中止。在分布式共识中，这种不确定性是不可接受的。</p></li><li><p>右图显示了 OCC-DA 的工作原理。在执行之前，所有节点都决定 #3 的第一次执行只能读取 #1 执行之前的状态 (<code>𝑠𝑣3,0 := 0</code>)，而第二次执行可以看到 #2 之后的状态 (<code>𝑠𝑣3,1 := 2</code>)。因此，即使在节点 A 中 #3 被安排的 #1 之后，它无法获得 #1 的写入并将中止。这与节点 B 上 #3 与 #1 同时执行的结果一致。第二次执行 #3 将在节点 A 和 B 上获得最新状态，因此它将在两个节点上提交。</p></li></ul><h3 id="5-5-Assigning-Storage-Versions"><a href="#5-5-Assigning-Storage-Versions" class="headerlink" title="5.5 Assigning Storage Versions"></a>5.5 Assigning Storage Versions</h3><p>依赖两种信息：</p><ul><li>首先，我们可以使用交易的预期执行时间来查找交易预期读取的最新存储版本。假如 #3 将在 #1 之后但在 #2 之前开始执行，我们设置 <code>𝑠𝑣3,0 := 1</code>。</li><li>其次，我们通过对事务依赖关系图的估计来允许预防中止。例如，如果我们猜测 #3 可能与 #1 冲突，那么我们可以设置 <code>𝑠𝑣3,0 &gt;= 1</code>。</li></ul><p>存储版本分配的准确性直接影响并行调度程序的性能：如果我们使用的存储版本太低，那么我们就有可能引入更多的中止。如果我们使用的存储版本太高，那么交易可能需要一直等待存储版本可用，从而导致线程利用率不足。</p><h3 id="5-6-The-Algorithm"><a href="#5-6-The-Algorithm" class="headerlink" title="5.6 The Algorithm"></a>5.6 The Algorithm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Algorithm">Input: Transactions 𝑇, gas 𝐺𝑎𝑠, number of threads 𝑡, none or a dependency graph 𝐷<br><br>𝐻𝑡𝑥𝑠 ← an empty minheap of (𝑠𝑣, 𝑖𝑑) ;<br>for 𝑖𝑑 ∈ [0, |𝑇|) do<br>    if 𝐷 exists then<br>        𝑖𝑑𝑚𝑎𝑥 ← −1 ;<br>        for edge (𝑖𝑑, 𝑖𝑑𝑝𝑟𝑒𝑣) ∈ 𝐷 do<br>            //tx_𝑖𝑑 depends on tx_𝑖𝑑𝑝𝑟𝑒𝑣<br>            //tx_𝑖𝑑 reads what tx_𝑖𝑑𝑝𝑟𝑒𝑣 writes<br>            𝑖𝑑𝑚𝑎𝑥 ← 𝑚𝑎𝑥(𝑖𝑑𝑚𝑎𝑥, 𝑖𝑑𝑝𝑟𝑒𝑣) ;<br>        𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((𝑖𝑑𝑚𝑎𝑥, 𝑖𝑑)) ;<br>    else<br>        𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((−1, 𝑖𝑑)) ;<br><br>𝐻𝑟𝑒𝑎𝑑𝑦 ← an empty minheap of (𝑖𝑑, 𝑠𝑣) ;<br>𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠 ← an empty minheap of (𝑔𝑎𝑠, 𝑖𝑑, 𝑠𝑣) ;<br>𝐻𝑐𝑜𝑚𝑚𝑖𝑡 ← an empty minheap of (𝑖𝑑, 𝑠𝑣) ;<br>𝑛𝑒𝑥𝑡 ← 0 ;<br><br>while 𝑛𝑒𝑥𝑡 &lt; |𝑇| do<br>    //Stage 1 : Schedule<br>    for (𝑠𝑣, 𝑖𝑑) ← 𝐻𝑡𝑥𝑠.𝑝𝑜𝑝() do<br>        if 𝑠𝑣 &gt; 𝑛𝑒𝑥𝑡 − 1 then<br>            𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((𝑠𝑣, 𝑖𝑑)) ;<br>            break<br>        else<br>            𝐻𝑟𝑒𝑎𝑑𝑦.𝑝𝑢𝑠ℎ((𝑖𝑑, 𝑠𝑣)) ;<br>    while |𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠| &lt; 𝑝𝑜𝑜𝑙_𝑠𝑖𝑧𝑒 and |𝐻𝑟𝑒𝑎𝑑𝑦| &gt; 0 do<br>        (𝑖𝑑, 𝑠𝑣) ← 𝐻𝑟𝑒𝑎𝑑𝑦.𝑝𝑜𝑝 () ;<br>        𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠.𝑝𝑢𝑠ℎ((𝐺𝑎𝑠[𝑖𝑑], 𝑖𝑑, 𝑠𝑣)) ;<br>    //Stage 2 : Execution<br>    if |𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠| &gt; 0 then<br>        (𝑔𝑎𝑠, 𝑖𝑑, 𝑠𝑣) ← 𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠.𝑝𝑜𝑝 () ;<br>        𝐻𝑐𝑜𝑚𝑚𝑖𝑡 ← (𝑖𝑑, 𝑠𝑣) ;<br>        for 𝑖 ∈ [0, |𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠|) do<br>            𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠[𝑖].𝑔𝑎𝑠 ← 𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠[𝑖].𝑔𝑎𝑠 − 𝑔𝑎𝑠 ;<br>    //Stage 3 : Commit/Abort<br>    while |𝐻𝑐𝑜𝑚𝑚𝑖𝑡| &gt; 0 do<br>        (𝑖𝑑, 𝑠𝑣) ← 𝐻𝑐𝑜𝑚𝑚𝑖𝑡.𝑝𝑜𝑝() ;<br>        if 𝑖𝑑 ≠ 𝑛𝑒𝑥𝑡 then<br>            𝐻𝑐𝑜𝑚𝑚𝑖𝑡.𝑝𝑢𝑠ℎ((𝑖𝑑, 𝑠𝑣)) ;<br>            break<br>        for 𝑖𝑑𝑝𝑟𝑒𝑣 ∈ [𝑠𝑣 + 1, 𝑖𝑑 − 1] do<br>            if tx_𝑖𝑑𝑝𝑟𝑒𝑣’s write set ∩ tx_𝑖𝑑’s read set ≠ ∅ then<br>                get Aborted ;<br>                break<br>        if Aborted then<br>            𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((𝑖𝑑 − 1, 𝑖𝑑)) ;<br>        else<br>            //Commit successfully<br>            𝑛𝑒𝑥𝑡 ← 𝑛𝑒𝑥𝑡 + 1 ;<br>return<br></code></pre></td></tr></table></figure><p>该算法将一组交易及其依赖项作为输入。依赖图可以通过估计每个交易的读写集来构建。估计不一定是完美的，但它需要在所有区块链节点上具有确定性和一致性。它越精确，我们可能遇到的不必要中断就越少。</p><p>根据依赖关系图，每个交易的存储版本被初始化为它所依赖交易的最大 id，如果没有依赖关系，则为 −1。交易被加入最小堆 𝐻𝑡𝑥𝑠 并按存储版本索引。还有另外三个最小堆：𝐻𝑟𝑒𝑎𝑑𝑦 维护准备好被调度的交易，𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠 是用于执行交易的线程池，𝐻𝑐𝑜𝑚𝑚𝑖𝑡 用于已完成执行并等待提交的交易。全局变量 𝑛𝑒𝑥𝑡 维护下一个要提交交易的 id。接下来：</p><ul><li><p><strong>Stage 1</strong>：将交易调度到线程池中。当与其存储版本对应的交易已提交时，我们认为该交易已准备好执行。如果线程池有空槽，交易将被推入线程池。</p></li><li><p><strong>Stage 2</strong>：线程池中交易的执行。我们选择剩余 gas 最少的交易，即是 𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠 的顶部元素，把它推入 𝐻𝑐𝑜𝑚𝑚𝑖𝑡。</p></li><li><p><strong>Stage 3</strong>：逐个尝试提交在 𝐻𝑐𝑜𝑚𝑚𝑖𝑡 中的交易。𝐻𝑐𝑜𝑚𝑚𝑖𝑡 中的交易按照 id 的顺序进行维护，因为我们总是按顺序提交。对于每个交易，算法通过检查当前交易和自开始执行以来提交的交易之间是否存在读写冲突来判断中止或提交。如果中止，交易将被推回到 𝐻𝑡𝑥𝑠 其新存储版本设置为 𝑖𝑑 − 1。</p></li></ul><h2 id="6-EVALUATION"><a href="#6-EVALUATION" class="headerlink" title="6 EVALUATION"></a>6 EVALUATION</h2><h3 id="6-1-Experimental-Setup"><a href="#6-1-Experimental-Setup" class="headerlink" title="6.1 Experimental Setup"></a>6.1 Experimental Setup</h3><p>我们首先构建交易的依赖图，其中顶点（对应于交易）由消耗的 gas 加权。然后我们模拟在一组线程（2、4、8、16、32）上调度事务。</p><h3 id="6-2-Assumptions-and-Limitations"><a href="#6-2-Assumptions-and-Limitations" class="headerlink" title="6.2 Assumptions and Limitations"></a>6.2 Assumptions and Limitations</h3><p>我们的评估是基于使用真实数据的模拟，而不是基于在真实区块链系统中的实现。</p><h3 id="6-3-Evaluation-Results"><a href="#6-3-Evaluation-Results" class="headerlink" title="6.3 Evaluation Results"></a>6.3 Evaluation Results</h3><p>略</p><h2 id="7-THREATS-TO-VALIDITY"><a href="#7-THREATS-TO-VALIDITY" class="headerlink" title="7 THREATS TO VALIDITY"></a>7 THREATS TO VALIDITY</h2><p>略</p><h2 id="8-RELEVANCE-AND-FUTURE-WORK"><a href="#8-RELEVANCE-AND-FUTURE-WORK" class="headerlink" title="8 RELEVANCE AND FUTURE WORK"></a>8 RELEVANCE AND FUTURE WORK</h2><p>略</p><h2 id="9-RELATED-WORK"><a href="#9-RELATED-WORK" class="headerlink" title="9 RELATED WORK"></a>9 RELATED WORK</h2><p>略</p><h2 id="10-CONCLUSION"><a href="#10-CONCLUSION" class="headerlink" title="10 CONCLUSION"></a>10 CONCLUSION</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(6)：架构初探</title>
    <link href="/ByteDance-6/"/>
    <url>/ByteDance-6/</url>
    
    <content type="html"><![CDATA[<p>本文简单介绍关于架构的知识。</p><span id="more"></span><h2 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>Q：如何给架构下定义？</strong></p><p>A：架构，又称软件架构：</p><ul><li>是有关软件整体结构与组件的抽象描述。</li><li>用于指导软件系统各个方面的设计。</li></ul><p>实现一个软件有很多种方法，架构在<strong>方法选择</strong>上起着至关重要的指导作用。</p><p><strong>Q：架构的重要性？</strong></p><p>A：拿盖房子来做举例子。</p><p>我们都知道，地基对于一栋楼房的主要性，架构对于一个软件的重要性也是类似的：</p><ul><li>架构没设计好，软件容易崩，用户体验上不去。最终要么重构，要么放弃。</li><li>架构设计好了，软件的稳定性上去了，用户体验高了，口碑一点点就打造出来了。</li><li>良好的架构基础，也为软件的未来发展提供了更多的可能。为用户赋能，实现自身价值。</li></ul><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p>All in one，所有的东西都在一个进程里，部署在一个机器上。</p><p><img src="/ByteDance-6/1.png" alt="单机"></p><p>优点：</p><ul><li>简单</li></ul><p>缺点：</p><ul><li>运维需要停服，用户体验较差</li><li>承载能力有限（c10k 问题）</li></ul><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>在单机架构的基础上，将进程部署到多个机器上。</p><p><img src="/ByteDance-6/2.png" alt="单体"></p><p>优点：</p><ul><li>具备水平扩容能力</li><li>运维不需要停服</li></ul><p>缺点：</p><ul><li>后端进程职责太多，越来越臃肿</li><li>爆炸半径较大，进程中一个很小的模块出现问题，都可能导致整个进程崩溃</li></ul><h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>在单机架构基础上，将进程按照某种依据切分开。比如，A 软件和 B 软件的后端原先采用单机架构部署，那就是一个进程部署在多个机器上；如果用垂直应用架构，可以将 A 和 B 的后端拆分为 A、B 两个进程，然后再按照单体模式的思路，部署在多个机器上。</p><p><img src="/ByteDance-6/3.png" alt="垂直"></p><p>优点：</p><ul><li>一定程度上减少了后端进程职责</li><li>一定程度上缩小爆炸半径</li></ul><p>缺点：</p><ul><li>没有根本解决单体架构的问题</li></ul><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p>SOA（Service-Oriented Architecture，面向服务架构）中，服务为一等公民，将进程按照不同的功能单元进行抽象，拆分为『服务』。有了服务之后，SOA 还为服务之间的通信定义了标准，保证各个服务之间通讯体验的一致性。</p><p><img src="/ByteDance-6/4.png" alt="SOA"></p><p>优点：</p><ul><li>各服务的职责更清晰</li><li>运维粒度减小到服务，爆炸半径可控</li></ul><p>缺点：</p><ul><li>ESB (企业服务总线) 往往需要一整套解决方案</li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>在 SOA 架构中，ESB 起到了至关重要的作用。但从架构拓扑来看，它更像是一个集中式的模块。有一个 SOA 去中心化演进的分支，最终的形态便是微服务。</p><p><img src="/ByteDance-6/5.png" alt="微服务"></p><p>优点：</p><ul><li>兼具 SOA 解决的问题</li><li>服务间的通信更敏捷、灵活</li></ul><p>缺点：</p><ul><li>运维成本</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>架构演进的初衷：满足软件迭代诉求，提高迭代效率</p></li><li><p>架构演进的思路：垂直切分——分布式，水平切分——分层&#x2F;模块化</p></li></ul><h2 id="企业级后端架构剖析"><a href="#企业级后端架构剖析" class="headerlink" title="企业级后端架构剖析"></a>企业级后端架构剖析</h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>是指通过软件自动化管理，提供计算资源的服务网络，是现代互联网大规模熟悉分析和存储的基石。</p><p><strong>云计算基础：</strong></p><ul><li><p>虚拟化技术</p><ul><li>硬件层面（VM 虚拟机）- KVM&#x2F;Xen&#x2F;VMware</li><li>操作系统层面（Container 容器）- LCX&#x2F;Docker&#x2F;Kata Container</li><li>网络层面 - Linux Bridge&#x2F;Open v Switch</li></ul></li><li><p>编排方案</p><ul><li>VM - OpenStack&#x2F;VMWare Workstation</li><li>Container - Kubernetes&#x2F;Docker Swarm</li></ul></li></ul><p><strong>云计算架构：</strong></p><ul><li><p>云服务</p><ul><li>IaaS - Infrastructure as a Service，云基础设施，对底层硬件资源池的抽象</li><li>PaaS - Platform as a Service，基于资源池抽象，对上层提供的弹性资源平台</li><li>SaaS - Software as a Service，基于弹性资源平台构建的云服务</li><li>FaaS - Function as a Service，更轻量级的函数服务。好比 LeetCode 等 OJ，刷题时只需要实现函数，不需要关注输入输出流</li></ul></li><li><p>云部署模式</p><ul><li>私有云 - 企业自用</li><li>公有云 - AWS&#x2F;Azure&#x2F;Google Cloud&#x2F;Huawei</li><li>混合云</li></ul></li></ul><h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><p>云原生，实际是云原生计算的简称，它是云计算发展到现在的一种形态。</p><p><img src="/ByteDance-6/6.png" alt="云原生"></p><p>云原生技术为组织（公司）在公有云、自由云、混合云等新型的动态环境中，构建和运行可弹性拓展的应用提供了可能。 它的代表技术：</p><ul><li>弹性资源</li><li>微服务架构</li><li>DevOps</li><li>服务网格</li></ul><h4 id="弹性资源"><a href="#弹性资源" class="headerlink" title="弹性资源"></a>弹性资源</h4><p>基于虚拟化技术，提供的可以快速扩缩容的能力。可以分为<strong>弹性计算资源</strong>和<strong>弹性存储资源</strong>两个方面。</p><ul><li><p><strong>弹性计算资源：</strong></p><ul><li><p>计算资源调度</p><ul><li>在线计算 - 互联网后端服务</li><li>离线计算 - 大数据分析。Map-Reduce&#x2F;Spark&#x2F;Flinnk</li></ul></li><li><p>消息队列</p><ul><li>在线队列 - 削峰、解耦</li><li>离线队列 - 结合数据分析的一整套方案，如 ELK</li></ul></li></ul></li><li><p><strong>弹性存储资源：</strong></p><ul><li><p>经典存储</p><ul><li>对象存储 - 视频、图片等。结合 CDN 等技术，可以为应用提供丰富的多媒体能力</li><li>大数据存储 - 应用日志、用户数据等。结合数据挖掘、机器学习等技术，提高应用的体验</li></ul></li><li><p>关系型数据库</p></li><li><p>元数据</p><ul><li>服务发现</li></ul></li><li><p>NoSQL</p><ul><li>KV 存储 - Redis</li><li>文档存储 - Mongo</li></ul></li></ul></li></ul><p>在云原生的大背景下，不论是计算资源还是存储资源，他们都像是服务一样供用户使用。</p><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p>DevOps 是云原生时代软件交付的利器，贯穿整个软件开发周期。结合自动化流程，提高软件开发、交付效率。</p><p><img src="/ByteDance-6/7.png" alt="DevOps"></p><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>微服务架构下，服务之间的通讯标准是基于协议而不是 ESB 的。</p><ul><li>HTTP - H1&#x2F;H2</li><li>RPC - Apache Thrift&#x2F;gRPC</li></ul><p><img src="/ByteDance-6/8.png" alt="微服务"></p><p>如何在 HTTP 和 RPC 之间选择？</p><ul><li>性能 - RPC 协议往往具备较好的压缩率，性能较高。如 Thrift, Protocol Buffers</li><li>服务治理 - RPC 中间件往往集成了丰富的服务治理能力。如 熔断、降级、超时等</li><li>可解释性 - HTTP 通信的协议往往首选 JSON，可解释性、可调试性更好</li></ul><h4 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h4><ul><li>微服务之间通讯的中间层</li><li>一个高性能网络代理</li><li>将流量层面的逻辑与业务进程解耦</li></ul><p><img src="/ByteDance-6/9.png" alt="Service Mesh"></p><p>没有什么是加一层代理解决不了的问题，服务网格相比较于 RPC&#x2F;HTTP 框架：</p><ul><li>实现了异构系统治理的统一化</li><li>服务网格的数据平面代理与业务进程采取进程间通信的模式，使得流量相关的逻辑（包含治理）与业务进程解耦，生命周期也更容易管理</li></ul><h2 id="企业级后端架构的挑战"><a href="#企业级后端架构的挑战" class="headerlink" title="企业级后端架构的挑战"></a>企业级后端架构的挑战</h2><ul><li><p>基础设施层面：</p><p>  Q：我们总说，云是弹性的，也就是说，在用户的角度，云提供的资源是无限的。然而，云背后的物理资源是有限的。在企业级后端架构里，云如何解决近乎无限的弹性资源和有限的物理资源之间的矛盾？</p><p>  Q：闲时的资源就这么空着吗？如何提高资源利用率，提高物理资源的价值转换率？</p></li><li><p>用户层面：</p><p>  Q：上了云原生微服务后，服务之间的通信开销较大，应该如何做成本优化？</p><p>  Q：微服务看起来没有那么美好，抖动导致的运维成本较高，如何解决？</p><p>  Q：异构的物理环境应该对用户是透明的，如何屏蔽这些细节？</p></li></ul><h3 id="离在线资源并池"><a href="#离在线资源并池" class="headerlink" title="离在线资源并池"></a>离在线资源并池</h3><p>考虑到在线业务的潮汐性，物理资源的用量不是一成不变的。离在线资源并池，可以：</p><ul><li>提高物理资源利用率</li><li>提供更多的弹性资源</li></ul><p><img src="/ByteDance-6/10.png" alt="离在线资源并池"></p><h3 id="自动扩缩容"><a href="#自动扩缩容" class="headerlink" title="自动扩缩容"></a>自动扩缩容</h3><p>利用在线业务潮汐性自动扩缩容。</p><h3 id="微服务亲合性部署"><a href="#微服务亲合性部署" class="headerlink" title="微服务亲合性部署"></a>微服务亲合性部署</h3><p>微服务之间的通信成本较高，是否可以：</p><ul><li>形态上是微服务架构</li><li>通信上是单体架构</li></ul><p>亲合性部署，通过将微服务调用形态与资源调度系统结合，将一些调用关系紧密、通信量大的服务部署在同一个机器上，并且使用 IPC 代替 RPC 的方式，降低网络通信带来的开销。</p><p><img src="/ByteDance-6/11.png" alt="微服务亲合性部署"></p><ul><li>将满足亲合性条件的容器调度到一台宿主机</li><li>微服务中间件与服务网格通过共享内存通信</li><li>服务网格控制面实施灵活、动态的流量调度</li></ul><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><p>核心收益：</p><ul><li>提高微服务调用容错性</li><li>容灾</li><li>进一步提高开发效率，DevOps 发挥到极致</li></ul><p>解决思路：基于微服务中间件 &amp; 服务网格的流量治理</p><ul><li>熔断、重试</li><li>单元化</li><li>复杂环境（功能、预览）的流量调度</li></ul><h2 id="后端架构实战"><a href="#后端架构实战" class="headerlink" title="后端架构实战"></a>后端架构实战</h2><p><img src="/ByteDance-6/12.png"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 FastFabric: Scaling Hyperledger Fabric to 20,000 Transactions per Second</title>
    <link href="/Fast-Fabric/"/>
    <url>/Fast-Fabric/</url>
    
    <content type="html"><![CDATA[<p>本文重新构建了 Hyperledger Fabric，减少事务排序和验证期间的计算和 I&#x2F;O 开销，从而大大提高吞吐量，将交易吞吐量从每秒 3000 笔提高到 20000 笔。值得注意的是，本文的优化是即插即用的，不需要对 Fabric 进行任何接口更改。</p><span id="more"></span><h2 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h2><p>相比公链，许可链通常将共识和交易验证委托给选定的一组节点，从而减轻共识算法的负担。但即使在这种情况下，共识仍然是一个瓶颈。</p><p>本文中仔细研究了 Hyperledger Fabric 1.2 的设计，基于常见的系统设计技术设计并实现了几种体系结构优化，这些技术将系统 tps 提高了近 7 倍，从每秒 3000 提高到 20000，同时降低了块延迟。具体贡献如下：</p><ol><li><em>Separating metadata from data</em>：Fabric 中的共识层接收整个交易作为输入，但只需要 ID 来决定交易顺序。我们重新设计了 Fabric 的排序服务，使其仅使用交易 ID，从而大大提高了吞吐量。</li><li><em>Parallelism and caching</em>：交易验证的某些方面可以并行化，而其他地方可以从缓存交易数据中获益。我们重新设计了 Fabric 的交易验证服务，在 committers 中积极缓存未组装的块，同时并行化尽可能多的验证步骤，包括背书策略验证和语法验证。</li><li><em>Exploiting the memory hierarchy for fast data access on the critical path</em>：Fabric 保持全局状态的键值存储可以被轻量级的内存数据结构所取代，这些结构缺乏持久性保证，可以通过区块链本身来弥补。我们围绕轻量级哈希表重新设计了 Fabric 的数据管理层，该哈希表可以更快地访问关键交易验证路径上的数据，将不可变块的存储推迟到写优化的存储集群。</li><li><em>Resource separation</em>：提交者和背书者节点争夺资源。我们介绍了一种将这些角色转移到单独硬件的体系结构。</li></ol><h2 id="II-FABRIC-ARCHITECTURE"><a href="#II-FABRIC-ARCHITECTURE" class="headerlink" title="II. FABRIC ARCHITECTURE"></a>II. FABRIC ARCHITECTURE</h2><h3 id="A-Node-types"><a href="#A-Node-types" class="headerlink" title="A. Node types"></a>A. Node types</h3><p>客户端发起交易，即对区块链的读取和写入，这些交易被发送到 Fabric 节点。节点要么是 peers，要么是 orderers；一些 peers 也是 endorsers。所有 peers 将区块提交到区块链的本地副本，并将相应的更改应用于维护当前世界状态快照的 state database。背书节点可以根据链码中的业务规则来证明交易是有效的。排序节点只负责决定交易顺序，而不验证正确性或有效性。</p><h3 id="B-Transaction-flow"><a href="#B-Transaction-flow" class="headerlink" title="B. Transaction flow"></a>B. Transaction flow</h3><ol><li>客户将其交易发送给一定数量的背书节点。</li><li>每个背书节点在沙盒中执行事务，并计算相应的读写集以及访问的每个键值的版本号。每个背书节点还使用业务规则来验证交易的正确性。</li><li>客户端等待足够数量的背书，然后将这些响应发送给排序节点。</li><li>排序节点首先对传入交易的顺序达成共识，然后将消息队列划分为块。</li><li>块被传递给对等节点，然后由对等节点验证并提交它们。</li></ol><h3 id="C-Implementation-details"><a href="#C-Implementation-details" class="headerlink" title="C. Implementation details"></a>C. Implementation details</h3><ul><li><p><em>Orderer</em></p><p>  客户端收到背书节点响应后，会创建一个包含 header 和 payload 的交易提案，header 包含交易 ID 和通道 ID，payload 包含读写集和其对应的版本号，以及背书节点的签名集。客户端对交易提案签名，并发送给排序服务。</p><p>  排序服务的两个目标：(a) 对交易排序达成共识，(b) 出块并发送给节点。本文中 Fabric 使用基于 ZooKeeper 的 Apache Kafka 来实现崩溃容错共识。</p><p>  当排序节点收到交易提案时，它会检查客户端是否有权提交交易。如果通过，排序节点将交易提案发布到 Kafka cluster，其中每个 Fabric 通道都映射到一个 Kafka topic，以创建相应的不可变的交易序列顺序。然后，每个排序节点根据每个块允许的最大交易数或超时时间，将从 Kafka 接收的交易组装成块，签名并使用 gRPC 将块传递给节点。</p></li><li><p><em>Peer</em></p><p>  在接收到来自排序服务的消息时，对等节点首先对块的头和元数据进行解码，并检查其语法结构。然后验证创建此块的排序节点的签名是否符合指定的策略。未通过这些测试的块将立即被丢弃。初始验证之后，区块被加入队列，从而保证其被添加到区块链中。之后块会依次经过两个验证步骤和一个提交步骤。</p><p>  在第一个验证步骤中，对块中的所有交易进行解码，检查它们的语法并验证它们的背书集。未通过的交易被标记为无效，但保留在块中。这一步使得恶意交易被排除。</p><p>  在第二个验证步骤中，节点确保有效交易间的相互作用不会导致无效的世界状态。回想一下，每一笔交易都携带一组需要从世界状态数据库读取的键（读集）和一组将写入数据库的键和值（写集），以及背书节点记录的版本号。在第二个验证步骤中，交易读写集中的每个键都必须具有相同的版本号。这样可以防止双重支付。</p><p>  在最后一步中，对等节点将块写入文件系统，该块现在包含交易的验证标志。根据应用程序的配置，键值（即世界状态）将持久化在 LevelDB 或 CouchDB 中。每个块及其交易的索引都存储在 LevelDB 中，以加快数据访问速度。</p></li></ul><h2 id="III-DESIGN"><a href="#III-DESIGN" class="headerlink" title="III. DESIGN"></a>III. DESIGN</h2><h3 id="A-Preliminaries"><a href="#A-Preliminaries" class="headerlink" title="A. Preliminaries"></a>A. Preliminaries</h3><p>使用拜占庭容错（BFT）共识算法是 HyperLedger 中的一个关键性能瓶颈。在我们的工作中，我们选择跳过这一明显的瓶颈，原因有三：</p><ul><li><p>在许可区块链中使用 BFT 协议并不像在无许可的系统中那么重要，因为所有参与者都是已知的，并被激励以诚实的方式保持系统运行。</p></li><li><p>BFT 共识正在被广泛研究，我们预计在未来一两年内会出现更高吞吐量的解决方案。</p></li><li><p>在实践中，Fabric 1.2 不使用 BFT 共识协议，而是依赖于 Kafka 进行交易排序，如前所述。</p></li></ul><h3 id="B-Orderer-improvement-I-Separate-transaction-header-from-payload"><a href="#B-Orderer-improvement-I-Separate-transaction-header-from-payload" class="headerlink" title="B. Orderer improvement I: Separate transaction header from payload"></a>B. Orderer improvement I: Separate transaction header from payload</h3><p>在 Fabric 1.2 中，使用 Apache Kafka 的排序节点将整个交易发送给 Kafka 进行排序。交易的长度可能是几千字节，这会导致高通信开销，从而影响整体性能。然而，在交易顺序上获得共识只需要交易 ID，因此我们可以通过只向 Kafka 发送交易 ID 来显著提高排序节点的吞吐量。具体来说，在从客户端接收到交易时，排序节点从 header 中提取交易 ID，并将该 ID 发布到 Kafka 集群。排序节点将相应的 payload 单独存储在本地数据结构中，当从 Kafka 收到 ID 时，交易将重新组装。</p><h3 id="C-Orderer-improvement-II-Message-pipelining"><a href="#C-Orderer-improvement-II-Message-pipelining" class="headerlink" title="C. Orderer improvement II: Message pipelining"></a>C. Orderer improvement II: Message pipelining</h3><p>在 Fabric 1.2 中，排序服务逐个处理来自客户端的传入交易。当交易到达时，识别其对应的通道，根据一组规则检查其有效性，最后将其转发到共识系统（Kafka），然后才能处理下一笔交易。我们实现了一种流水线机制，可以同时处理多个传入交易，即使它们来自使用相同 gRPC 连接的同一客户端。为此，我们维护了一个并行处理传入请求的线程池，每个传入请求有一个线程。线程调用 Kafka API 来发布交易 ID，并在成功时向客户端发送响应。</p><p><img src="/Fast-Fabric/1.png" alt="New orderer architecture"></p><h3 id="D-Peer-tasks"><a href="#D-Peer-tasks" class="headerlink" title="D. Peer tasks"></a>D. Peer tasks</h3><p>在接收到区块时，Fabric 节点按顺序执行以下任务：</p><ul><li>验证接收到的消息的合法性</li><li>验证区块中每个交易的区块头和每个背书签名</li><li>验证交易的读写集</li><li>在 LevelDB 或 CouchDB 中更新世界状态</li><li>将区块链日志存储在文件系统中，并在 LevelDB 中提供相应的索引</li></ul><p>我们的目标是在交易流的关键路径上最大限度地提高吞吐量。为此，我们进行了调用图分析，以确定性能瓶颈。<strong>首先</strong>，交易读写集的验证需要快速访问世界状态。因此，我们可以通过使用内存中的哈希表而不是数据库来加快这一过程。<strong>其次</strong>，交易流不需要区块链日志，因此我们可以推迟到交易流结束时将其存储到专用存储和数据分析服务器。<strong>第三</strong>，如果节点是背书节点，则需要处理新的交易提案。然而，提交者和背书者的角色是不同的，因此可以为每个任务分配不同的物理硬件。<strong>第四</strong>，传入的块和交易必须在节点进行验证和解析。最重要的是，通过交易写集对状态更改的验证必须按顺序进行，这会阻止所有其他任务。因此，尽可能加快这项操作是很重要的。<strong>最后</strong>，通过缓存块的 Protocol Buffers 解码的结果，可以获得显著的性能增益。</p><p><img src="/Fast-Fabric/2.png" alt="New peer architecture"></p><h3 id="E-Peer-improvement-I-Replacing-the-world-state-database-with-a-hash-table"><a href="#E-Peer-improvement-I-Replacing-the-world-state-database-with-a-hash-table" class="headerlink" title="E. Peer improvement I: Replacing the world state database with a hash table"></a>E. Peer improvement I: Replacing the world state database with a hash table</h3><p>我们认为，对于常见的情况，例如跟踪钱包或账本上的资产，世界状态相对较小。即使需要存储数十亿个键值，大多数服务器也可以很容易地将它们保存在内存中。因此，我们建议使用内存中的哈希表来存储世界状态，而不是 LevelDB&#x2F;CouchDB。这消除了在更新世界状态时对硬盘的访问。它还消除了昂贵的数据库系统保证（即ACID属性），因为区块链本身的冗余保证是不必要的，进一步提高了性能。由于使用易失性内存，这种替换容易受到节点故障的影响，因此必须通过稳定存储来增强内存哈希表。</p><h3 id="F-Peer-improvement-II-Store-blocks-using-a-peer-cluster"><a href="#F-Peer-improvement-II-Store-blocks-using-a-peer-cluster" class="headerlink" title="F. Peer improvement II: Store blocks using a peer cluster"></a>F. Peer improvement II: Store blocks using a peer cluster</h3><p>根据定义，区块是不可变的。这使它们非常适合追加式数据存储。通过将数据存储与节点的其余任务分离，我们可以设想许多类型的数据存储用于区块和世界状态备份，包括单个服务器将区块和世界状态备份存储在其文件系统中，就像 Fabric 目前所做的那样；也可以使用数据库或键值存储，例如 LevelDB 或 CouchDB。为了最大限度地扩展，我们建议使用分布式存储集群。请注意，使用此解决方案，每个存储服务器仅包含链的一部分，这促使使用分布式数据处理工具，如 Hadoop MapReduce 或 Spark5。</p><h3 id="G-Peer-improvement-III-Separate-commitment-and-endorsement"><a href="#G-Peer-improvement-III-Separate-commitment-and-endorsement" class="headerlink" title="G. Peer improvement III: Separate commitment and endorsement"></a>G. Peer improvement III: Separate commitment and endorsement</h3><p>在 Fabric 1.2 中，背书节点也负责提交区块。背书是一个昂贵的操作，提交也是如此。虽然在背书节点集群上的并发事务处理会提高性能，但在每个新节点上重复提交的额外工作实际上抵消了这些好处。因此，我们建议拆分这些角色。</p><p>在我们的设计中，提交节点执行验证流程，然后将已验证的区块发送到一个背书节点集群，这些节点仅将更改应用于其世界状态而不进行验证。这一步骤允许我们释放节点上的资源。这样的背书节点集群可以通过只将节点的背书角色分离到专用硬件上以满足需求。该集群中的服务器并不相当于 Fabric 1.2 中完整的背书节点。</p><h3 id="H-Peer-improvement-IV-Parallelize-validation"><a href="#H-Peer-improvement-IV-Parallelize-validation" class="headerlink" title="H. Peer improvement IV: Parallelize validation"></a>H. Peer improvement IV: Parallelize validation</h3><p>区块和交易头验证都包括检查发送方的权限、背书策略和语法验证，具有高度可并行性。我们通过引入完整的验证流水线来扩展 Fabric 1.2 的并发性能。</p><p>具体而言，对于每个传入的区块，分配一个 go-routine 来引导其通过区块验证阶段。随后，这些 go-routines 中的每一个都利用 Fabric 1.2 中已经存在的用于交易验证的 go-routine 池。因此，在任何给定时间，多个区块及其交易都可以并行地进行有效性检查。最后，所有<strong>读写集合按正确顺序由单个 go-routine 顺序验证</strong>。这使我们能够充分利用多核服务器 CPU 的潜力。</p><h3 id="I-Peer-improvement-V-Cache-unmarshaled-blocks"><a href="#I-Peer-improvement-V-Cache-unmarshaled-blocks" class="headerlink" title="I. Peer improvement V: Cache unmarshaled blocks"></a>I. Peer improvement V: Cache unmarshaled blocks</h3><p>Fabric 在网络节点之间使用 gRPC 进行通信。为了准备数据进行传输，使用 Protocol Buffers 进行序列化。为了能够处理应用程序和软件随着时间的推移进行的升级，Fabric 的区块结构高度分层，每个层都分别进行编组和解组。这导致大量内存被分配用于将字节数组转换为数据结构。此外，Fabric 1.2 不会在缓存中存储先前未解组的数据，因此每当需要数据时就必须重新进行此操作。</p><p>为了缓解这个问题，我们提出了一个临时的未解组数据缓存。在验证流水线中，块被存储在缓存中，并在需要时按块编号检索。一旦块的任何部分变得未解组，它就与块一起存储以供重用。我们将其实现为一个循环缓冲区，大小与验证流水线相同。每当提交一个块时，就可以接受一个新块到管道中，并自动覆盖已提交块的现有缓存位置。由于在提交后不需要缓存，并且保证新块仅在旧块离开管道后才到达，因此这是一个安全的操作。请注意，解组仅向缓存添加数据，它从不更改数据。因此，在验证流水线中可以为所有 go-routines 提供无锁访问。在最坏的情况下，多个 go-routines 尝试访问相同的（但尚未解组的）数据，并且所有 go-routines 并行执行解组。然后，缓存的最后写入获胜，这不是问题，因为结果在任何情况下都是相同的。</p><h2 id="IV-RESULTS"><a href="#IV-RESULTS" class="headerlink" title="IV. RESULTS"></a>IV. RESULTS</h2><p>实验配置略。</p><h3 id="A-Block-transfer-via-gRPC"><a href="#A-Block-transfer-via-gRPC" class="headerlink" title="A. Block transfer via gRPC"></a>A. Block transfer via gRPC</h3><p>我们预先创建了包含不同数量交易的有效块，通过 Fabric gRPC 接口将它们从一个 orderer 发送到 peer，然后立即丢弃它们。</p><p><img src="/Fast-Fabric/3.png" alt="Throughput via gRPC for different block sizes"></p><h3 id="B-Orderer-throughput-as-a-function-of-message-size"><a href="#B-Orderer-throughput-as-a-function-of-message-size" class="headerlink" title="B. Orderer throughput as a function of message size"></a>B. Orderer throughput as a function of message size</h3><p>在这个实验中，我们设置了多个客户端，这些客户端向排序节点发送交易，并监控发送 100000 个交易所需的时间。我们评估在 Fabric 1.2 中排序交易的速率，并将其与我们的改进进行比较：</p><ul><li><strong>Opt O-I</strong>: only Transaction ID is published to Kafka (Section III-B)</li><li><strong>Opt O-II</strong>: parallelized incoming transaction proposals from clients (Section III-C)</li></ul><p><img src="/Fast-Fabric/4.png" alt="Effect of payload size on orderer throughput"></p><h3 id="C-Peer-experiments"><a href="#C-Peer-experiments" class="headerlink" title="C. Peer experiments"></a>C. Peer experiments</h3><p>本节在单独节点上进行测试。我们准备好块，并将它们发送给节点，就像我们在第 IV-A 节的 gRPC 实验中所做的那样。然后，节点完全验证并提交块。</p><ul><li><strong>Opt P-I</strong>: LevelDB replaced by an in-memory hash table</li><li><strong>Opt P-II</strong>: Validation and commitment completely parallelized; block storage and endorsement offloaded to a separate storage server via remote gRPC call</li><li><strong>Opt P-III</strong>: All unmarshaled data cached and accessible to the entire validation&#x2F;commitment pipeline</li></ul><ol><li><em>Experiments with fixed block sizes</em>：单次运行 100000 个交易的验证和提交，重复 1000 次，每个区块包含 100 笔交易。</li></ol><p><img src="/Fast-Fabric/5.png" alt="Impact of our optimizations on peer block latency"></p><p><img src="/Fast-Fabric/6.png" alt="Impact of our optimizations on peer throughput"></p><ol start="2"><li><em>Parameter sensitivity</em>：测试改变两个参数对并行化性能的影响。</li></ol><ul><li>在验证流程中并行引导块的 go-routines 的数量</li><li>并行验证交易的 go-routines 的数量</li></ul><p>我们使用 semaphores 控制系统中 go-routines 的数量，同时允许多个块同时进入验证管道。这使我们能够通过两个独立的 go-routine pools 来控制块头验证和交易验证的并行度。</p><p><img src="/Fast-Fabric/7.png" alt=" Parameter sensitivity study for blocks containing 100 transactions and a server with 24 CPU cores. We scale the number of blocks that are validated in parallel and the number of transactions per block that are validated in parallel independently"></p><p>配置 24 ± 2 交易验证 go-routines，验证通道中有 30 ± 3 个区块，测试区块大小的影响。</p><p><img src="/Fast-Fabric/8.png" alt="Throughput dependence on block size for optimally tuned configuration"></p><h3 id="D-End-to-end-throughput"><a href="#D-End-to-end-throughput" class="headerlink" title="D. End-to-end throughput"></a>D. End-to-end throughput</h3><p>我们现在讨论通过组合所有优化实现的端到端吞吐量。O-II 与 P-III，与 Fabric 1.2 的测量结果对比。</p><p><img src="/Fast-Fabric/9.png" alt="Result"></p><h2 id="V-RELATED-WORK"><a href="#V-RELATED-WORK" class="headerlink" title="V. RELATED WORK"></a>V. RELATED WORK</h2><p>略</p><h2 id="VI-CONCLUSIONS"><a href="#VI-CONCLUSIONS" class="headerlink" title="VI. CONCLUSIONS"></a>VI. CONCLUSIONS</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Go」 回溯算法</title>
    <link href="/Go-backtrack/"/>
    <url>/Go-backtrack/</url>
    
    <content type="html"><![CDATA[<p>本文以 <a href="https://leetcode.cn/problems/combinations/">leetcode 77 题</a>为例，介绍回溯算法，参考 <a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">Carl 的教程</a>。</p><span id="more"></span><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p><code>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 **任何顺序** 返回答案。</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最直接的解法是使用 k 个 for 循环，但是当 k 过大时这个方法显然不适用。所以回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像 for 循环嵌套 k 层让人绝望。</p><p>用树形结构来理解回溯：</p><p><img src="/Go-backtrack/1.png" alt="n = 4, k = 2"></p><p>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。</p><p>图中可以发现n相当于树的宽度，k相当于树的深度。每次搜索到了叶子节点，我们就找到了一个结果。</p><h2 id="回溯法三部曲"><a href="#回溯法三部曲" class="headerlink" title="回溯法三部曲"></a>回溯法三部曲</h2><h3 id="1-递归函数的返回值以及参数"><a href="#1-递归函数的返回值以及参数" class="headerlink" title="1. 递归函数的返回值以及参数"></a>1. 递归函数的返回值以及参数</h3><p>在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>函数里一定有两个参数，既然是集合 n 里面取 k 个数，那么 n 和 k 是两个 int 型的参数。</p><p>然后还需要一个参数，为 int 型变量 start，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n]）。start 用于防止出现重复的组合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> backTrace <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k, start <span class="hljs-type">int</span>)</span></span> <br></code></pre></td></tr></table></figure><h3 id="2-回溯函数终止条件"><a href="#2-回溯函数终止条件" class="headerlink" title="2. 回溯函数终止条件"></a>2. 回溯函数终止条件</h3><p>path 这个数组的大小如果达到 k，说明我们找到了一个子集大小为 k 的组合了，在图中 path 存的就是根节点到叶子节点的路径。</p><p><img src="/Go-backtrack/2.png" alt="path"></p><p>此时用 res 二维数组，把 path 保存起来，并终止本层递归。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123; <br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-built_in">copy</span>(tmp, path)<br>    res = <span class="hljs-built_in">append</span>(res, tmp)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意不能直接 <code>append(res, path)</code>，后续修改 path 时会影响到 res。</strong></p><h3 id="3-单层搜索的过程"><a href="#3-单层搜索的过程" class="headerlink" title="3. 单层搜索的过程"></a>3. 单层搜索的过程</h3><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出 for 循环用来横向遍历，递归的过程是纵向遍历。</p><p><img src="/Go-backtrack/3.png" alt="遍历"></p><p>for 循环每次从 start 开始遍历，然后用 path 保存取到的节点 i。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> start &lt;= n &#123;                <span class="hljs-comment">// 控制树的横向遍历</span><br>    path = <span class="hljs-built_in">append</span>(path, start)  <span class="hljs-comment">// 处理节点</span><br>    backTrace(n, k, start + <span class="hljs-number">1</span>)  <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从 i+1 开始</span><br>    path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]   <span class="hljs-comment">// 回溯：撤销处理的节点</span><br>    start++<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">var</span> backTrace <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b, start <span class="hljs-type">int</span>)</span></span> <br>    backTrace = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b, start <span class="hljs-type">int</span>)</span></span> &#123;       <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == b &#123; <br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, b)<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-comment">// 从start开始，不往回走，避免出现重复组合</span><br>        <span class="hljs-keyword">for</span> start &lt;= a &#123;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> a - start + <span class="hljs-number">1</span> &lt; b - <span class="hljs-built_in">len</span>(path) &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            path = <span class="hljs-built_in">append</span>(path, start)<br>            backTrace(a, b, start + <span class="hljs-number">1</span>)<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>            start++<br>        &#125;<br>    &#125;<br><br>    backTrace(n, k, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform</title>
    <link href="/Optimizing-Fabric/"/>
    <url>/Optimizing-Fabric/</url>
    
    <content type="html"><![CDATA[<p>这篇文章发现了 Fabric v1.0 的三个主要性能瓶颈：(1) 背书策略验证；(2) 块中交易的顺序策略验证；(3) CouchDB 的状态验证和提交。同时对上述问题进行了简单的优化，如加密组件中用于背书策略验证的主动缓存、并行背书策略验证、增强并测量了 CouchDB 的现有批量读&#x2F;写优化的效果。</p><span id="more"></span><h2 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h2><p>与公链相比，许可链每个参与者的身份都是已知的，并且经过加密身份验证，这样区块链就可以存储谁进行了哪些交易。这样的网络可以内置访问控制机制，以限制谁可以 (a) 读取和附加账本数据，(b) 发布交易，(c) 管理区块链网络的参与者。所以非常适用于要求身份验证的企业级应用程序。</p><p>Fabric 提供了许多可配置的参数（block size，endorsement policy，channels，state database），因此，建立高效区块链网络的主要挑战之一就是为这些参数找到合适的值。</p><p><strong>本文的三个主要贡献：</strong></p><ol><li>我们进行了 1000 多次实验，通过改变五个主要参数的赋值，对 Fabric 平台进行了全面的测试，并且提供了六条关于配置这些参数以获得最大性能的指导方针。</li><li>我们确定了三个主要的性能瓶颈：(i) 加密操作，(ii) 区块中的交易串行验证，(iii) 对 CouchDB 的多个 REST API 调用。</li><li>进行三种简单优化，在单通道环境下将整体性能提高 16 倍。代码见 <a href="https://github.com/thakkarparth007/fabric">https://github.com/thakkarparth007/fabric</a>。</li></ol><h2 id="II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS"><a href="#II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS" class="headerlink" title="II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS"></a>II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS</h2><h3 id="A-Key-Components-in-Fabric"><a href="#A-Key-Components-in-Fabric" class="headerlink" title="A. Key Components in Fabric"></a>A. Key Components in Fabric</h3><ul><li><p><strong>Peer</strong>：对等节点执行实现用户智能合约的链码，并且在文件系统中维护账本。节点被进一本分为<strong>背书节点</strong>（endorsing peer，具有链码逻辑）和<strong>提交节点</strong>（committing peer，没有链码逻辑）。对等节点在键值存储中将当前状态维护为 StateDB，以便链码可以使用数据库查询语言查询或修改状态。</p><p>  <em><strong>Endorsement Policies</strong></em>：指定一组节点来模拟执行交易，并对执行结果签名背书。</p><p>  <em><strong>System chaincodes</strong></em>：系统链码与普通用户链码具有相同的程序设计模型，并内置于对等节点可执行文件中，这与用户链码不同。</p><ul><li><strong>LSCC</strong>（life cycle system chaincode）用于安装&#x2F;实例化&#x2F;更新链码；</li><li><strong>ESCC</strong>（endorsement system chaincode）通过对响应进行数字签名来背书交易；</li><li><strong>VSCC</strong>（validation system chaincode）根据背书策略验证交易的背书签名集；</li><li><strong>CSCC</strong>（configuration system chaincode）管理通道配置。</li></ul><p>  <em><strong>Channel</strong></em>：Fabric 引入通道的概念————两个或多个对等节点之间通信的“专用”子网，以提供一定程度的隔离。</p></li><li><p><strong>Ordering Service</strong>：排序节点（OSN）参与共识协议并出块，然后通过 gossip 协议传递给对等节点。区块结构如下图所示：</p></li></ul><p><img src="/Optimizing-Fabric/1.png" alt="Block Structure in Hyperledger Fabric v1.0"></p><p>OSNs 将交易发布到 kafka 并利用其记录的有序和不可变性来生成唯一的有序区块。</p><ul><li><strong>Client</strong>：客户端应用负责将交易提案组装成上图的形式，然后将交易提案同时提交给一个或多个对等节点，以收集带有背书的提案响应，满足背书政策后再将其广播给排序者。</li></ul><h3 id="B-Transaction-Flow-in-Hyperledger-Fabric"><a href="#B-Transaction-Flow-in-Hyperledger-Fabric" class="headerlink" title="B. Transaction Flow in Hyperledger Fabric"></a>B. Transaction Flow in Hyperledger Fabric</h3><p><img src="/Optimizing-Fabric/2.png" alt="Transaction Flow"></p><ol><li><p><strong>Endorsement Phase</strong><br> 客户端根据背书政策发送交易。背书节点收到客户端发来的交易，首先验证提交者有调用交易的权限；其次执行链码并产生 response value，read-set 和 write-set，读集读取当前的区块链状态，写集仅修改一个私有的工作区，即未提交到账本；然后背书节点调用 ESCC 签署背书并回复客户端；最后客户端验证提案响应。</p></li><li><p><strong>Ordering Phase</strong><br> 客户端将交易（read-write sets，endorsing peer signatures，Channel ID）包装好发给排序节点。排序服务并不检查交易内容，只按照通道分别排序并出块。给块签名后使用 gossip 传递给节点。</p></li><li><p><strong>Validation Phase</strong><br> 所有节点都会收到区块，首先检查排序者的签名，有效块被解码，并且块中的所有交易在执行 MVCC 验证之前首先经过 VSCC 验证。</p><ul><li>VSCC Validation：根据为链码指定的背书策略评估交易中的背书。如果不满足背书策略，则该交易被标记为无效。</li><li>MVCC Validation：Multi-Version Concurrency Control <strong>顺序</strong>检查有效交易（VSCC 标记）在背书阶段读取键值的版本与提交时本地账本中的当前状态是否相同，类似于为并发控制所做的读写冲突检查。</li></ul></li><li><p><strong>Ledger Update Phase</strong><br> StateDB 使用有效事务（MVCC 验证所标记）的写集进行更新</p></li></ol><h3 id="C-Configuration-Parameters"><a href="#C-Configuration-Parameters" class="headerlink" title="C. Configuration Parameters"></a>C. Configuration Parameters</h3><ol><li>Block Size</li><li>Endorsement Policy</li><li>Channel</li><li>Resource Allocation</li><li>Ledger Database</li></ol><h2 id="III-PROBLEM-STATEMENT"><a href="#III-PROBLEM-STATEMENT" class="headerlink" title="III. PROBLEM STATEMENT"></a>III. PROBLEM STATEMENT</h2><p>本文工作的两个主要目标：</p><ol><li>Performance Benchmarking.</li><li>Optimization.</li></ol><h2 id="IV-EXPERIMENTAL-METHODOLOGY"><a href="#IV-EXPERIMENTAL-METHODOLOGY" class="headerlink" title="IV. EXPERIMENTAL METHODOLOGY"></a>IV. EXPERIMENTAL METHODOLOGY</h2><p>两个性能指标：<strong>Throughput</strong>（交易提交到账本的速率）和 <strong>Latency</strong>（从客户端发送提案到交易上链的时间）。</p><p>延时主要由以下部分组成：</p><ul><li>Endorsement latency：客户端收集提案响应以及背书所花的时间。</li><li>Broadcast latency：客户端传播交易到排序节点和排序节点验证客户端的时间。</li><li>Commit latency：节点验证和提交交易的时间。</li><li>Ordering latency：交易排序所用的时间（本文未讨论）。</li></ul><p>本文又定义了三个区块级别的延时：</p><ul><li>VSCC validation latency：验证一个区块所有交易背书的签名集的时间。</li><li>MVCC validation latency：采用多版本并发控制验证一个区块所有交易的时间。</li><li>Ledger update latency：根据一个区块有效交易的写集改变数据库状态的时间。</li></ul><p>使用 <a href="https://github.com/thakkarparth007/fabric-load-gen">load generator</a> 生成交易，<a href="https://github.com/cendhu/fetch-block">fetch-block</a> 测试。</p><h3 id="A-Setup-and-Workloads"><a href="#A-Setup-and-Workloads" class="headerlink" title="A. Setup and Workloads"></a>A. Setup and Workloads</h3><p><img src="/Optimizing-Fabric/3.png" alt="Experimental Setup"></p><p>4 个组织，每个组织 2 个背书节点，1 个排序节点（硬件配置略）。</p><h2 id="V-EXPERIMENTAL-RESULTS"><a href="#V-EXPERIMENTAL-RESULTS" class="headerlink" title="V. EXPERIMENTAL RESULTS"></a>V. EXPERIMENTAL RESULTS</h2><p><img src="/Optimizing-Fabric/4.png" alt="默认配置"></p><h3 id="A-Impact-of-Transaction-Arrival-Rate-and-Block-Size"><a href="#A-Impact-of-Transaction-Arrival-Rate-and-Block-Size" class="headerlink" title="A. Impact of Transaction Arrival Rate and Block Size"></a>A. Impact of Transaction Arrival Rate and Block Size</h3><p><img src="/Optimizing-Fabric/5.png" alt="Impact of the block size and transaction arrival rate on performance"></p><ul><li><p><strong>Observation 1</strong>：throughput 随交易到达率线性增长，直到 140 tps 左右饱和，在饱和点附近延时显著增长。这是因为验证阶段 VSCC 队列中等待的有序交易数量显著增长，影响了提交延迟。进一步提高交易到达率并不会影响背书延时和广播延时，仅影响提交延时，这是因为 VSCC 利用单个 vCPU，新的交易提案使用了对等节点上的其他 vCPU 进行模拟和背书。所以只有验证阶段会成为性能瓶颈。</p></li><li><p><strong>Observation 2</strong>：交易到达率低于饱和点时，区块越大延时越高。原因是随着块大小的增加，排序服务的块创建时间增加，因此平均而言，交易在排序节点等待更长的时间。</p></li><li><p><strong>Observation 3</strong>：交易到达率高于饱和点时，区块越大延时越低。这是因为验证和提交一个大小为 n 的块所花费的时间总是小于验证和提交 m 个大小为 n&#x2F;m 的块所花的时间。</p></li><li><p><strong>Observation 4</strong>：当区块大小低于某个阈值时，延迟随着到达速率的增加而减少；高于阈值时，延迟随着到达率的增加而增加。对于较小的区块和较高的到达速率，块的创建速度更快，减少交易在排序节点等待的时间。对于较大的区块，随着到达率的增加，块中的事务数量增加，验证和提交阶段所花费的时间也增加了。</p></li><li><p><strong>Observation 5</strong>：即使在 throughput 达到峰值时，资源利用率也非常低。原因是在块的 VSCC 验证阶段执行的 CPU 密集型任务一次只处理一个事务。由于这种串行执行，只使用了一个 vCPU。</p></li><li><p><strong>Guideline 1</strong>：当交易到达率预计低于饱和点时，为了实现应用程序更低的延迟，始终使用更小的块。在这种情况下，吞吐量将与到达速率相匹配。</p></li><li><p><strong>Guideline 2</strong>：当交易到达率预计较高时，为了实现更高的吞吐量和更低的延迟，使用更大的块。</p></li><li><p><strong>Action Item 1</strong>：CPU 资源利用不足，潜在的优化是在 VSCC 验证阶段一次处理多个事务。</p></li></ul><h3 id="B-Impact-of-Endorsement-Policy"><a href="#B-Impact-of-Endorsement-Policy" class="headerlink" title="B. Impact of Endorsement Policy"></a>B. Impact of Endorsement Policy</h3><p><img src="/Optimizing-Fabric/6.png" alt="Impact of different endorsement policies"></p><p>研究不同的背书策略对性能影响，其中 a b c d 是四个不同的组织。</p><p><img src="/Optimizing-Fabric/7.png" alt="VSCC latency, and resource utilization for various endorsement policies (arrival rate = 125)"></p><ul><li><p><strong>Observation 6</strong>：多个子策略和多个加密签名验证的组合影响了性能（CPU 利用率和 VSCC 延迟）。1 和 4 背书策略没有子策略，2 和 3 AND&#x2F;OR 策略实现的吞吐量分别比其他策略低 7% 和 20%。</p></li><li><p><strong>Guideline 3</strong>：使用较少数量的子策略和签名来制定策略实现更高性能。</p></li><li><p><strong>Action Item 2</strong>：由于加密操作是 CPU 密集型的，我们可以通过维护反序列化身份及其 MSP 信息的缓存来避免某些重复操作。身份是长期存在的，并且维护单独的证书吊销列表（CRL）。</p></li></ul><h3 id="C-Impact-of-Channels-and-Resource-Allocation"><a href="#C-Impact-of-Channels-and-Resource-Allocation" class="headerlink" title="C. Impact of Channels and Resource Allocation"></a>C. Impact of Channels and Resource Allocation</h3><p>我们将不同信道数量的到达率分为两类：<strong>non-overloaded</strong>（延迟在 [0.4-1s]）和 <strong>overloaded</strong>（延迟范围 [30-40s]）。</p><p>Number of Channels: 1, 2, 4, 8, 16.<br>Tx. Arrival Rate: 125 to 250 tps with a step of 25.</p><p><img src="/Optimizing-Fabric/8.png" alt="Impact of the number of channels on performance"></p><ul><li><strong>Observation 7</strong>：随着通道数量的增加，吞吐量增加，延迟减少，CPU等资源利用率也有所提高。这是因为每个通道都独立于其他通道，并维护自己的区块链。因此，多个块（每个通道一个）的验证阶段和最终账本更新并行执行，这增加了 CPU 利用率，从而提高了吞吐量。</li></ul><p><img src="/Optimizing-Fabric/9.png" alt="Impact of the number of vCPU on throughput &amp; various latencies with 4 channels (arrival rate = 350 tps) and 16 channels (arrival rate = 850 tps)"></p><ul><li><strong>Observation 8</strong>：在中等负载下，当分配的 vCPU 数量小于通道数时，性能下降。由于 CPU 资源的大量竞争，平均背书和提交延迟都呈爆炸式增长（分别从 37ms 到 21s 和 640ms 到 49s）。</li></ul><p><img src="/Optimizing-Fabric/10.png" alt="Impact of heterogeneous setup"></p><ul><li><p><strong>Observation 9</strong>：在中等负载下，即使分配给 8 个对等点中的 2 个对等点的 vCPU 数量小于通道数，性能也会下降。原因有两个，一是来自功能较弱的对等节点的背书请求超时，二是专门针对读写事务的 MVCC 冲突。</p></li><li><p><strong>Guideline 4</strong>：为了实现更高的吞吐量和更低的延迟，最好为每个通道分配至少一个 vCPU。为了优化 vCPU 分配，我们需要确定每个通道的预期负载，并相应地分配足够的 vCPU。</p></li><li><p><strong>Guideline 5</strong>：为了实现更高的吞吐量和更低的延迟，最好避免异构对等节点，因为系统性能将由功能较弱的对等节点决定。</p></li><li><p><strong>Action Item 3</strong>：可以改进通道内和通道间的交易处理，以更好地利用额外的 CPU 能力。</p></li></ul><h3 id="D-Impact-of-Ledger-Database"><a href="#D-Impact-of-Ledger-Database" class="headerlink" title="D. Impact of Ledger Database"></a>D. Impact of Ledger Database</h3><p><img src="/Optimizing-Fabric/11.png" alt="Impact of state database"></p><ul><li><strong>Observation 10</strong>：以 GoLevelDB 作为 Fabric 的状态数据库，事务吞吐量是 CouchDB 的 3 倍。CouchDB 和 GoLevelDB 之间存在显著性能差异的原因是，后者是一个对等节点进程的嵌入式数据库，而前者是通过安全的 HTTP 使用 REST APIs 访问的。因此 CouchDB 的背书延迟、VSCC 延迟、MVCC 延迟和账本更新延迟更高。</li></ul><p><img src="/Optimizing-Fabric/12.png" alt="Impact of database (arrival rate = 30 tps)"></p><ul><li><p><strong>Observation 11</strong>：对于 CouchDB，背书延迟和账本更新延迟随着每笔交易写入次数的增加而增加。</p></li><li><p><strong>Observation 12</strong>：只有随着每个交易的读操作次数的增加，MVCC 延迟才会增加。</p></li><li><p><strong>Guideline 6</strong>：对于状态数据库来说，GoLevelDB 是一个性能更好的选项。如果对只读事务的富查询支持很重要，那么 CouchDB 是一个更好的选择。</p></li><li><p><strong>Action Item 4</strong>：CouchDB 支持批量读写操作，而不需要额外的事务语义。可以使用批量操作缩短锁的持续时间并提高性能。</p></li><li><p><strong>Action Item 5</strong>：在没有快照隔离级别的情况下，使用 GoLevelDB 和 CouchDB 等数据库会导致背书和账本更新阶段的整个数据库锁定。因此，我们未来的工作是研究如何移除锁或使用支持快照隔离的数据库，如 PostgreSQL。</p></li></ul><h3 id="E-Scalability-and-Fault-Tolerant"><a href="#E-Scalability-and-Fault-Tolerant" class="headerlink" title="E. Scalability and Fault Tolerant"></a>E. Scalability and Fault Tolerant</h3><p>在 Fabric 中，可扩展性可以根据通道数量、加入通道的组织数量以及每个组织的对等节点数量来衡量。从资源消耗的角度来看，背书策略的复杂性控制着网络的可扩展性。即使有大量的组织或节点，如果背书策略只需要少数组织签名，那么性能也不会受到影响。</p><p>节点故障在分布式系统中很常见，因此研究 Fabric 的容错能力很重要。在我们早期的研究中，我们观察到节点故障不会影响性能（在非过载情况下），因为客户端可以从其他可用节点收集背书。在负载较高的情况下，节点在故障后重新加入，并由于丢失块而同步账本，这有很大的延迟。这是因为尽管重新加入的节点处的块处理速率处于峰值，但是其他节点继续以相同的峰值处理速率添加新块。</p><h2 id="VI-OPTIMIZATIONS-STUDIED"><a href="#VI-OPTIMIZATIONS-STUDIED" class="headerlink" title="VI. OPTIMIZATIONS STUDIED"></a>VI. OPTIMIZATIONS STUDIED</h2><p>三个简单优化方案和它们结合起来的效果。</p><h3 id="A-MSP-Cache"><a href="#A-MSP-Cache" class="headerlink" title="A. MSP Cache"></a>A. MSP Cache</h3><p>由于加密操作非常占用 CPU，在本节中，我们研究了在加密模块中的以下两个操作中使用缓存的效率：</p><ol><li>身份的反序列化</li><li>组织 MSP 的身份验证</li></ol><p>为了避免每次都对序列化的身份标识进行反序列化，我们使用以序列化形式为键的哈希映射来缓存反序列化的身份。类似地，为了避免每次使用多个 MSP 验证一个身份，我们使用了一个哈希表，其中身份作为键，值是该身份所属的相应 MSP。</p><p><img src="/Optimizing-Fabric/13.png" alt="Impact of MSP cache"></p><p>与普通对等节点相比，由于 MSP 缓存，吞吐量平均增加了 3 倍。</p><h3 id="B-Parallel-VSCC-Validation-of-a-Block"><a href="#B-Parallel-VSCC-Validation-of-a-Block" class="headerlink" title="B. Parallel VSCC Validation of a Block"></a>B. Parallel VSCC Validation of a Block</h3><p>并行验证多个交易的背书，以利用闲置的 CPU 并提高整体性能。为了实现这一点，我们在对等节点启动时为每个通道创建了可配置数量的工作线程。每个工作线程根据其背书策略验证一个交易的背书签名集。</p><p><img src="/Optimizing-Fabric/14.png" alt="Impact of parallel VSCC validation on multichannel setup"></p><p>对于每个通道，我们分配了与块大小相等的工作线程。在一个通道的非过载情况下，对于 30 的块大小，吞吐量从 130 tps 提升到 800 tps（提高了6.3倍），对于 300 的块大小提升到 980 tps（7.5倍）。块内交易的并行 VSCC 验证显著提高了单个通道的性能。但是随着通道数量的增加，改善的百分比下降。这是因为默认情况下，多个通道会导致块（而不是交易）的并行验证，因此只有少量可用的 vCPU 可用于并行 VSCC。</p><h3 id="C-Bulk-Read-x2F-Write-During-MVCC-Validation-amp-Commit"><a href="#C-Bulk-Read-x2F-Write-During-MVCC-Validation-amp-Commit" class="headerlink" title="C. Bulk Read&#x2F;Write During MVCC Validation &amp; Commit"></a>C. Bulk Read&#x2F;Write During MVCC Validation &amp; Commit</h3><p>为了减少 REST API 调用的数量，CouchDB 建议使用批量操作。因此，我们使用 Fabric 中现有的 BatchRetrieval API，通过每个块的单个 GET REST API 调用，将多个键的版本和修订号批量加载到缓存中。为了增强账本更新过程，我们使用 BatchUpdate API 来提交一批文档，每个块使用一个 PUT REST API 调用。此外，我们在 VSCC 中引入了一个缓存，以减少对 CouchDB 的调用，从而获得每个交易的背书策略。</p><p><img src="/Optimizing-Fabric/15.png" alt="Impact of bulk read during the MVCC validation and ledger update on the performance"></p><p>要与上文非批量读写进行比较，对于单次写入的事务，性能从 50 tps 显著提高到 115 tps（2.3 倍）。对于多次写入（3-w 和 5-w），吞吐量从 26 tps 增加到 100 tps（3-w 为 3.8倍），从 18 tps 提高到 90 tps（5-w 为 5 倍）。我们注意到读写事务也有类似的改进。</p><h3 id="D-Combinations-of-Optimizations"><a href="#D-Combinations-of-Optimizations" class="headerlink" title="D. Combinations of Optimizations"></a>D. Combinations of Optimizations</h3><p><img src="/Optimizing-Fabric/16.png" alt="Configuration"></p><p><img src="/Optimizing-Fabric/17.png" alt="Impact of all the three optimizations on the performance with different block sizes"></p><p><img src="/Optimizing-Fabric/18.png" alt="Impact of all the three optimizations on the performance with a simple endorsement policy and different number of channels"></p><h2 id="VII-RELATED-WORK"><a href="#VII-RELATED-WORK" class="headerlink" title="VII. RELATED WORK"></a>VII. RELATED WORK</h2><p>略</p><h2 id="VIII-CONCLUSION-amp-FUTURE-WORK"><a href="#VIII-CONCLUSION-amp-FUTURE-WORK" class="headerlink" title="VIII. CONCLUSION &amp; FUTURE WORK"></a>VIII. CONCLUSION &amp; FUTURE WORK</h2><p>略</p><h2 id="IX-ACKNOWLEDGEMENTS"><a href="#IX-ACKNOWLEDGEMENTS" class="headerlink" title="IX. ACKNOWLEDGEMENTS"></a>IX. ACKNOWLEDGEMENTS</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(5)：规则引擎</title>
    <link href="/ByteDance-5/"/>
    <url>/ByteDance-5/</url>
    
    <content type="html"><![CDATA[<p>本文介绍规则引擎。</p><p>项目代码：<a href="https://github.com/qimengxingyuan/young_engine.git">https://github.com/qimengxingyuan/young_engine.git</a></p><span id="more"></span><h2 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>规则引擎是一种嵌入在应用服务中的组件，可以将灵活多变的业务决策从服务代码中分离出来。</p><p>通过使用预定义的语义模块来编写业务逻辑规则。在执行时接受数据输入、解释业务规则，并做出决策。规则引擎能大大提高系统的灵活性和扩展性。</p><p><img src="/ByteDance-5/1.png" alt="old"></p><p>解决开发人员重复编码问题，业务决策与服务本身解耦，提高服务的可维护性。</p><p><img src="/ByteDance-5/2.png" alt="new"></p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>数据输入</li><li>规则理解</li><li>规则执行</li></ul><h2 id="编译原理基本概念"><a href="#编译原理基本概念" class="headerlink" title="编译原理基本概念"></a>编译原理基本概念</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译的过程就是 把某种语言的源程序，<strong>在不改变语义的条件下</strong>，转换成另一种语言程序(目标语言程序)。</p><p><img src="/ByteDance-5/3.jpg" alt="编译"></p><ul><li>如果源代码编译后要在操作系统上运行，那目标代码就是汇编&#x2F;机器代码。</li><li>如果编译后是在虚拟机里执行，那目标代码就可以不是汇编代码，而是一种解释器可以理解的中间形式的代码即可。</li></ul><p>有的语言提前把代码一次性转换完毕，这种就是编译型语言，用的转换工具就叫编译器，比如 C、C++、Go。一次编译可重复执行。</p><p>有的语言则可以一边执行一边转化，用到哪里了就转哪里，这种就是解释性语言，用的转化工具叫虚拟机或者解释器，比如 java、python、javascript。</p><ul><li>Java 既有编译又有解释。但是编译并没有直接编译成机器码，而是编译成字节码，然后再放到虚拟机中执行。</li><li>Python 执行过程也是经过两个阶段，先编译成字节码 .pyc 再放到虚拟机中去执行。</li></ul><h3 id="词法分析（Lexical-Analysis）"><a href="#词法分析（Lexical-Analysis）" class="headerlink" title="词法分析（Lexical Analysis）"></a>词法分析（Lexical Analysis）</h3><p>把源代码字符串转换为词法单元（Token）。</p><p><img src="/ByteDance-5/4.png" alt="Lexical Analysis"></p><h3 id="语法分析（Syntax-Analysis）"><a href="#语法分析（Syntax-Analysis）" class="headerlink" title="语法分析（Syntax Analysis）"></a>语法分析（Syntax Analysis）</h3><p>词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构。这棵树叫做<strong>抽象语法树</strong>（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点。</p><ul><li><p><strong>上下文无关语法</strong>（Context-Free Grammar）</p><p>  语言句子无需考虑上下文，就可以判断正确性。</p><p>  巴科斯范式（BNF）是描述上下文无关理论的一种具体方法，通过 BNF 可以实现上下文无关文法的具体化、公式化、科学化，是实现代码解析的必要条件。</p></li><li><p><strong>递归下降算法</strong>（Recursive Descent Parsing）</p><p>  递归下降算法就是自顶向下构造语法树。</p><p>  不断对 Token 进行语法展开，展开过程可能会遇到递归的情况。</p></li></ul><h2 id="设计规则引擎"><a href="#设计规则引擎" class="headerlink" title="设计规则引擎"></a>设计规则引擎</h2><p>详见<a href="https://github.com/qimengxingyuan/young_engine.git">项目代码</a>。</p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Go」 堆结构</title>
    <link href="/Go-heap/"/>
    <url>/Go-heap/</url>
    
    <content type="html"><![CDATA[<p>本文以 <a href="https://leetcode.cn/problems/top-k-frequent-elements/">leetcode 347 题</a>为例，介绍一下堆结构，参考 <a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html">Carl 的教程</a>。</p><span id="more"></span><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p><code>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。你所设计算法的时间复杂度必须优于 O(n*logn)，其中 n 是数组大小。</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><p>首先统计元素出现的频率，这一类的问题可以使用 map 来进行统计。</p><p>然后是对频率进行排序，这里我们可以使用<strong>优先级队列</strong>。</p><p><strong>堆</strong>就是优先级队列的一种实现。</p><h2 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h2><p>堆是一棵<strong>完全二叉树</strong>，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是<strong>大顶堆</strong>（根节点最大），小于等于左右孩子就是<strong>小顶堆</strong>（根节点最小）。</p><p><img src="/Go-heap/3.png" alt="heap"></p><p>堆本身就是一个数组，因此创建一个数组来创建堆。</p><p><img src="/Go-heap/4.png" alt="存储"></p><p>假设当前元素的索引位置为 i，可以得到规律：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs heap">parent(i) = i/2（取整）<br>left child(i) = 2*i<br>right child(i) = 2*i + 1<br></code></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p><img src="/Go-heap/1.png" alt="插入"></p><p>在完全二叉树中，插入的节点与它的父节点相比，如果比父节点小，就交换它们的位置，再往上和父节点相比，如果比父节点小，再交换位置，直到比父节点大为止。</p><p>在数组中，插入的节点与 n&#x2F;2 位置的节点相比，如果比 n&#x2F;2 位置的节点小，就交换它们的位置，再往前与 n&#x2F;4 位置的节点相比，如果比 n&#x2F;4 位置的节点小，再交换位置，直到比 n&#x2F;(2^x) 位置的节点大为止。</p><p>这就是插入元素时进行的堆化，也叫<strong>自下而上的堆化</strong>。</p><p>插入元素的时间复杂度为 O(log n)。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="/Go-heap/2.png" alt="删除"></p><p>在完全二叉树中，移除根节点首先把最后一个节点放到堆顶，然后与左右子节点中<strong>小</strong>的交换位置（因为是小顶堆），依次往下，直到其比左右子节点都小为止。</p><p>在数组中，把最后一个元素移到下标为 1 的位置，然后与下标为 2 和 3 的位置对比，发现 8 比 2 大，且 2 是 2 和 3 中间最小的，所以与 2 交换位置；然后再下标为 4 和 5 的位置对比，发现 8 比 5 大，且 5 是 5 和 7 中最小的，所以与 5 交换位置，没有左右子节点了，堆化结束。即 <code>parent = child; child = parent*2;</code>。</p><p>这就是删除元素时进行的堆化，也叫<strong>自上而下的堆化</strong>。</p><p>删除元素的时间复杂度为 O(log n)。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此题使用小顶堆，因为要统计最大前 k 个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前 k 个最大元素。</p><p><img src="/Go-heap/5.png" alt="过程"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用 go 标准库给我们提供的 heap，需要实现这些接口定义的方法：</p><ul><li>Len() int</li><li>Less(i, j int) bool</li><li>Swap(i, j int)</li><li>Push(x interface{})</li><li>Pop() interface{}</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法一：小顶堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    map_num := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> nums&#123;<br>        map_num[item]++<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 heap</span><br>    h := &amp;IHeap&#123;&#125;<br>    heap.Init(h)<br>    <span class="hljs-comment">// 所有元素入堆，堆的长度为 k</span><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map_num &#123;<br>        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key, value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            <span class="hljs-comment">// heap.Pop 并非下方定义的 h.Pop</span><br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-comment">// 按顺序返回堆中的元素</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        res[k-i<span class="hljs-number">-1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// 构建小顶堆</span><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len()<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 如果 h[i][1] &lt; h[j][1] 生成的就是小根堆，h[i][1] &gt; h[j][1] 生成的就是大根堆</span><br>    <span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>] &lt; h[j][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    h[i], h[j] = h[j], h[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个解法是先使用 map 存储元素与出现次数，然后将元素放入切片，再按照频率对切片排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法二：利用 O(nlogn) 排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    map_num := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> nums &#123;<br>        map_num[item]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> map_num &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 切片排序</span><br>    sort.Slice(ans, <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-comment">// 第一个参数是：待排序数据</span><br>        <span class="hljs-comment">// 第二个参数是：排序判断方法</span><br>        <span class="hljs-comment">// 形参 a 代表后一个元素</span><br>        <span class="hljs-comment">// 形参 b 代表前一元素</span><br>        <span class="hljs-comment">// 返回值：代表 a, b 是否交换，true：交换，false：不交换</span><br>        <span class="hljs-keyword">return</span> map_num[ans[a]] &gt; map_num[ans[b]]<br>        <span class="hljs-comment">// 后一个大于前一个就交换，所以是降序</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> ans[:k]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(4)：框架三件套</title>
    <link href="/ByteDance-4/"/>
    <url>/ByteDance-4/</url>
    
    <content type="html"><![CDATA[<p>本文介绍 Gorm、Kitex、Hertz 三件套。</p><span id="more"></span><h2 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h2><p>Gorm 是面向 Golang 语言的一种 <strong>ORM（Object Relational Mapping，对象关系映射）框架</strong>，支持多种数据库的接入，例如 MySQL，PostgreSQL，SQLite，SQL Server，Clickhouse。此框架弱化了开发者对于 SQL 语言的掌握程度，使用提供的 API 进行底层数据库的访问。</p><p>快速开始：<a href="https://gorm.cn/zh_CN/docs/index.html">https://gorm.cn/zh_CN/docs/index.html</a><br>框架地址：<a href="https://github.com/go-gorm/gorm">https://github.com/go-gorm/gorm</a></p><ul><li><p><strong>基本使用</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br><span class="hljs-string">&quot;gorm.io/driver/sqlite&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Code  <span class="hljs-type">string</span><br>    Price <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 连接数据库</span><br>    db, err := gorm.Open(sqlite.Open(<span class="hljs-string">&quot;test.db&quot;</span>), &amp;gorm.Config&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>    &#125;   <br><br>    <span class="hljs-comment">// 迁移 schema</span><br>    db.AutoMigrate(&amp;Product&#123;&#125;)<br><br>    <span class="hljs-comment">// Create</span><br>    db.Create(&amp;Product&#123;Code: <span class="hljs-string">&quot;D42&quot;</span>, Price: <span class="hljs-number">100</span>&#125;)<br><br>    <span class="hljs-comment">// Read</span><br>    <span class="hljs-keyword">var</span> product Product<br>    db.First(&amp;product, <span class="hljs-number">1</span>) <span class="hljs-comment">// 根据整形主键查找</span><br>    db.First(&amp;product, <span class="hljs-string">&quot;code = ?&quot;</span>, <span class="hljs-string">&quot;D42&quot;</span>) <span class="hljs-comment">// 查找 code 字段值为 D42 的记录</span><br><br>    <span class="hljs-comment">// Update - 将 product 的 price 更新为 200</span><br>    db.Model(&amp;product).Update(<span class="hljs-string">&quot;Price&quot;</span>, <span class="hljs-number">200</span>)<br>    <span class="hljs-comment">// Update - 更新多个字段</span><br>    db.Model(&amp;product).Updates(Product&#123;Price: <span class="hljs-number">200</span>, Code: <span class="hljs-string">&quot;F42&quot;</span>&#125;) <span class="hljs-comment">// 仅更新非零值字段</span><br>    db.Model(&amp;product).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Price&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-string">&quot;F42&quot;</span>&#125;)<br><br>    <span class="hljs-comment">// Delete - 删除 product</span><br>    db.Delete(&amp;product, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>连接数据库</strong></p><p>  GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>    <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span><br>    dsn := <span class="hljs-string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Kitex"><a href="#Kitex" class="headerlink" title="Kitex"></a>Kitex</h2><p>Kitex[kaɪt’eks] 字节跳动内部的 Golang 微服务 <strong>RPC（Remote Procedure Call）框架</strong>，具有高性能、强可扩展的特点，在字节内部已广泛使用。</p><p>快速开始：<a href="https://www.cloudwego.io/zh/docs/kitex/getting-started">https://www.cloudwego.io/zh/docs/kitex/getting-started</a><br>框架地址：<a href="https://github.com/cloudwego/kitex">https://github.com/cloudwego/kitex</a></p><ul><li><p><strong>定义 IDL</strong></p><p>  如果我们要进行 RPC，就需要知道对方的接口是什么，需要传什么参数，同时也需要知道返回值是什么样的，就好比两个人之间交流，需要保证在说的是同一个语言、同一件事。 这时候，就需要通过 IDL（Interface Definition Language）来约定双方的协议，就像在写代码的时候需要调用某个函数，我们需要知道函数签名一样。</p>  <figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-keyword">namespace</span> go api<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Request</span> </span>&#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-type">string</span> message<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Response</span> </span>&#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-type">string</span> message<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    Response echo(<span class="hljs-number">1</span>: Request req)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编写 echo 服务逻辑</strong></p><p>  服务默认监听 8888 端口。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;example/kitex_gen/api&quot;</span><br>)<br><br><span class="hljs-comment">// EchoImpl implements the last service interface defined in the IDL.</span><br><span class="hljs-keyword">type</span> EchoImpl <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Echo implements the EchoImpl interface.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *EchoImpl)</span></span> Echo(ctx context.Context, req *api.Request) (resp *api.Response, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Your code here...</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>创建 client</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;example/kitex_gen/api/echo&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/cloudwego/kitex/client&quot;</span><br>...<br>c, err := echo.NewClient(<span class="hljs-string">&quot;example&quot;</span>, client.WithHostPorts(<span class="hljs-string">&quot;0.0.0.0:8888&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>  上述代码中，echo.NewClient 用于创建 client，其第一个参数为调用的服务名，第二个参数为 options，用于传入参数，此处的 client.WithHostPorts 用于指定服务端的地址。</p></li><li><p><strong>发起调用</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;example/kitex_gen/api&quot;</span><br>...<br>req := &amp;api.Request&#123;Message: <span class="hljs-string">&quot;my request&quot;</span>&#125;<br>resp, err := c.Echo(context.Background(), req, callopt.WithRPCTimeout(<span class="hljs-number">3</span>*time.Second))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br>log.Println(resp)<br></code></pre></td></tr></table></figure><p>  上述代码中，我们首先创建了一个请求 req , 然后通过 c.Echo 发起了调用。</p></li></ul><h2 id="Hertz"><a href="#Hertz" class="headerlink" title="Hertz"></a>Hertz</h2><p>Hertz[həːts] 是一个 Golang 微服务 <strong>HTTP 框架</strong>，在设计之初参考了其他开源框架 fasthttp、gin、echo 的优势，并结合字节跳动内部的需求，使其具有高易用性、高性能、高扩展性等特点。</p><p>快速开始：<a href="https://www.cloudwego.io/zh/docs/hertz/getting-started">https://www.cloudwego.io/zh/docs/hertz/getting-started</a><br>框架地址：<a href="https://github.com/cloudwego/hertz">https://github.com/cloudwego/hertz</a></p><ul><li><p><strong>基本使用</strong></p><p>  实现服务监听 8080 端口并注册一个 GET 方法的路由函数。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/app&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/app/server&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/common/utils&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/protocol/consts&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    h := server.Default(server.WithHostPorts(<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>))<br><br>    h.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c context.Context, ctx *app.RequestContext)</span></span> &#123;<br>        ctx.JSON(consts.StatusOK, utils.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>&#125;)<br>    &#125;)<br><br>    h.Spin()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Go」 KMP 算法</title>
    <link href="/Go-KMP/"/>
    <url>/Go-KMP/</url>
    
    <content type="html"><![CDATA[<p>以 <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">leetcode 28 题</a>为例，学习一下 KMP 算法。本文参考 <a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#_28-%E5%AE%9E%E7%8E%B0-strstr">Carl 的教程</a>。</p><span id="more"></span><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p><code>给你两个字符串 haystack 和 needle，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。</code></p><p>举个例子，就是要在<strong>文本串</strong>：aabaabaafa 中查找是否出现过一个<strong>模式串</strong>：aabaaf，并返回出现的地方。</p><p>暴力解法很容易想到，但是时间复杂度是 <strong>O(m*n)</strong> （m 和 n 分别是文本串和模式串长度）</p><p>而 KMP 算法的时间复杂度为 <strong>O(m+n)</strong> （匹配和单独生成 next 数组）</p><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP 是由三位学者发明的：Knuth，Morris 和 Pratt，取了三位学者名字的首字母，所以叫做 KMP。</p><p>KMP 主要应用在<strong>字符串匹配</strong>上。</p><p>KMP 的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了</strong>。</p><p><img src="/Go-KMP/1.gif" alt="KMP"></p><p>假设文本串有下标 i，模式串有下标 j。</p><p>可以看到整个 KMP 过程中 i 是不需要回溯的，出现不匹配时 j 会回溯到 next[j-1] 的位置，所以构建 next 是关键。</p><h2 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h2><p>next 数组就是一个前缀表（prefix table），记录下标 i 之前（包括 i）的字符串中，有多大长度的<strong>相同前缀后缀</strong>。</p><p>前缀表是用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配。</p><h3 id="如何计算前缀表"><a href="#如何计算前缀表" class="headerlink" title="如何计算前缀表"></a>如何计算前缀表</h3><p>如图：</p><p><img src="/Go-KMP/2.png"></p><p>长度为前 1 个字符的子串 a，最长相同前后缀的长度为 0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串）</p><p><img src="/Go-KMP/3.png"></p><p>长度为前 2 个字符的子串 aa，最长相同前后缀的长度为 1。</p><p><img src="/Go-KMP/4.png"></p><p>长度为前 3 个字符的子串 aab，最长相同前后缀的长度为 0。</p><p>以此类推：长度为前 4 个字符的子串 aaba，最长相同前后缀的长度为 1。长度为前 5 个字符的子串 aabaa，最长相同前后缀的长度为 2。长度为前 6 个字符的子串 aabaaf，最长相同前后缀的长度为0。</p><p><img src="/Go-KMP/5.png"></p><h3 id="前缀表与-next-数组"><a href="#前缀表与-next-数组" class="headerlink" title="前缀表与 next 数组"></a>前缀表与 next 数组</h3><p>next 数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为 -1）之后作为 next 数组。</p><p>其实这并不涉及到 KMP 的原理，而是具体实现，next 数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为 -1）。</p><h3 id="构造-next-数组"><a href="#构造-next-数组" class="headerlink" title="构造 next 数组"></a>构造 next 数组</h3><p>构造 next 数组主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这是我自己写的不右移也不减一的版本。</p><p>总结就是：i 一直往后走，遇到不匹配，j 去找前一位看看回溯到哪里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-type">string</span>, needle <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// KMP, i 是文本串指针, j 是模式串指针, i 不回溯 </span><br>    j := <span class="hljs-number">0</span><br>    next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(needle))<br>    getNext(next, needle)<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(haystack); i++ &#123;<br>        <span class="hljs-comment">// 匹配到不同字符</span><br>        <span class="hljs-keyword">for</span> haystack[i] != needle[j] &amp;&amp; j &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// j 回溯</span><br>            j = next[j<span class="hljs-number">-1</span>]<br>        &#125;<br><br>        <span class="hljs-comment">// 匹配到相同字符</span><br>        <span class="hljs-keyword">if</span> haystack[i] == needle[j] &#123;<br>            j++<br>            <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle) &#123;<br>                <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 构建 next (不减 1)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNext</span><span class="hljs-params">(next []<span class="hljs-type">int</span>, s <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 初始化, 定义两个指针 i 和 j, j 指向前缀末尾位置, i 指向后缀末尾位置</span><br>    j := <span class="hljs-number">0</span><br>    next[<span class="hljs-number">0</span>] = j<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 前后缀不同</span><br>        <span class="hljs-keyword">for</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j] &#123;<br>            j = next[j<span class="hljs-number">-1</span>]<br>        &#125;<br><br>        <span class="hljs-comment">// 前后缀相同</span><br>        <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>            j++<br>        &#125;<br>        next[i] = j<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只简单介绍了 KMP 算法的流程，但是关于为什么它可以解决字符串匹配的问题，没有详细讨论。感兴趣的话可以参考<a href="https://blog.csdn.net/weixin_52622200/article/details/110563434">这篇文章</a>。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(3)：内存管理</title>
    <link href="/ByteDance-3/"/>
    <url>/ByteDance-3/</url>
    
    <content type="html"><![CDATA[<p>本文是关于自动内存管理和 Go 内存管理及优化的笔记。</p><span id="more"></span><h2 id="1-自动内存管理"><a href="#1-自动内存管理" class="headerlink" title="1 自动内存管理"></a>1 自动内存管理</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p><strong>自动内存管理</strong>（垃圾回收，GC）：由程序语言的运行时系统管理动态内存。避免手动内存管理，专注于实现业务逻辑，并保证内存使用的正确性和安全性: double-free problem, use-after-free problem</p><p><strong>三个任务</strong>：</p><ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul><p><strong>Mutator</strong>: 业务线程，分配新对象，修改对象指向关系<br><strong>Collector</strong>: GC 线程，找到存活对象，回收死亡对象的内存空间<br><strong>Serial GC</strong>: 只有一个 collector<br><strong>Parallel GC</strong>: 并行 GC，支持多个 collectors 同时回收的 GC 算法<br><strong>Concurrent GC</strong>: 并发 GC，支持 mutator(s) 和 collector(s) 同时执行的 GC 算法</p><p><img src="/ByteDance-3/1.png" alt="GC"></p><h3 id="1-2-追踪垃圾回收"><a href="#1-2-追踪垃圾回收" class="headerlink" title="1.2 追踪垃圾回收"></a>1.2 追踪垃圾回收</h3><ul><li><p>被回收的条件：指针指向关系不可达对象</p></li><li><p>过程：</p><p>  <img src="/ByteDance-3/2.png" alt="扫描过程"></p><ol><li><p>标记根对象 (GC roots): 静态变量、全局变量、常量、线程栈等</p></li><li><p>标记：找到所有可达对象</p></li><li><p>清理：回收所有不可达对象占据的内存空间</p><ul><li><strong>Copying GC</strong>: 将存活对象从一块内存空间复制到<strong>另外一块内存空间</strong>，原先的空间可以直接进行对象分配<br> <img src="/ByteDance-3/3.png" alt="Copying GC"></li><li><strong>Mark-sweep GC</strong>: 将死亡对象所在内存块标记为可分配，使用 free list 管理可分配的空间<br> <img src="/ByteDance-3/4.png" alt="Mark-sweep GC"></li><li><strong>Mark-compact GC</strong>: 将存活对象复制到同一块内存区域的开头<br> <img src="/ByteDance-3/5.png" alt="Mark-compact GC"></li></ul></li></ol></li></ul><h3 id="1-3-分代-GC"><a href="#1-3-分代-GC" class="headerlink" title="1.3 分代 GC"></a>1.3 分代 GC</h3><p>分代假说：most objects die young，很多对象在分配出来后很快就不再使用了</p><ul><li><p>年轻代（Young generation）</p><ul><li>常规的对象分配</li><li>由于存活对象少，可以采用 copying collection</li><li>GC 吞吐率很高</li></ul></li><li><p>老年代（Old generation）</p><ul><li>对象趋于一直活着，反复复制开销大</li><li>可以采用 mark-sweep collection</li></ul></li></ul><h3 id="1-4-引用计数"><a href="#1-4-引用计数" class="headerlink" title="1.4 引用计数"></a>1.4 引用计数</h3><p>每个对象都有一个与之关联的引用数目</p><p>对象存活的条件：当且仅当引用数大于 0</p><ul><li><p>优点：</p><ul><li>内存管理的操作被平摊到程序运行中：指针传递的过程中进行引用计数的增减</li><li>不需要了解 runtime 的细节：因为不需要标记 GC roots，因此不需要知道哪里是全局变量、线程栈等</li></ul></li><li><p>缺点：</p><ul><li>开销大，因为对象可能会被多线程访问，对引用计数的修改需要<strong>原子操作</strong>保证原子性和可见性</li><li>无法回收环形数据结构</li><li>每个对象都引入额外存储空间存储引用计数</li><li>虽然引用计数的操作被平摊到程序运行过程中，但是回收大的数据结构依然可能引发暂停</li></ul></li></ul><h2 id="2-Go-内存管理及优化"><a href="#2-Go-内存管理及优化" class="headerlink" title="2 Go 内存管理及优化"></a>2 Go 内存管理及优化</h2><h3 id="2-1-分块"><a href="#2-1-分块" class="headerlink" title="2.1 分块"></a>2.1 分块</h3><p>为对象在 heap 上分配内存，提前将<strong>内存分块</strong></p><ul><li>调用系统调用 mmap() 向 OS 申请一大块内存，例如 4 MB</li><li>先将内存划分成大块，例如 8 KB，称作 mspan</li><li>再将大块继续划分成<strong>特定大小</strong>的小块，例如 8 B、16 B、24 B，用于对象分配</li><li>noscan mspan: 分配不包含指针的对象 —— GC 不需要扫描</li><li>scan mspan: 分配包含指针的对象 —— GC 需要扫描</li></ul><h3 id="2-2-缓存"><a href="#2-2-缓存" class="headerlink" title="2.2 缓存"></a>2.2 缓存</h3><p>Go 内存管理构成了多级缓存机制，从 OS 分配得的内存被内存管理回收后，也不会立刻归还给 OS，而是在 Go runtime 内部先缓存起来，从而避免频繁向 OS 申请内存。</p><p><img src="/ByteDance-3/6.png" alt="多级缓存"></p><ul><li>g：gorotine（协程）</li><li>m：machine（内核线程）</li><li>p：processor（调度器）</li><li>每个 p 包含一个 mcache 用于快速分配，用于为绑定于 p 上的 g 分配对象</li><li>mcache 管理一组 mspan</li><li>当 mchache 中的 mspan 分配完毕，向 mcentral 申请带有未分配块的 mspan</li><li>当 mspan 中没有分配的对象，mspan 会缓存在 mcentral 中，而不是立即释放并归还给 OS</li></ul><h3 id="2-3-优化方案"><a href="#2-3-优化方案" class="headerlink" title="2.3 优化方案"></a>2.3 优化方案</h3><p><strong>Go 内存管理的问题</strong>：对象分配是非常高频的操作，每秒分配 GB 级别的内存；Go 的内存分配流程很长，占用很多 CPU</p><p><strong>字节跳动的优化方案</strong>：Balanced GC</p><p>核心：将 noscan 对象在 per-g allocation buffer (GAB) 上分配，并使用移动对象 GC 管理这部分内存，提高对象分配和回收效率。</p><p><img src="/ByteDance-3/7.png" alt="GAB"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> top + size &lt;= end &#123;<br>    addr := top<br>    top += size<br>    <span class="hljs-keyword">return</span> addr<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 g 会绑定一个较大的 allocation buffer (例如 1 KB) 用来分配小于 128 B 的 noscan 小对象</li><li>分配对象时，根据对象大小移动 top 指针并返回，快速完成一次对象分配</li><li>同原先调用 mallocgc() 进行对象分配的方式相比，balanced GC 缩短了对象分配的路径，减少了对象分配执行的指令数目，降低 CPU 使用</li></ul><p>从 Go runtime 内存管理模块的角度看，一个 allocation buffer 其实是一个大对象。本质上 Balanced GC 是将多次小对象的分配合并成一次大对象的分配。因此，当 GAB 中哪怕只有一个小对象存活时，Go runtime 也会认为整个大对象（即 GAB）存活。为此，balanced GC 会根据 GC 策略，将 GAB 中存活的对象移动到另外的 GAB 中，从而压缩并清理 GAB 的内存空间，原先的 GAB 空间由于不再有存活对象，可以全部释放。</p><p><img src="/ByteDance-3/8.png" alt="用 copying GC 管理小对象"></p><p>Balanced GC 只负责 noscan 对象的分配和移动，对象的标记和回收依然依赖 Go GC 本身，并和 Go GC 保持兼容。</p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(2)：性能调优</title>
    <link href="/ByteDance-2/"/>
    <url>/ByteDance-2/</url>
    
    <content type="html"><![CDATA[<p>请参考：<a href="https://github.com/RaymondCode/go-practice">性能优化建议代码</a>，<a href="https://github.com/wolfogre/go-pprof-practice">pprof 示例代码</a></p><span id="more"></span><h2 id="1-性能优化建议"><a href="#1-性能优化建议" class="headerlink" title="1 性能优化建议"></a>1 性能优化建议</h2><h3 id="1-1-Slice"><a href="#1-1-Slice" class="headerlink" title="1.1 Slice"></a>1.1 Slice</h3><p><strong>预分配内存</strong>：使用 <code>make()</code> 初始化切片时提供容量信息。</p><ul><li>切片本质是一个数组片段的描述，包括：<ul><li>数组指针</li><li>片段的长度</li><li>片段的容量</li></ul></li><li>切片操作并不复制切片指向的元素</li><li>创建一个新的切片会复用原来切片的底层数组</li><li>切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景：<ul><li>当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间</li><li>当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组</li></ul></li></ul><p><img src="/ByteDance-2/2.png" alt="append"></p><p>因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NoPreAlloc</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> &#123;<br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++ &#123;<br>data = <span class="hljs-built_in">append</span>(data, k)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PreAlloc</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> &#123;<br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, size)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++ &#123;<br>data = <span class="hljs-built_in">append</span>(data, k)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-2/1.png" alt="result"></p><p><strong>另一个陷阱</strong>：大内存得不到释放。</p><p>在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。</p><p>推荐的做法：<strong>使用 copy 替代 re-slice</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// slice.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLastBySlice</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLastByCopy</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">copy</span>(result, origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:])<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">// slice_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testGetLast</span><span class="hljs-params">(t *testing.T, f <span class="hljs-keyword">func</span>([]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span>) &#123;<br>result := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++ &#123;<br>origin := generateWithCap(<span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-comment">// 1M</span><br>result = <span class="hljs-built_in">append</span>(result, f(origin))<br>&#125;<br>printMem(t)<br>_ = result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLastBySlice</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>testGetLast(t, GetLastBySlice)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLastByCopy</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>testGetLast(t, GetLastByCopy)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-2/3.png" alt="result"></p><h3 id="1-2-Map"><a href="#1-2-Map" class="headerlink" title="1.2 Map"></a>1.2 Map</h3><p><strong>预分配内存</strong></p><ul><li>不断向 map 中添加元素的操作会触发 map 的扩容</li><li>根据实际需求提前预估好需要的空间</li><li>提前分配好空间可以减少内存拷贝和 Rehash 的消耗</li></ul><h3 id="1-3-字符串处理"><a href="#1-3-字符串处理" class="headerlink" title="1.3 字符串处理"></a>1.3 字符串处理</h3><p>使用 strings.Builder 代替 “+”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Plus</span><span class="hljs-params">(n <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>s := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>s += str<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrBuilder</span><span class="hljs-params">(n <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> builder strings.Builder<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>builder.WriteString(str)<br>&#125;<br><span class="hljs-keyword">return</span> builder.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ByteBuffer</span><span class="hljs-params">(n <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>buf := <span class="hljs-built_in">new</span>(bytes.Buffer)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>buf.WriteString(str)<br>&#125;<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-2/4.png" alt="分别传入(1000, &quot;string&quot;)"></p><ul><li>字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 “+” 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和</li><li>strings.Builder，bytes.Buffer 的内存是以倍数申请的</li><li>strings.Builder 和 bytes.Buffer 底层都是 []byte 数组，bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回</li></ul><h3 id="1-4-空结构体"><a href="#1-4-空结构体" class="headerlink" title="1.4 空结构体"></a>1.4 空结构体</h3><p><strong>使用空结构体节省内存</strong></p><ul><li>空结构体不占据内存空间，可作为占位符使用。比如实现简单的 Set：Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。对于集合场景，只需要用到 map 的键而不需要值。</li></ul><h2 id="2-性能调优实战"><a href="#2-性能调优实战" class="headerlink" title="2 性能调优实战"></a>2 性能调优实战</h2><h3 id="2-1-分析工具"><a href="#2-1-分析工具" class="headerlink" title="2.1 分析工具"></a>2.1 分析工具</h3><p><img src="/ByteDance-2/5.png" alt="pprof"></p><h3 id="2-2-搭建项目"><a href="#2-2-搭建项目" class="headerlink" title="2.2 搭建项目"></a>2.2 搭建项目</h3><p><a href="https://blog.wolfogre.com/posts/go-ppof-practice/">参考教程</a><br>项目提前埋入了一些炸弹代码，产生可观测的性能问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span>  <span class="hljs-comment">// 自动注册 pprof 的 handler 到 http server</span><br>    <span class="hljs-comment">// ...</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.LstdFlags)<br>log.SetOutput(os.Stdout)<br><br>runtime.GOMAXPROCS(<span class="hljs-number">1</span>)                   <span class="hljs-comment">// 限制 CPU 使用数</span><br>runtime.SetMutexProfileFraction(<span class="hljs-number">1</span>)      <span class="hljs-comment">// 开启锁调用跟踪</span><br>runtime.SetBlockProfileRate(<span class="hljs-number">1</span>)          <span class="hljs-comment">// 开启阻塞调用跟踪</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 启动 http server</span><br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:6060&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> animal.AllAnimals &#123;<br>v.Live()<br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-浏览器查看指标"><a href="#2-3-浏览器查看指标" class="headerlink" title="2.3 浏览器查看指标"></a>2.3 浏览器查看指标</h3><p><img src="/ByteDance-2/6.png" alt="debug"></p><ul><li>CPU</li></ul><p><img src="/ByteDance-2/7.png" alt="CPU"></p><ul><li><code>go tool pprof &quot;http://127.0.0.1:6060/debug/pprof/profile?seconds=10&quot;</code></li><li><code>topN</code> 查看占用资源最多的函数</li><li><code>list</code> 根据指定的正则表达式查找代码行</li><li><code>web</code> 调用关系可视化</li></ul><p><img src="/ByteDance-2/8.png" alt="排查过程"></p><ul><li>heap-堆内存</li><li>goroutine-协程</li><li>mutex-锁</li><li>block-阻塞</li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 以太坊区块结构和数据存储</title>
    <link href="/Block/"/>
    <url>/Block/</url>
    
    <content type="html"><![CDATA[<p>此篇文章用以太坊为例，研究一下一个区块里面到底有什么，以及以太坊中的数据是怎么存储的。</p><span id="more"></span><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><p>一个区块由两部分组成：</p><ul><li>区块头（Header）</li><li>区块体（Body）</li></ul><p><img src="/Block/1.png" alt="Block"></p><p>轻节点只会存储 Header。</p><p>区块中的三棵树：</p><ul><li><p><strong>状态树</strong>：状态树是全局的、不断更新的，它的 key 为 keccak256(ethereumAddress)，value 为 rlp(ethereumAccount)。其中 ethereumAddress 表示以太坊账户地址；ethereumAccount 表示以太坊账户，包含四个字段：nonce，balance，storageRoot，codeHash。如果 storageRoot 和 codeHash 不为空，则为合约账户，其中 codeHash 对应合约代码的哈希，storageRoot 对应另一棵树的树根，这棵树我们称为<strong>存储树</strong>。存储树存储了合约的所有状态数据，每个合约有单独的存储树。</p></li><li><p><strong>交易树</strong>：每个区块都有一棵独立的交易树，对应区块头里的交易根。交易树的 key（路径）为 rlp(transactionIndex)，value 为交易序列化后的值。其中 transactionIndex 表示交易在该区块中的下标。</p></li><li><p><strong>回执树</strong>：每个交易对应一个交易回执，交易回执记录了交易执行结果，包括执行状态、Gas 消耗、事件日志等。每个区块有自己的回执树，对应了区块头里的回执根。与交易树类似，key 为 rlp(transactionIndex)，value 为交易回执序列化后的值。</p></li></ul><p><img src="/Block/2.png" alt="Trie"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>以太坊中的账户状态是用什么数据结构存储的呢？</p><p>有关这个问题<a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=16">肖臻老师的公开课</a>有非常详细的解释。这里直接说结论：</p><p><strong>Merkle Patricia Trie（MPT）</strong></p><p><img src="/Block/3.png" alt="World State Trie"></p><p>右上角为简化的 key-value 定义。我们可以看到图中有 2 个拓展节点，2 个分支节点，4 个叶子节点。在最下面的两个叶子节点中，prefix 3 的右边有个格子，有个箭头从 7 指向这个格子，表示 3 和 7 两个 nibble 组成一个字节存储。当一个节点被另一个节点在内部指向时（比如上图中的分支节点内部指向了叶子节点），父节点会存储 H(rlp.encode(x))。<br>其中 H(y) &#x3D; keccak256(y) if len(y) &gt;&#x3D; 32 else y，rlp.encode 为 RLP 编码函数。</p><p>由于 MPT 树是确定性的，所以如果两棵树存储了完全相同的数据，那么这两棵树的节点将完全相同，包括根节点。假设在某一时刻，当其中一个合约修改了某个变量的数据，使得它与另一个合约的数据不同时，会生成一个新的节点，并从新节点开始由下往上直到根节点，整个路径的节点值都会更新，新生成的节点会存储到硬盘，但旧的节点不会从硬盘删除。</p><p><img src="/Block/4.png" alt="update data"></p><h2 id="StateDB"><a href="#StateDB" class="headerlink" title="StateDB"></a>StateDB</h2><p>在以太坊中，StateDB 是一个用于管理账户状态数据的内存数据库，它的数据存储在节点的内存中，并且随着区块链的不断增长而不断变化。但是，为了确保数据的可靠性和持久性，StateDB 数据需要被定期持久化到磁盘中。</p><p>为了实现数据的持久化，以太坊节点使用了 LevelDB 这样的键值对存储引擎。当 StateDB 中的数据发生变化时，节点会将这些变化记录在 LevelDB 中，以便在下次启动时从磁盘中重新加载数据。</p><p>需要注意的是，由于 LevelDB 是一种磁盘存储引擎，相比于内存数据库，它的读写速度要慢很多。因此，在以太坊节点中，StateDB 通常被用作内存数据库，而 LevelDB 则用于实现数据的持久化。这种方式可以同时满足节点的高性能和数据的可靠性要求。</p><h2 id="block-go-源码"><a href="#block-go-源码" class="headerlink" title="block.go 源码"></a>block.go 源码</h2><p>研究那么多不如来看一看区块结构的源码：go-ethereum&#x2F;core&#x2F;types&#x2F;block.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Header represents a block header in the Ethereum blockchain.</span><br><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>ParentHash  common.Hash    <span class="hljs-comment">// 父区块的哈希</span><br>    UncleHash   common.Hash    <span class="hljs-comment">// 所有叔块的哈希（Block.uncles）</span><br>    Coinbase    common.Address <span class="hljs-comment">// 接受出块奖励的地址，矿工出块时在这个字段填入自己的地址</span><br>    Root        common.Hash    <span class="hljs-comment">// 此区块包含的所有交易完成后，state 对象的哈希值</span><br>    TxHash      common.Hash    <span class="hljs-comment">// 此区块包含的所有交易的哈希（Block.transactions）</span><br>    ReceiptHash common.Hash    <span class="hljs-comment">// 此区块所有交易完成后所产生的所有收据的哈希</span><br>    Bloom       Bloom          <span class="hljs-comment">// 用来快速判断一个参数 Log 对象是否存在于一组已知的 Log 集合中</span><br>    Difficulty  *big.Int       <span class="hljs-comment">// 此区块的难度值</span><br>    Number      *big.Int       <span class="hljs-comment">// 此区块的高度</span><br>    GasLimit    <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 此区块所有交易消耗的 gas 值的上限</span><br>    GasUsed     <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 此区块所有交易消耗的 gas 的实际值</span><br>    Time        *big.Int       <span class="hljs-comment">// 区块时间戳</span><br>    Extra       []<span class="hljs-type">byte</span>         <span class="hljs-comment">// 区块的额外数据</span><br>    MixDigest   common.Hash    <span class="hljs-comment">// 以太坊 hashimoto 算法产生的哈希</span><br>    Nonce       BlockNonce     <span class="hljs-comment">// 通过此字段产生符合 Difficulty 值要求的区块哈希</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Body <span class="hljs-keyword">struct</span> &#123;<br>Transactions []*Transaction<br>Uncles       []*Header<br>&#125;<br><br><span class="hljs-comment">// Block represents an entire block in the Ethereum blockchain.</span><br><span class="hljs-keyword">type</span> Block <span class="hljs-keyword">struct</span> &#123;<br>header       *Header<br>uncles       []*Header<br>transactions Transactions<br><br><span class="hljs-comment">// caches</span><br>hash atomic.Value<br>size atomic.Value<br><br><span class="hljs-comment">// 从创世块开始，到当前区块截止，累积的所有区块 Difficulty 之和</span><br>td *big.Int<br><br><span class="hljs-comment">// These fields are used by package eth to track</span><br><span class="hljs-comment">// inter-peer block relay.</span><br>ReceivedAt   time.Time<br>ReceivedFrom <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见一个区块携带的数据主要是：<strong>Header 中的信息 + 叔块们的头部信息 + 块中包含的所有交易信息</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Web3.0 黑话</title>
    <link href="/Black-words/"/>
    <url>/Black-words/</url>
    
    <content type="html"><![CDATA[<p>区块链&#x2F;Token 等专业术语。</p><span id="more"></span><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><ul><li><p>AA：Account Abstraction，账户抽象希望用户使用包含任意验证逻辑的智能合约钱包，而不是 EOAs 作为他们的主要帐户。</p></li><li><p>ABI：Application Binary Interface，类似于API，是两个二进制程序模块之间接口。</p></li><li><p>address：钱包&#x2F;合约地址。</p></li><li><p>alpha：超额收益机会。</p></li><li><p>AMA：Ask Me Anything，项目方面向公众的问答会。</p></li><li><p>AMM：Autonomous Market Making，自动化做市商，是去中心化交易所的常用技术。</p></li><li><p>ape：梭哈。</p></li><li><p>ATH：All Time High，历史最高的价格。</p></li></ul><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><ul><li><p>Blockchain：区块链。</p></li><li><p>Bridge：跨链桥，连接不同公链上的资产的应用。</p></li><li><p>Buy the fucking dip: 抄底。</p></li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul><li><p>CA：Contract Accounts，合约账户（也曾被称为内部账户）。</p></li><li><p>CeFi：Centralized Finance，中心化金融。</p></li><li><p>Cex：Centralized Exchange，中心化交易所。</p></li></ul><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><ul><li><p>DAO：Decentralized Autonomous Organization，去中心化自治组织。</p></li><li><p>Dapp：Decentralized Application，去中心化应用。</p></li><li><p>DeFi：Decentralized Finance，去中心化金融。</p></li><li><p>degen：degenerate，赌徒&#x2F;梭哈的人。</p></li><li><p>DeX：Decentralized Exchange，去中心化交易所。</p></li><li><p>Diamond hands：钻石手，长期持有代币&#x2F;NFT的人。</p></li><li><p>DID：Decentralized Identity，去中心化身份。</p></li><li><p>discord：社群常用的信息传播平台。</p></li><li><p>dm：direct message，私信。</p></li><li><p>DYOR：Do Your Own Research，自己研究，自己负责。</p></li></ul><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><ul><li><p>EOA：Externally Owned Accounts，以太坊网络中的外部账户，EOA 是交易的触发器，一笔交易无论后面有多少合约调用，一开始都必须由一个 EOA 发起并且支付足够的 gas 才可以进行。</p></li><li><p>ERC20：以太坊上的同质化代币标准。</p></li><li><p>ERC721：以太坊上的非同质化代币标准。</p></li><li><p>Ethereum：以太坊，一个去中心化的开源区块链网络，也是它的原生代币名字。</p></li><li><p>EVM：Ethereum Virtual Machine，以太坊虚拟机，是区块链开发人员用来在以太坊区块链上部署去中心化应用程序 (Dapp) 的软件应用程序。</p></li></ul><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><ul><li><p>FT: fungible token，同质化代币。</p></li><li><p>FYI(for your information): 供你参考。</p></li><li><p>flash loan: 闪电贷。在同一笔交易内完成借款和还款，常用于套利。</p></li></ul><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><ul><li>gas：燃料，表示在区块链完成交易所需的计算工作量。</li></ul><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><ul><li>hacked：被黑客攻击了。</li></ul><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><ul><li><p>ifykyk: 懂得都懂。</p></li><li><p>ICO: Initial Coin Offering 首次代币发行。</p></li><li><p>IFO：Initial Farm Offering 首次农场（质押）发行。</p></li><li><p>IEO：Initial Exchange Offering 首次交易所发行（比如在币安交易所发行）。</p></li><li><p>IDO：Initial DEX Offering 首次去中心化交易所发行（比如在 Pancakeswap 上发行）。</p></li></ul><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><ul><li><p>layer2：建立在现有公链上的二层框架，通常会有更快更便宜的交易、更多的存储空间。</p></li><li><p>liquidity：流动性。</p></li></ul><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><ul><li><p>meme：谜因&#x2F;梗，可以传播的东西。</p></li><li><p>Mempool：交易缓冲池，在交易被发出但未上链的时候，会出现在这里。</p></li><li><p>Merkle Tree：区块链用于安全验证和汇总大型数据集的数据结构。</p></li><li><p>MEV：Miner Extractable Value 或 Maximal Extractable Value，指矿工通过在一个区块中包含、排除或重新排序交易可以获得的利润。</p></li><li><p>Mint：铸造 NFT&#x2F;ERC20。</p></li><li><p>Moon: to the moon, 暴涨。</p></li><li><p>MPC：Multi-Party Computation，多方安全计算，是一种范式，包含很多技术方案，在目前 Web3 的语境下大都指的是 TSS。</p></li></ul><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><ul><li><p>nfa：Not Financial Advice，不是投资建议。</p></li><li><p>NFT：Non-Fungible Token，非同质化代币。</p></li><li><p>Noob：菜鸡。</p></li><li><p>Nonce：随机数</p></li></ul><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><ul><li><p>OG：Original Gangster，元老。</p></li><li><p>on-chain：链上。</p></li><li><p>off-chain：链下，不上链。</p></li><li><p>optimistic rollups：乐观汇总，一种以太坊layer2解决方案。</p></li><li><p>oracle：预言机， 把信息通过去中心化的方式转到链上， 通过保证传入信息的去中心化程度和准确性， 从而保持该Dapp的去中心化程度。</p></li></ul><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><ul><li><p>pfp：profile picture，个人头像。</p></li><li><p>PoS：Proof of Stake，权益证明，参与者通过持仓质押维护区块链网络正常运行。</p></li><li><p>PoW：Proof of Work，工作量证明，参与者通过花费计算能力和能量维护区块链网络正常运行。</p></li></ul><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><ul><li><p>ReFi：Regenerative Finance，可再生&#x2F;可持续金融。</p></li><li><p>roadmap：路线图（画大饼）。</p></li><li><p>RT：Retweet 推特转发。</p></li></ul><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><ul><li><p>Sandwich Attack：三明治攻击&#x2F;夹子，攻击者会抢在受害者的大笔买入订单之前买入、提高价格，在受害者订单后下达卖单，赚取收益。</p></li><li><p>SBT：Soulbound Token，灵魂绑定代币，不能交易的NFT。</p></li><li><p>SCW&#x2F;A：Smart Contract Wallet&#x2F;Account，用 CA 作为地址的钱包方案，智能合约钱包可以实现很多 EOA 无法实现的功能，比如 gas 代付，批量交易，权限管理，离线授权，社交恢复等等。</p></li><li><p>Smart Contracts：智能合约，在区块链上运行的一段代码。</p></li><li><p>Solidity：以太坊上的编写智能合约的语言。</p></li></ul><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><ul><li><p>Tokenomics：代币经济学。</p></li><li><p>TSS：Threshold Signature Scheme，门限签名是一种分布式多方签名协议。</p></li><li><p>TVL：Total Value Locked，协议中锁定的资金总价值。</p></li></ul><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><ul><li>Up Only：一直上涨（大家的美好愿望）。</li></ul><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><ul><li><p>wallet：钱包。</p></li><li><p>web3.0：以去中心化和数字所有权为特征的互联网，与Web1.0和Web2.0不同。</p></li><li><p>WL：White List，白名单。</p></li></ul><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><ul><li>zk：zero-knowledge proof，零知识证明，可以证明一个人拥有某个秘密，但不用泄露秘密本身。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Git 使用教程</title>
    <link href="/Tutorial-Git/"/>
    <url>/Tutorial-Git/</url>
    
    <content type="html"><![CDATA[<p>Git is very good!</p><span id="more"></span><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><p><img src="/Tutorial-Git/1.png" alt="工作流程"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li><li><strong>暂存区</strong>：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库</strong>：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</li><li><strong>远程版本库</strong>：一般指的是 Git 服务器上所对应的仓库，如 github 仓库。</li></ul><p><img src="/Tutorial-Git/2.jpg" alt="关系"></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><code>git init</code>：初始化仓库</li><li><code>git config</code>：配置开发者用户名和邮箱</li><li><code>git clone</code>：从 git 服务器拉取代码</li><li><code>git status</code>：查看文件变动状态</li><li><code>git add .</code>：添加文件到暂存区</li><li><code>git commit</code>：提交文件变动到版本库</li><li><code>git push</code>：将本地的代码改动推送到服务器</li><li><code>git pull</code>：将服务器上的最新代码拉取到本地</li><li><code>git log</code>：查看版本提交记录</li><li><code>git tag</code>：为项目标记里程碑</li><li><code>git reset</code>：回退版本</li><li>.gitignore：设置哪些内容不需要推送到服务器，这是一个配置文件</li></ul><p>具体参数可参考<a href="https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA">这篇文章</a></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ul><li>分支（Branch）：分支是为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改。</li><li>主分支（Master&#x2F;Main）：前面提到过 master 是 Git 为我们自动创建的第一个分支，也叫主分支，其它分支开发完成后都要合并到 master。</li><li>HEAD：指向的就是当前分支的最新提交。</li></ul><p><img src="/Tutorial-Git/3.png" alt="Branch"></p><ul><li><code>git branch</code>：创建、重命名、查看、删除项目分支</li><li><code>git checkout</code>：切换分支</li><li><code>git merge</code>：合并分支</li></ul><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>如果你想通过 Git 分享你的代码或者与其他开发人员合作。你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p>本例使用了 Github 作为远程仓库，可以阅读 <a href="https://www.runoob.com/w3cnote/git-guide.html">Github 简明教程</a>。</p><p><img src="/Tutorial-Git/4.png" alt="Github"></p><ul><li><code>git fetch</code>：从远程仓库下载新分支与数据</li><li><code>git merge</code>：从远端仓库提取数据并尝试合并到当前分支</li></ul><p><img src="/Tutorial-Git/5.png" alt="提取"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 QUIC 协议理解</title>
    <link href="/QUIC/"/>
    <url>/QUIC/</url>
    
    <content type="html"><![CDATA[<p>QUIC（Quick UDP Internet Connections）是一种基于 UDP 的传输协议，旨在加速 HTTP 通信，同时使其变得更加安全，其最终目的是在 web 上代替 TCP 和 TLS 协议。</p><span id="more"></span><h2 id="HTTP-发展史"><a href="#HTTP-发展史" class="headerlink" title="HTTP 发展史"></a>HTTP 发展史</h2><p>Hyper Text Transfer Protocol（超文本传输协议），是用于从万维网（WWW：World Wide Web）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。</p><p><img src="/QUIC/3.png" alt="HTTP protocol"></p><h3 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h3><p>HTTP 是基于 TCP&#x2F;IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。 最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令：GET。</p><p>TCP 连接建立后，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。服务器发送完毕，就关闭 TCP 连接。</p><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>1996 年 5 月，HTTP&#x2F;1.0 版本发布，内容大大增加：</p><ul><li>任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。</li><li>除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。</li><li>HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</li><li>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</li></ul><p>HTTP&#x2F;1.0 的主要缺点：</p><ul><li>每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li><li>TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（Slow start）。</li></ul><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>1997 年 1 月，HTTP&#x2F;1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议：</p><ul><li><strong>长连接</strong>：HTTP&#x2F;1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</li><li><strong>缓存处理</strong>：HTTP&#x2F;1.1 引入了更多的缓存控制策略。</li><li><strong>带宽优化及网络连接的使用</strong>：HTTP&#x2F;1.0 中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能；HTTP&#x2F;1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>：新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host 头处理</strong>：在 HTTP&#x2F;1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。HTTP&#x2F;1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li></ul><p>HTTP&#x2F;1.1 的主要缺点：</p><ul><li>同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<strong>队头堵塞</strong>（Head-of-line blocking）。</li><li>HTTP&#x2F;1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li><li>HTTP&#x2F;1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</li><li>虽然 HTTP&#x2F;1.x 支持了 keep-alive，来弥补多次创建连接产生的延迟，但是 keep-alive 使用多了同样会给服务端带来大量的性能压力，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ul><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>2009 年，Google 公开了自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。 这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP&#x2F;2 的基础，主要特性都在 HTTP&#x2F;2 之中得到继承：</p><ul><li><strong>降低延迟</strong>：针对 HTTP 高延迟的问题，SPDY 采取了<strong>多路复用</strong>（multiplexing），通过多个请求 stream 共享一个 tcp 连接的方式，降低延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。</li><li><strong>header 压缩</strong>：前面提到 HTTP&#x2F;1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>加密传输</strong>：基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>：采用了 SPDY 的网页，例如网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。</li></ul><p><img src="/QUIC/1.png" alt="SPDY"></p><h3 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2 可以说是 SPDY 的升级版（其实原本也是基于 SPDY 设计的），但是 HTTP&#x2F;2 跟 SPDY 仍有不同的地方：</p><ul><li>HTTP&#x2F;2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。</li><li>HTTP&#x2F;2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE。</li></ul><p><img src="/QUIC/2.png" alt="multiplexing"></p><p>在 Internet 和 HTTP 的发展过程中，HTTP 的底层传输机制基本没有变化。然而，随着移动设备技术的大规模普及，实时应用需求的增加，互联网流量不断增长，HTTP&#x2F;2 的缺点也越来越明显。</p><h3 id="HTTP-x2F-3-0"><a href="#HTTP-x2F-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h3><p>HTTP&#x2F;2 的最大特性就是多路复用，但是每个 HTTP 连接都是由 TCP 进行连接建立和传输的，TCP 协议在处理包时有严格的顺序要求。这也就是说，当某个包切分的 stream 由于某些原因丢失后，服务器不会处理其他 stream，而会优先等待客户端发送丢失的 stream。</p><p>HTTP&#x2F;3 使用了一种名为 QUIC 的协议，该协议运行在 UDP 协议之上，而不是 TCP。UDP 允许消息的多向广播，这一特性有助于解决数据包级别的<strong>队头阻塞</strong>问题。</p><p>此外，QUIC 重新设计了客户端和服务器之间握手的方式，减少了与建立重复连接相关的延迟。</p><p><img src="/QUIC/5.png" alt="重复连接时的 handshake"></p><p>HTTP&#x2F;3 在语法和语义上与 HTTP&#x2F;2 相似，遵循着相同的请求和响应消息交换顺序，其数据格式包含方法、报头、状态码和正文。HTTP&#x2F;3 的显着差异在于 UDP 之上协议层的堆叠顺序，如下图所示。</p><p><img src="/QUIC/6.png" alt="比较"></p><h2 id="TCP-的局限性"><a href="#TCP-的局限性" class="headerlink" title="TCP 的局限性"></a>TCP 的局限性</h2><ul><li><p><strong>TCP 的队头阻塞</strong></p><p>  如果序列号较低的数据段尚未到达&#x2F;接收，即使序列号较高的段已经到达&#x2F;接收，TCP 的接收器滑动窗口也不会前进。这会导致 TCP 流暂时挂起甚至关闭，这个问题称为 TCP 流的<strong>队头阻塞</strong>。队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。</p></li></ul><p><img src="/QUIC/7.png" alt="HoL"></p><ul><li><p><strong>TCP 不支持流级多路复用</strong></p><p>  虽然 TCP 允许与应用层之间的多个逻辑连接，但它不允许在单个 TCP 流中多路复用数据包。使用 HTTP&#x2F;2，浏览器只能打开一个与服务器的 TCP 连接。它使用同一个连接来请求多个对象，例如 CSS、JavaScript 和其他文件。在接收这些对象时，TCP将同一流中的所有对象序列化。因此，它不知道 TCP 段的对象级分区。</p></li><li><p><strong>TCP 握手导致连接成本</strong></p><p>  在进行连接握手时，TCP 交换一系列消息，如果与已知主机建立连接，会有冗余的消息交换序列。对于很多短连接场景，这样的握手延迟影响很大，且无法消除。</p></li></ul><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>在 TCP 中，TCP 为了保证数据的可靠性，使用了序号 + 确认号机制来实现，一旦带有 synchronize sequence number 的包发送到服务器，服务器都会在一定时间内进行响应，如果过了这段时间没有响应，客户端就会重传这个包，直到服务器收到数据包并作出响应为止。</p><p>虽然 QUIC 没有使用 TCP 协议，但是它也保证了可靠性，QUIC 实现可靠性的机制是使用了 Packet Number，这个序列号可以认为是 syn 的替代者，这个序列号也是递增的。与 syn 所不同的是，不管服务器有没有接收到数据包，这个 Packet Number 都会 +1，而 syn 是只有服务器发送 ack 响应之后，syn 才会 +1。</p><p><img src="/QUIC/9.png" alt="序列号"></p><p>QUIC 引入了一个 stream offset 的概念，一个 stream 可以传输多个 stream offset，每个 stream offset 其实就是一个 PN 标识的数据，即使某个 PN 标识的数据丢失，PN+1 后，它重传的仍旧是 PN 所标识的数据，等到所有 PN 标识的数据发送到服务器，就会进行重组，以此来保证数据可靠性。到达服务器的 stream offset 会按照顺序进行组装，这同时也保证了数据的顺序性。</p><p><img src="/QUIC/10.png" alt="stream offset"></p><p>QUIC 相比于 HTTP&#x2F;2 具有下面这些优势：</p><ul><li><p><strong>选择 UDP 作为底层传输层协议</strong></p><p>  如果还在TCP 之上的建立新的传输机制，将仍继承前面所说的TCP限制。QUIC 是在用户级别构建的，它不需要在每次协议升级时更改内核，从而更易采用。</p></li><li><p><strong>流复用和流量控制</strong></p><p>  QUIC 引入了在单个连接上多路复用流的概念。QUIC 实现了单独的、逐流的流量控制。UDP 本身没有建立连接这个概念，QUIC 使用的 stream 之间是相互隔离的，不会阻塞其他 stream 数据的处理，所以使用 UDP 并不会造成队头阻塞。</p></li></ul><p><img src="/QUIC/8.png" alt="使用 UDP，没有包级的队头阻塞"></p><ul><li><p><strong>灵活的拥塞控制</strong></p><p>  TCP 有严格的拥塞控制机制。每次 TCP 协议检测到拥塞时，它都会将拥塞窗口的大小减半。QUIC 的拥塞控制更加灵活，从内核空间到用户空间，可以更有效地利用可用网络带宽，从而获得更好的流量吞吐量。</p></li><li><p><strong>更好的错误处理</strong></p><p>  QUIC 提议使用增强的丢失恢复机制和前向纠错来处理错误的数据包，尤其是对于在传输中容易出现高错误率的缓慢的无线网络。</p></li><li><p><strong>更快地握手</strong></p><p>  QUIC 使用与 HTTP&#x2F;2 相同的 TLS 模块来实现安全连接。然而，与 TCP 不同的是，QUIC 的握手机制经过优化，可以避免在两个已知对等点相互建立通信时进行冗余协议交换。使用 TCP 和 TLS 建立安全连接至少需要两次往返时间（RTT），增加了延迟开销。使用 QUIC，建立第一个加密连接是 1 个 RTT，当会话恢复时，有效负载数据与第一个数据包一起发送，RTT 最少为零。</p></li></ul><p><img src="/QUIC/11.png" alt="QUIC"></p><ul><li><p><strong>语法和语义</strong></p><p>  通过在 QUIC 之上构建基于 HTTP&#x2F;3 的应用层，可以获得增强传输机制的所有优势，同时保留与 HTTP&#x2F;2 相同的语法和语义。但是 HTTP&#x2F;2 不能直接与 QUIC 集成，因为从应用到传输的底层帧映射是不兼容的。因此，IETF 的 HTTP 工作组建议将 HTTP&#x2F;3 作为新的 HTTP 版本，并根据 QUIC 协议的帧格式要求修改其帧映射。</p></li><li><p><strong>压缩</strong></p><p>  HTTP&#x2F;3 还使用了一种称为 QPACK 的新报头压缩机制，是对 HTTP&#x2F;2 中使用的 HPACK 的修改。在 QPACK 下，HTTP 报头可以在不同的 QUIC 流中乱序到达。QPACK 使用了一种查找表机制来对报头进行编码和解码。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> QUIC 作为一个新的传输层协议，它在设计上针对 TCP 的不足进行了很多优化。它提供的多路传输、快速握手等新特性使得它和 TCP 相比在理论上可以获得更低的数据传输延时。现有测量工作表明，QUIC 在大部分情况下的确能比 TCP 达到更低的传输延时，但是仍然有部分情况下 QUIC 的表现不如 TCP。这些 QUIC 性能表现较差的场景往往是拥塞算法的选择、服务器部署等外部因素造成的，而非 QUIC 本身的设计缺陷。因此，QUIC 的软件实现仍然有很大的进步空间。</p><p> 另外关于队头阻塞的问题，本文描述过于简略，有兴趣可以学习<a href="https://www.cnblogs.com/sexintercourse/p/16839900.html">这篇文章</a>。</p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Docker 使用教程</title>
    <link href="/Tutorial-Docker/"/>
    <url>/Tutorial-Docker/</url>
    
    <content type="html"><![CDATA[<p>Docker 容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是 “一次构建，到处运行（Build once，run anywhere）”。避免了“代码在我这里可以运行啊”的尴尬局面。</p><span id="more"></span><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><ul><li><p><strong>镜像（Image）</strong>：相当于是一个 root 文件系统。Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</p></li><li><p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></li><li><p><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</p></li><li><p><strong>客户端（Client）</strong>：Docker 客户端通过命令行或者其他工具使用 <a href="https://docs.docker.com/develop/sdk/">Docker SDK</a> 与 Docker 的守护进程通信。</p></li><li><p><strong>主机（Host）</strong>：一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</p></li></ul><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><p><img src="/Tutorial-Docker/1.png" alt="Docker 架构"></p><p>在没有使用 Docker 时，我们开发完毕一个项目，需要打成 war 包或 jar 包。然后，在服务器上进行各种环境的安装、配置以及应用程序维护，比如：JDK、Tomcat、数据库等。而且，上述的配置在开发环境、测试服务器、生产服务器（通常会有很多个），都需要进行一遍同样的操作，工作量相当繁重。</p><p>在使用了 Docker 之后，我们可以自己创建一个空的镜像从头构建，也可以使用公共仓库中已经构建好的镜像，直接使用。当需要在不同环境中进行部署时，直接使用构建好的镜像即可。</p><p><img src="/Tutorial-Docker/3.png" alt="Docker 优势"></p><h2 id="Docker-容器与虚拟机"><a href="#Docker-容器与虚拟机" class="headerlink" title="Docker 容器与虚拟机"></a>Docker 容器与虚拟机</h2><p>虚拟机是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。创建虚拟机时，会将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存，每个虚拟机都有独立的硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。虚拟机会消耗大量系统资源和开销，尤其是当多个虚拟机在同一物理服务器上运行时，每个虚拟机都有自己的子操作系统，大量精力以及资源被用于虚拟化的部署和运行上。</p><p>容器类似于虚拟机，只是容器不是完整的操作系统，容器通常只包含必要的操作系统包和应用程序，这就是它们轻量级的原因。</p><p><img src="/Tutorial-Docker/2.png" alt="容器与虚拟机"></p><p>传统的虚拟机是在宿主机之上，又添加了一个新的操作系统，这就导致了虚拟机的臃肿，不适合迁移。而 Docker 是直接寄存在宿主机上，完全就会避免大部分虚拟机带来的困扰。</p><p>Docker 是一个黑盒的进程，区别于传统的进程，Docker 可以独立出一个自己的空间，不会使得在 Docker 中的行为以及变量溢出到宿主机上。</p><h2 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h2><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务：</p><ul><li>科大镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></li><li>网易：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></li><li>阿里云：https:&#x2F;&#x2F;&lt;你的ID&gt;.mirror.aliyuncs.com（<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像获取地址</a>）</li><li>七牛云加速器：<a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></li></ul><p>对于使用 systemd 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;<br></code></pre></td></tr></table></figure><p>之后重新启动服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ sudo systemctl daemon-reload<br>$ sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>检查是否生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker info<br>Registry Mirrors:<br>    https://reg-mirror.qiniu.com<br></code></pre></td></tr></table></figure><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><ol><li><p>当前系统 Docker 信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker<br>$ docker info<br>$ docker version<br></code></pre></td></tr></table></figure></li><li><p>容器使用</p><ul><li><p><strong>获取镜像</strong><br>  如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker pull ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>启动容器</strong><br>  以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker run -it ubuntu /bin/bash<br><br>参数说明：<br>-i: 交互式操作。<br>-t: 终端。<br>ubuntu: ubuntu 镜像。<br>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。<br><br>退出终端：<br># exit<br></code></pre></td></tr></table></figure></li><li><p><strong>查看所有容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker ps -a<br></code></pre></td></tr></table></figure><p>  查看当前有哪些容器正在运行</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker ps<br></code></pre></td></tr></table></figure></li><li><p><strong>启动、停止、重启容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker start container_id<br>$ docker stop container_id<br>$ docker restart container_id<br></code></pre></td></tr></table></figure></li><li><p><strong>后台运行</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker run -itd --name ubuntu-test ubuntu /bin/bash<br></code></pre></td></tr></table></figure></li><li><p><strong>进入容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker attach container_id<br>如果从这个容器退出，会导致容器的停止<br><br>$ docker exec -it container_id /bin/bash<br>如果从这个容器退出，容器不会停止，推荐大家使用 docker exec<br></code></pre></td></tr></table></figure></li><li><p><strong>删除容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker rm -f container_id<br></code></pre></td></tr></table></figure></li></ul></li><li><p>镜像使用</p><ul><li><p><strong>查看宿主机上的镜像</strong><br>   Docker 镜像保存在 &#x2F; var&#x2F;lib&#x2F;docker 目录下</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker images<br></code></pre></td></tr></table></figure></li><li><p><strong>拉取新的镜像</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker pull image_name:tag<br></code></pre></td></tr></table></figure></li><li><p><strong>删除镜像</strong></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker rmi hello-world<br></code></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://www.runoob.com/docker/docker-hello-world.html">更多命令</a></p></li></ol><h2 id="个人疑问"><a href="#个人疑问" class="headerlink" title="个人疑问"></a>个人疑问</h2><p><strong>Linux docker 宿主机是否可以运行 Windows 容器？</strong></p><ul><li>Windows docker 宿主机可以运行 Windows 和 Linux 容器。</li><li>Linux docker 宿主机只能运行 Linux 容器。</li><li>Windows 宿主机可以运行 Linux 容器的原因是： Windows 在后台创建了一个 Linux 子系统，因此 Linux 容器仍在 Linux 上运行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 TCP 与 TLS/SSL</title>
    <link href="/TCP-IP-handshake/"/>
    <url>/TCP-IP-handshake/</url>
    
    <content type="html"><![CDATA[<p>本文总结 TCP 的三次握手和四次挥手，以及 TLS&#x2F;SSL 的四次握手过程。</p><span id="more"></span><h2 id="TCP-连接的建立（三次握手）"><a href="#TCP-连接的建立（三次握手）" class="headerlink" title="TCP 连接的建立（三次握手）"></a>TCP 连接的建立（三次握手）</h2><p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><p><img src="/TCP-IP-handshake/1.png" alt="三次握手"></p><ol><li>TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态。</li><li>TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文。报文首部中的同部位 SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x。此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN&#x3D;1 的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中 ACK&#x3D;1，SYN&#x3D;1，确认号是 ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK&#x3D;1，ack&#x3D;y+1，自己的序列号 seq&#x3D;x+1，此时，TCP连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段<strong>可以</strong>携带数据，如果<strong>不携带数据则不消耗序号</strong>。</li><li>当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。</li></ol><blockquote><p><strong>为什么TCP客户端最后还要发送一次确认呢？</strong></p><p>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><h2 id="TCP-连接的释放（四次挥手）"><a href="#TCP-连接的释放（四次挥手）" class="headerlink" title="TCP 连接的释放（四次挥手）"></a>TCP 连接的释放（四次挥手）</h2><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p><p><img src="/TCP-IP-handshake/2.png" alt="四次挥手"></p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN&#x3D;1，其序列号为 seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号 seq&#x3D;v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq&#x3D;w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是 seq&#x3D;u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2?MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</li><li>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</li></ol><blockquote><p><strong>为什么客户端最后还要等待 2MSL？</strong></p><p>MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><blockquote><p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p></blockquote><h2 id="TLS-x2F-SSL-握手"><a href="#TLS-x2F-SSL-握手" class="headerlink" title="TLS&#x2F;SSL 握手"></a>TLS&#x2F;SSL 握手</h2><p>SSL（Secure Socket Layer 安全套接层）是 TCP&#x2F;IP 协议中位于 HTTP 之下，TCP 之上的一个可选协议层。起初 HTTP 在传输数据时使用的是明文，是不安全的。为了解决这个隐患，网景（Netscap）公司推出了 SSL。</p><p>HTTPS（HTTP+SSL）的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时， 互联网工程任务组（IETF）对 SSL3.0 进行了标准化，并添加了少数机制，并将其更名为 TLS1.0（Transport Layer Security 安全传输层协议）。</p><p><img src="/TCP-IP-handshake/3.png" alt="HTTPS = HTTP + TLS/SSL"></p><p>在 HTTPS 协议中，当客户端与服务器通过三次握手建立 TCP 连接之后，并不会直接传输数据，而是会经过一个 SSL&#x2F;TLS 握手的过程，用于协商、以及验证证书等，之后就可以安全传输数据了。</p><p><img src="/TCP-IP-handshake/4.png" alt="TLS/SSL 握手"></p><ol><li><p>Client Hello：由客户端发起，主要包含以下信息：</p><ul><li>客户端生成的随机数 x，用于之后的密钥生成</li><li>客户端支持的加密算法列表（Cipher Suites）</li><li>TLS 版本信息</li><li>客户端支持的压缩算法列表（Compression Methods）</li></ul></li><li><p>Server Hello：服务端接收到客户端的 Client Hello 之后，服务端需要将自己的 CA 证书发送给客户端，这个步骤叫 Server Certificate。证书是对服务端的一种认证，是由专门的数字证书认证机构（CA）审核之后颁发的，所以一般人无法伪造。在颁发证书的同时还会产生两把钥匙，一把私钥，一把公钥。私钥由服务端保管不可泄露，公钥则附带在证书中公开。证书本身还附带了一个证书电子签名，这个签名用来验证证书的完整性和真实性，防止证书被人窜改。跟客户端一样，服务端也需要生产一个随机数 y 发送给客户端，客户端和服务端都需要使用这俩随机数生成通信密钥，这个过程叫 Server Key Exchange。最后服务端会发送一个 Server Hello Done 给到客户端，表示 Server Hello 过程结束。综上，由服务端发起的消息内容，主要包含：</p><ul><li>确认使用的加密通信协议版本，比如 TLS 1.2 版本。如果客户端和服务端支持的版本不一致，服务端关闭加密通信</li><li>服务端生成的随机数 y，用于之后的密钥生成</li><li>在客户端发送的加密算法列表里选一个加密算法，比如 RSA 公钥加密</li><li>服务器 CA 证书</li></ul></li><li><p>Certificate Verify：如果服务端需要客户端进行验证，在客户端收到服务端的 Server Hello 消息之后，首先需要向服务端发送客户端的证书，让服务端验证客户端的合法性。这个过程叫 Client Certificate。接着，客户端需要对服务端的证书进行检查，如果证书不是可信机构颁布、或证书中的域名与实际域名不符、或者证书已过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没问题，客户端就会从服务器证书中取出服务端公钥。这个过程叫 Certificate Verify。客户端用这个服务端的公钥加密一个随机数 z，并把这个加密过的随机数发送给服务端，这个过程叫 Client Key Exchange。由客户端会告诉服务端已经切换到协商好的加密算法的状态了，这个过程叫 Change Cipher Spec。最后由已经协商好的加密算法和之前的随机数 x、y、z，产生的一个密钥就是整个消息加密解密过程的核心所在了。这个过程叫 Encrypted Handshake Message。综上，由客户端发送给服务端的信息如下：</p><ul><li>由服务器公钥加密过的随机数 z，用于生成服务器的密钥</li><li>编码改变通知，表示随后的信息都将由双方协商的加密方法和密钥发送</li><li>客户端 TLS 握手结束通知，这一项也是前面发送所有内容的哈希值，用来供服务器校验</li></ul></li><li><p>Server Finish：服务端在接收到客户端传来的加密过的随机数 z 之后，使用自己的私钥对其进行解密获取随机数 z，并对数据进行验证。验证无误，用协商好的加密算法和之前的随机数 x、y、z 产生服务器密钥，它和客户端生成的密钥是一致的，因为此后的加密都是对称加密了。这个过程叫 Encrypted Handshake Message。等一切完毕之后，会给客户端发送通知，告知客户端已经切换到协商过的加密算法，这个过程叫 Change Cipher Spec。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 TCP/IP 分层结构</title>
    <link href="/TCP-IP-fiveLayers/"/>
    <url>/TCP-IP-fiveLayers/</url>
    
    <content type="html"><![CDATA[<p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;互联网协议）是互联网的基本协议，也是国际互联网络的基础。TCP&#x2F;IP 是一个协议族，包括多个网络协议，定义了计算机操作系统如何连入互联网，以及数据传输的标准。它是为了解决不同系统的计算机之间的传输通信而提出的一个标准，不同系统的计算机采用了同一种协议后，就能相互通信，从而能够建立网络连接，实现资源共享和网络通信。</p><span id="more"></span><h2 id="TCP-x2F-IP-的分层结构"><a href="#TCP-x2F-IP-的分层结构" class="headerlink" title="TCP&#x2F;IP 的分层结构"></a>TCP&#x2F;IP 的分层结构</h2><p>目前对计算机网络的分层方式一共有三种：1.OSI 七层模型；2.五层模型；3.TCP&#x2F;IP 四层模型</p><p>OSI 是一种理论模型，实现起来过分复杂，而且运行效率低。OSI 先有模型，后有协议，先有标准，后进行实践，而 TCP&#x2F;IP 则相反。TCI&#x2F;IP 已经被广泛使用，成为网络互连实际上的标准。而五层模型一般只出现在计算机网络学习教学过程中，是对七层模型和四层模型的一个折中。</p><p><img src="/TCP-IP-fiveLayers/1.png" alt="三种模型"></p><ul><li><strong>应用层</strong>：包含所有的高层协议，比如 Telnet（Telecommunications Network，远程登录协议）、FTP、SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）、DNS（Domain Name Service，域名服务）、NNTP（Net News Transfer Protocol，网络新闻传输协议）和 HTTP 等。Telnet 允许一台机器上的用户登录远程机器进行工作，FTP 提供将文件从一台机器上移到另一台机器上的有效方法，SMTP用于电子邮件的收发，DNS 用于把主机名映射到网络地址，NNTP 用于新闻的发布、检索和获取，HTTP 用于在 WWW 上获取主页。</li><li><strong>传输层</strong>：著名的 TCP 和 UDP（User Datagram Protocol，用户数据报协议）就在这一层。TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</li><li><strong>网络层</strong>：该层是整个 TCP&#x2F;IP 体系结构的关键部分，其功能是使主机可以把数据报（Packet，或称为分组）发往任何网络，并使分组独立地传向目标。这些分组经由不同的网络到达的顺序和发送的顺序可能不同。网络层使用的协议有 IP。</li><li><strong>数据链路层</strong>：该层是整个体系结构的基础部分，负责接收 IP 层的 IP 数据报，通过网络向外发送，或接收从网络上来的物理帧，抽出 IP 数据报，向 IP 层发送。该层是主机与网络的实际连接层。数据链路层下面就是实体线路（比如以太网络、光纤网络等）。数据链路层有以太网、令牌环网等标准，负责网卡设备的驱动、帧同步（从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机可以在不同的数据链路层的网络之间（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间）转发数据帧，由于不同数据链路层的帧格式不同，交换机要将进来的数据报拆掉报头重新封装之后再转发。</li></ul><p>不同的协议层对数据报有不同的称谓，在传输层叫作段（Segment），在网络层叫作数据报（Datagram），在数据链路层叫作帧（Frame）。数据封装成帧后发送到传输介质上，到达目的主机后，每层协议再剥掉相应的报头，最后将应用层数据交给应用程序处理。</p><p><img src="/TCP-IP-fiveLayers/2.png" alt="数据封装"></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>以浏览某个网页为例，看一下浏览网页的过程中 TCP&#x2F;IP 各层做了哪些工作。</p><p>发送方：</p><ol><li>打开浏览器，输入网址 <a href="http://www.xxx.com/">www.xxx.com</a> 按回车键来访问网页，其实就是访问 Web 服务器上的网页，在应用层采用的协议是 HTTP，浏览器将网址等信息组成 HTTP 数据，并将数据传送给传输层。</li><li>传输层在数据前面加上 TCP 报头，并标记端口为 80（Web 服务器的默认端口），将这个数据段给了网络层。</li><li>网络层在这个数据段前面加上自己机器的 IP 和目的 IP，这时该段被称为 IP 数据报，然后将这个 IP 数据报给了数据链路层。</li><li>数据链路层先在 IP 数据报前面加上自己机器的 MAC 地址以及目的 MAC 地址，加上 MAC 地址的数据称为帧，然后通过物理网卡把这个帧以比特流的方式发送到网络上。</li></ol><p>互联网上有路由器，它会读取比特流中的 IP 地址进行路由操作，到达正确的网段后，这个网段的交换机读取比特流中的 MAC 地址，从而找到要接收的对应机器。</p><p>接收方：</p><ol><li>数据链路层用网卡接收到了比特流，读取比特流中的帧，将帧中的 MAC 地址去掉，就成了 IP 数据报，传递给网络层。</li><li>网络层接收下层传来的 IP 数据报，将 IP 从包的前面拿掉，取出带有 TCP 的数据（数据段）交给传输层。</li><li>传输层拿到了这个数据段，看到 TCP 标记的端口是 80，说明应用层协议是 HTTP，之后将 TCP 头去掉并将数据交给应用层，告诉应用层对方请求的是 HTTP 数据。</li><li>应用层得知发送方请求的是 HTTP 数据，因此调用 Web 服务器程序把 <a href="http://www.xxx.com/">www.xxx.com</a> 的首页文件发送回去。</li></ol><p>如果两台计算机位于不同的网段中，那么数据从一台计算机到另一台计算机传输的过程中要经过一个或多个路由器，如下图所示。</p><p><img src="/TCP-IP-fiveLayers/3.png" alt="例子"></p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Hyperledger Fabric: A Distributed Operating System for Permissioned Blockchains</title>
    <link href="/Hyperledger-Fabric/"/>
    <url>/Hyperledger-Fabric/</url>
    
    <content type="html"><![CDATA[<p>Fabric 是一个模块化、可扩展的开源系统，用于部署和操作<strong>许可区块链</strong>，也是 Linux 基金会托管的超级账本项目之一。它支持<strong>模块化共识协议</strong>，允许系统根据特定用例和信任模型进行定制。在某些流行的部署配置中， Fabric 实现了每秒 3500 TPS，具有 sub-second 的延迟，可扩展到 100 多个对等节点。</p><span id="more"></span><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>区块链相较于传统的 SMR（state-machine replication，状态机复制）存在拜占庭式缺陷：</p><ol><li>不只一个，而是许多分布式应用程序同时运行</li><li>应用程序可以由任何人动态部署</li><li>应用程序代码是不可信的，甚至可能是恶意的</li></ol><p>许多现有区块链实施的是 <strong>order-execute</strong> 结构，它的局限性在于要求所有对等方执行每个交易，并且所有交易都是确定的。</p><ul><li>共识在平台内是硬编码的，这与没有一刀切的（BFT）共识协议的公认理解相矛盾</li><li>交易验证的信任模型由共识协议决定，不能适应智能合约的要求</li><li>智能合约必须以固定的、非标准的或特定领域的语言编写，这会阻碍广泛的应用，并可能导致编程错误</li><li>所有对等方对所有交易的顺序执行限制了性能，需要采取复杂的措施防止来自不可信合约的拒绝服务攻击</li><li>交易必须是确定性的，这在编程上很难保证</li><li>每个智能合约都在所有对等方上运行，这与保密性不符，并禁止向一部分对等方传播合约代码和状态</li></ul><p>Fabric 可以克服这些局限性。</p><p>Fabric 使用 <strong>execute-order-validate</strong> 结构，将交易分为三个步骤，可以在系统中不同的实体中运行：</p><ol><li><strong>executing</strong> 交易并检查其正确性，从而 <strong>endorsing</strong> 交易（对应于其他区块链中的“交易验证”）</li><li>通过共识协议进行 <strong>ordering</strong>，而不考虑交易语义</li><li>根据特定于应用程序的信任假设进行 <strong>validation</strong>，这防止了并发导致的竞争</li></ol><p>该设计结合了两种复制方案：<strong>passive</strong>（当一个事务提交时，领导者副本将该事务的数据变更广播给所有跟随者副本，跟随者按照顺序应用这些变更）和 <strong>active</strong>（每个副本独立执行相同的确定性交易代码）</p><ul><li>首先 Fabric 使用 passive replication，每个事务仅由一个对等方的子集执行和背书，这允许<strong>并行执行</strong>。背书政策规定了哪些对等方或其中多少对等方需要为智能合约提供担保。</li><li>其次 Fabric 结合 active replication，每个对等方单独执行的确定性验证步骤中，交易对账本状态的影响只有在总顺序达成共识后才能写入。状态更新的排序被委托给一个模块化组件以实现共识，该组件是无状态的，并且在逻辑上与执行交易和维护账本的对等方分离。由于共识是模块化的，因此它的实现可以根据特定部署的信任假设进行调整。</li></ul><p>Fabric 中包含了以下组件：</p><ul><li><strong>ordering service</strong> 以原子方式向对等方广播状态更新，并就事务顺序建立共识。</li><li><strong>membership service provider</strong> 负责将对等方与加密身份相关联。它保持了 Fabric 的许可性。</li><li>可选的 <strong>peer-to-peer gossip service</strong> 通过 ordering service 向所有对等节点传播块的输出。</li><li>Fabric 中的 <strong>smart contracts</strong> 在容器环境中运行以隔离。它们可以用标准编程语言编写，但不能直接访问帐本状态。</li><li>每个对等方在本地维护 <strong>ledger</strong>，并将其作为键值存储中最新状态的快照。</li></ul><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2 BACKGROUND"></a>2 BACKGROUND</h2><h3 id="2-1-Order-Execute-Architecture-for-Blockchains"><a href="#2-1-Order-Execute-Architecture-for-Blockchains" class="headerlink" title="2.1 Order-Execute Architecture for Blockchains"></a>2.1 Order-Execute Architecture for Blockchains</h3><p><img src="/Hyperledger-Fabric/1.png" alt="Order-execute architecture in replicated services."></p><h3 id="2-2-Limitations-of-Order-Execute"><a href="#2-2-Limitations-of-Order-Execute" class="headerlink" title="2.2 Limitations of Order-Execute"></a>2.2 Limitations of Order-Execute</h3><ul><li>Sequential execution：成为性能瓶颈</li><li>Non-deterministic code：导致分叉</li><li>Confidentiality of execution：保密开销巨大</li></ul><h3 id="2-3-Further-Limitations-of-Existing-Architectures"><a href="#2-3-Further-Limitations-of-Existing-Architectures" class="headerlink" title="2.3 Further Limitations of Existing Architectures"></a>2.3 Further Limitations of Existing Architectures</h3><ul><li>Fixed trust model：应用程序级别的信任不应固定为协议级别的信任</li><li>Hard-coded consensus：应使用不同共识协议适应不同的环境</li></ul><h3 id="2-4-Experience-with-Order-Execute-Blockchain"><a href="#2-4-Experience-with-Order-Execute-Blockchain" class="headerlink" title="2.4 Experience with Order-Execute Blockchain"></a>2.4 Experience with Order-Execute Blockchain</h3><p>区块链系统的关键属性，即一致性、安全性和性能，不得依赖于其用户的知识和善意，因为区块链在不受信任的环境中运行。</p><h2 id="3-ARCHITECTURE"><a href="#3-ARCHITECTURE" class="headerlink" title="3 ARCHITECTURE"></a>3 ARCHITECTURE</h2><h3 id="3-1-Fabric-Overview"><a href="#3-1-Fabric-Overview" class="headerlink" title="3.1 Fabric Overview"></a>3.1 Fabric Overview</h3><p><img src="/Hyperledger-Fabric/2.png" alt="Execute-order-validate architecture of Fabric"></p><p>Fabric 的分布式应用程序由两部分组成：</p><ul><li><strong>chaincode</strong>：一个智能合约，在执行阶段运行，可以使用通用编程语言（Golang、Java等）</li><li><strong>endorsement policy</strong>：一个背书策略，在验证阶段被评估，只有特定的管理员可以修改</li></ul><p>客户端向背书策略指定的节点发送交易，然后由节点执行每个交易，并记录其输出，这一步骤也称为 endorsement。执行完成后，交易进入排序阶段，通过可插拔的共识协议对这些交易排序（并非交易输入，而是对交易输出排序，并结合状态依赖），然后向所有节点广播。然后，每个节点根据背书策略验证背书交易的状态变化，并验证交易的一致性。在此期间 Fabric 使用了主动和被动复制的混合策略。</p><p>三个角色：</p><p><img src="/Hyperledger-Fabric/3.png" alt="MSP: membership service provider"></p><ul><li><strong>Clients</strong>：提交、广播交易</li><li><strong>Peers</strong>：执行（并不执行所有交易，只有被指定为 endorsers 时执行）、验证交易，维护区块链</li><li><strong>Orderers</strong> (OSN，Ordering Service Nodes)：给所有交易排序</li></ul><p>交易流：</p><p><img src="/Hyperledger-Fabric/4.png" alt="Fabric high level transaction flow"></p><h3 id="3-2-Execution-Phase"><a href="#3-2-Execution-Phase" class="headerlink" title="3.2 Execution Phase"></a>3.2 Execution Phase</h3><p>在执行阶段，客户端签署交易提案（proposal）并发送给背书策略中指定的背书人。背书人根据本地区块链状态模拟执行提案，此时的执行结果并不会与其他节点同步，也不会写入账本中。链码创建的状态仅限于该链码，不能由其他链码直接访问。给定适当的许可，链码可以调用另一个链码来访问同一通道内的状态。</p><p>每一个背书人在模拟执行的时候会生成一个 writeset（模拟执行产生的状态更新，即修改的键和值）和一个 readset（表示提案模拟执行的版本依赖，即模拟过程中所有的键和它的版本号）。模拟结束后，背书人对一条名为背书（endorsement）的消息进行加密签名，该消息包含 writeset 和 readset（以及交易 ID、背书人 ID 和背书人签名等元数据），并在提案响应中将其发送回客户端。客户端收集这些 endorsement 直到满足背书策略的要求，同时所有背书人要产生相同的执行结果（即，相同的 writeset 和 readset）。然后客户端会将交易发送给排序服务。</p><p>这种在排序之前的执行可以容忍非确定性链码，执行结果的不一致会导致它无法收集足够数量的背书。同时背书人若怀疑受到 DoS 攻击，可以根据本地协议单方面终止执行交易。</p><h3 id="3-3-Ordering-Phase"><a href="#3-3-Ordering-Phase" class="headerlink" title="3.3 Ordering Phase"></a>3.3 Ordering Phase</h3><p>当客户端收集到足够的背书时，它组装一个交易并将其提交给排序服务，该交易包含链码操作和参数、交易元数据和一组背书。排序阶段为每个通道（channel，不同的区块链系统可以连接至同一个排序服务，每一个区块链系统都叫做一个通道）提交的交易分别进行总排序。此外，排序服务将多个交易打包成块，并输出块的哈希序列。</p><p>排序服务的节点不维护区块链的状态，也不验证或执行交易。这种架构是 Fabric 的一个关键的特征，使 Fabric 成为第一个将共识与执行和验证完全分离的区块链系统。同时不需要排序服务来防止交易重复，因为在验证阶段节点在读写检查中过滤了重复的交易。</p><h3 id="3-4-Validation-Phase"><a href="#3-4-Validation-Phase" class="headerlink" title="3.4 Validation Phase"></a>3.4 Validation Phase</h3><p>区块直接由排序服务或者 gossip 发送给节点，然后进入验证阶段：</p><ol><li>对区块内的所有交易并行进行背书策略评估。评估是所谓的验证系统链码（VSCC）的任务，如果背书不满足，则交易被标记为无效，其影响将被忽略。</li><li>对区块内的所有交易按序进行读写冲突检查。对于每一笔交易，它都会将 readset 字段中的键与节点本地存储的账本当前状态的键进行比较，并确保它们相同。如果版本不匹配，则转换标记为无效，并忽略其影响。</li><li>最后对账本进行更新，区块被附加到本地存储的账本，区块链状态被更新。当将块添加到账本时，前两个步骤中的有效性检查结果也将以位掩码的形式持久化，该位掩码表示块内有效的交易。这有助于以后恢复状态。此外，所有状态更新都是将写集中的键值对写入本地状态。</li></ol><p>Fabric 帐本中也包括无效的交易，因为排序服务在形成区块时与链码状态无关。在某些需要在后续审计期间跟踪无效交易的用例中需要此功能，与以太坊（只包含有效交易）等其他区块链形成对比。</p><h3 id="3-5-Trust-and-Fault-Model"><a href="#3-5-Trust-and-Fault-Model" class="headerlink" title="3.5 Trust and Fault Model"></a>3.5 Trust and Fault Model</h3><p>所有客户端都是潜在的恶意或者拜占庭节点；节点被分为不同的组织，组织内节点相互信任，但不信任组织外的某一节点；排序服务认为所有客户端和节点都可能是拜占庭的。</p><p>Fabric 将应用程序的信任模型与共识的信任模型解耦。分布式应用程序可以定义自己的信任假设，这些假设通过背书策略传递，并且独立于由排序服务实现的共识假设。</p><h2 id="4-FABRIC-COMPONENTS"><a href="#4-FABRIC-COMPONENTS" class="headerlink" title="4 FABRIC COMPONENTS"></a>4 FABRIC COMPONENTS</h2><p>Fabric 是用 Go 语言编写的，并采用 gRPC 框架在节点之间传输信息。</p><p><img src="/Hyperledger-Fabric/5.png" alt="Fabric 节点的组成"></p><h3 id="4-1-Membership-Service"><a href="#4-1-Membership-Service" class="headerlink" title="4.1 Membership Service"></a>4.1 Membership Service</h3><p>The membership service provider (MSP) 维护着系统内所有节点（clients，peers，OSNs）的身份信息，并负责颁发用来认证和授权的凭据。因为 Fabric 是许可链，节点之间的所有交互都是通过经过身份验证的消息进行的，通常会使用数字签名。用于节点密钥管理和注册的工具也是 MSP 的一部分。</p><h3 id="4-2-Ordering-Service"><a href="#4-2-Ordering-Service" class="headerlink" title="4.2 Ordering Service"></a>4.2 Ordering Service</h3><p>排序服务管理着多个通道，对于每个通道它提供以下服务：</p><ol><li>用于交易排序的原子广播（Atomic broadcast），实现 broadcast 和 deliver 调用</li><li>在成员广播配置更新交易时，修改通道的配置</li><li>访问控制（可选），限制向指定客户端和节点广播交易和接收区块</li></ol><p>OSN 直接将新接收的交易注入原子广播（例如 Kafka 代理，OSNs 作为节点和 Kafka 之间的代理）。OSNs 将从原子广播接收的交易批处理并形成块。一旦满足以下三个条件之一，即成块：</p><ol><li>该块包含指定的最大交易数</li><li>块已达到最大大小（字节）</li><li>从接收到新块的第一个交易起已经过去了一段时间</li></ol><p><strong>该批处理过程是确定性的，因此在所有节点上产生相同的块</strong>（这是由原子广播的特性决定的）。前两点会形成相同区块很容易理解，为了满足第三个条件，节点在收到区块第一个交易时会启动一个计时器，如果到达设定时间还没有成块，节点就会在通道中广播一条 time-to-cut 交易表明要成块的区块号。</p><p>排序服务的实现：</p><ul><li><p><strong>Raft</strong>（推荐）</p><p>  作为 v1.4.1 的新特性，Raft 是一种基于 etcd 中 Raft 协议实现的崩溃容错（Crash Fault Tolerant，CFT）排序服务。Raft 遵循“领导者跟随者”模型，这个模型中，在每个通道上选举领导者节点，其决策被跟随者复制。Raft 排序服务会比基于 Kafka 的排序服务更容易设置和管理，它的设计允许不同的组织为分布式排序服务贡献节点。</p></li><li><p><strong>Kafka</strong>（在 v2.0 中被弃用）</p><p>  和基于 Raft 的排序类似，Apache Kafka 是一个 CFT 的实现，它使用“领导者和跟随者”节点配置。Kafka 利用一个 ZooKeeper 进行管理。基于 Kafka 的排序服务从 Fabric v1.0 开始就可以使用，但许多用户可能会发现管理 Kafka 集群的额外管理开销令人生畏或不受欢迎。</p></li><li><p><strong>Solo</strong>（在 v2.0 中被弃用）</p><p>  排序服务的 Solo 实现仅仅是为了测试，并且只包含了一个单一的排序节点。它已经被弃用了，可能会在将来的版本中被完全移除。</p></li></ul><h3 id="4-3-Peer-Gossip"><a href="#4-3-Peer-Gossip" class="headerlink" title="4.3 Peer Gossip"></a>4.3 Peer Gossip</h3><p>将执行、排序和验证阶段分离的一个优点是它们可以独立扩展。由于大多数共识算法（在 CFT 和 BFT 模型中）都有带宽限制，排序服务的吞吐量会受到其节点的网络容量的限制。研究表明共识性能不能通过增加节点数量来增强，这样做吞吐量反而会降低。然而，由于排序和验证是分离的，因此在排序阶段之后，可以将执行结果广播给所有节点进行验证；以及向新加入的节点和长期断开连接的节点的状态同步，这正是 gossip 部分的目标。</p><p>Gossip 的通信层基于 gRPC，并利用 TLS 相互认证，其组件维护系统中最新的在线成员视图。</p><p>Fabric gossip 使用两个阶段进行信息传播：</p><ul><li>push：每个节点从成员视图中随机选取一组活跃的邻居节点，并向它们转发消息</li><li>pull：每个节点周期性地访问一组随机选择的节点并请求丢失的消息。</li></ul><p>为了减少从排序节点向网络发送块的负载，该协议还选择一个领导节点从排序服务中 pull 区块并发起 gossip。</p><h3 id="4-4-Ledger"><a href="#4-4-Ledger" class="headerlink" title="4.4 Ledger"></a>4.4 Ledger</h3><p>Ledger 由一个 block store 和一个 peer transaction manager 组成：</p><ul><li>Ledger block store：由一组仅添加的文件组成，同时维护一些索引，用于随机访问块或块中的交易。</li><li>Peer transaction manager（PTM）：在版本化的键值储存中维护最新状态（key，val，ver）</li></ul><p>对于交易验证，PTM 顺序验证块中的所有交易。这将检查一个交易是否与之前的任何交易冲突（当前块或更早的块中）。对于 readset 中的任何键，如果 readset 中记录的版本与最新状态下的版本不同（假设所有之前的有效交易都已提交），则 PTM 将该交易标记为无效。PTM 会计算并保存一个 savepoint，表示成功应用的最大块数，用于崩溃中恢复时从持久化块中恢复索引和最新状态。</p><h3 id="4-5-Chaincode-Execution"><a href="#4-5-Chaincode-Execution" class="headerlink" title="4.5 Chaincode Execution"></a>4.5 Chaincode Execution</h3><p>链码的执行环境与节点低耦合，它支持用于添加新的链码编程语言的插件，目前支持 Go、Java 和 Node。</p><p>每个用户级或应用程序链码都在 Docker 容器的一个单独进程中运行，这将链码彼此隔离，并与节点隔离。而系统链码直接在节点进程中运行，可以实现 Fabric 所需的特定功能，并且可以在用户链码之间的隔离过于严格的情况下使用。</p><h3 id="4-6-Configuration-and-System-Chaincodes"><a href="#4-6-Configuration-and-System-Chaincodes" class="headerlink" title="4.6 Configuration and System Chaincodes"></a>4.6 Configuration and System Chaincodes</h3><p>Fabric 可以通过 channel configuration 和 system chaincodes 来定制结构。每个通道形成一个逻辑区块链，通道的配置保存在特殊 configuration blocks（genesis block）的元数据中。通道配置包括：</p><ol><li>确定参与节点的 MSPs</li><li>OSNs 的网络地址</li><li>实现共识和排序服务的共享配置（例如 batch size 和 timeouts）</li><li>制定访问排序服务的操作（broadcast 和 deliver）</li><li>制定修改通道配置的规则</li></ol><h2 id="5-EVALUATION"><a href="#5-EVALUATION" class="headerlink" title="5 EVALUATION"></a>5 EVALUATION</h2><p>此节介绍一些初步的性能数据和影响因素。引入 Fabric Coin（Fabcoin，UTXO cryptocurrencies）用于性能测试和比较。</p><h2 id="6-APPLICATIONS-AND-USE-CASES"><a href="#6-APPLICATIONS-AND-USE-CASES" class="headerlink" title="6 APPLICATIONS AND USE CASES"></a>6 APPLICATIONS AND USE CASES</h2><p>略</p><h2 id="7-RELATED-WORK"><a href="#7-RELATED-WORK" class="headerlink" title="7 RELATED WORK"></a>7 RELATED WORK</h2><p>略</p><h2 id="8-CONCLUSION"><a href="#8-CONCLUSION" class="headerlink" title="8 CONCLUSION"></a>8 CONCLUSION</h2><p>未来的改进工作：</p><ol><li>探索基准测试和优化实现性能</li><li>可扩展到大型部署</li><li>一致性保证和更通用的数据模型</li><li>通过不同的共识协议保证其他弹性</li><li>通过加密技术对交易和账本数据进行隐私和保密</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(1)：Go 语言</title>
    <link href="/ByteDance-1/"/>
    <url>/ByteDance-1/</url>
    
    <content type="html"><![CDATA[<p>关于 Go 语言的基础和进阶教程，示例代码在我的 Github 上：<br><a href="https://github.com/qanlyma/go-by-example">基础代码</a>，<a href="https://github.com/qanlyma/go-project-example/tree/V0">进阶代码</a></p><span id="more"></span><h2 id="1-Go-语言基础"><a href="#1-Go-语言基础" class="headerlink" title="1 Go 语言基础"></a>1 Go 语言基础</h2><h3 id="1-1-Go-语言简介"><a href="#1-1-Go-语言简介" class="headerlink" title="1.1 Go 语言简介"></a>1.1 Go 语言简介</h3><ul><li>高性能、高并发</li><li>语法简单、学习曲线平滑</li><li>丰富的标准库</li><li>完善的工具链</li><li>静态链接</li><li>快速编译</li><li>跨平台</li><li>垃圾回收</li></ul><h3 id="1-2-基础语法"><a href="#1-2-基础语法" class="headerlink" title="1.2 基础语法"></a>1.2 基础语法</h3><p>Golang 的安装和基础使用，可以参考<a href="https://www.runoob.com/go/go-tutorial.html">菜鸟教程</a>。</p><p>补充几点：</p><ol><li>错误处理</li></ol><p><img src="/ByteDance-1/1.png" alt="错误处理"></p><ol start="2"><li>字符串操作</li></ol><p><img src="/ByteDance-1/2.png" alt="字符串操作"></p><ol start="3"><li>字符串格式化</li></ol><p><img src="/ByteDance-1/3.png" alt="字符串格式化"></p><ol start="4"><li>JSON 处理</li></ol><p>对于一个已有的结构体，只要保证每个字段的第一个字母是大写（公开字段），就可以用 JSON.Marshal 序列化成一个 JSON 字符串。</p><p><img src="/ByteDance-1/4.png" alt="JSON 处理"></p><ol start="5"><li>时间处理</li></ol><p><img src="/ByteDance-1/5.png" alt="时间处理"></p><ol start="6"><li>数字解析</li></ol><p><img src="/ByteDance-1/6.png" alt="数字解析"></p><ol start="7"><li>进程信息</li></ol><p><img src="/ByteDance-1/7.png" alt="进程信息"></p><h3 id="1-3-项目实战"><a href="#1-3-项目实战" class="headerlink" title="1.3 项目实战"></a>1.3 项目实战</h3><ol><li><p>猜谜游戏</p><ul><li>生成随机数：用时间戳来初始化随机数种子</li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    maxNum := <span class="hljs-number">100</span> <br>    rand.Seed(time.Now().UnixNano()) <br>    secretNumber := rand.Intn(maxNum) <br>    fmt.Println(<span class="hljs-string">&quot;The secret number is &quot;</span>, secretNumber)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读取用户输入</li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    maxNum := <span class="hljs-number">100</span><br>    rand.Seed(time.Now().UnixNano())<br>    secretNumber := rand.Intn(maxNum)<br>    fmt.Println(<span class="hljs-string">&quot;The secret number is &quot;</span>, secretNumber)<br><br>    fmt.Println(<span class="hljs-string">&quot;Please input your guess&quot;</span>)<br>    reader := bufio.NewReader(os.Stdin)<br><br>    <span class="hljs-comment">//读取一行输入</span><br>    input, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;An error occured while reading input. Please try again&quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">//去掉换行符</span><br>    input = strings.Trim(input, <span class="hljs-string">&quot;\r\n&quot;</span>)<br>    <span class="hljs-comment">//转换为数字</span><br>    guess, err := strconv.Atoi(input)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Invalid input. Please enter an integer value&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;You guess is&quot;</span>, guess)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>逻辑判断 + 游戏循环：略</li></ul></li></ol><hr><ol start="2"><li>命令行词典</li></ol><hr><ol start="3"><li>SOCKS5 代理</li></ol><h2 id="2-Go-语言进阶"><a href="#2-Go-语言进阶" class="headerlink" title="2 Go 语言进阶"></a>2 Go 语言进阶</h2><h3 id="2-1-Goroutine"><a href="#2-1-Goroutine" class="headerlink" title="2.1 Goroutine"></a>2.1 Goroutine</h3><ul><li><strong>线程</strong>：程序执行的最小单元，是由寄存器集合和堆栈组成，线程是进程中的一个实体，可共享同一进程中所拥有的全部资源。</li><li><strong>协程</strong>：Goroutine 是一种比线程更加轻量级的存在。一个进程可以有多个线程，一个线程可以有多个协程。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello goroutine : &quot;</span> + fmt.Sprint(i))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloGoRoutine</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br>hello(j)<br>&#125;(i)<br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-CSP（Communicating-Sequential-Processes）"><a href="#2-2-CSP（Communicating-Sequential-Processes）" class="headerlink" title="2.2 CSP（Communicating Sequential Processes）"></a>2.2 CSP（Communicating Sequential Processes）</h3><p>提倡<strong>通过通信共享内存</strong>而不是通过共享内存而实现通信。</p><p><img src="/ByteDance-1/8.png" alt="CSP"></p><h3 id="2-3-Channel"><a href="#2-3-Channel" class="headerlink" title="2.3 Channel"></a>2.3 Channel</h3><ul><li>无缓冲通道：<code>make(chan int)</code></li><li>有缓冲通道：<code>make(chan int, 2)</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CalSquare</span><span class="hljs-params">()</span></span> &#123;<br>src := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>dest := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(src)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>src &lt;- i<br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(dest)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> src &#123;<br>dest &lt;- i * i<br>&#125;<br>&#125;()<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dest &#123;<br><span class="hljs-comment">//复杂操作</span><br><span class="hljs-built_in">println</span>(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Lock-并发安全"><a href="#2-4-Lock-并发安全" class="headerlink" title="2.4 Lock 并发安全"></a>2.4 Lock 并发安全</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x    <span class="hljs-type">int64</span><br>lock sync.Mutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithLock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;<br>lock.Lock()<br>x += <span class="hljs-number">1</span><br>lock.Unlock()<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithoutLock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;<br>x += <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">()</span></span> &#123;<br>x = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> addWithoutLock()<br>&#125;<br>time.Sleep(time.Second)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WithoutLock:&quot;</span>, x)<br>x = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> addWithLock()<br>&#125;<br>time.Sleep(time.Second)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WithLock:&quot;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-WaitGroup"><a href="#2-5-WaitGroup" class="headerlink" title="2.5 WaitGroup"></a>2.5 WaitGroup</h3><p>计数器：开启协程 +1；执行结束 -1；主协程阻塞直到计数器为 0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ManyGoWait</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">5</span>)                   <span class="hljs-comment">// 计数器 +5</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()     <span class="hljs-comment">// 计数器 -1</span><br>hello(j)<br>&#125;(i)<br>&#125;<br>wg.Wait()                   <span class="hljs-comment">// 阻塞直到计数器为 0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-依赖管理"><a href="#3-依赖管理" class="headerlink" title="3 依赖管理"></a>3 依赖管理</h2><ul><li><strong>GOPATH</strong>：设置环境变量，项目代码依赖 src 下的代码。无法实现 package 的多版本控制。</li><li><strong>Go Vendor</strong>：项目目录下增加 vendor 文件存放依赖包副本。同一项目无法依赖一个 package 的两个不同版本。</li><li><strong>Go Module</strong>：通过 go.mod 文件管理依赖包版本</li></ul><p>依赖管理三要素：</p><ol><li>配置文件，描述依赖：go.mod</li><li>中心仓库管理依赖库：Proxy</li><li>本地工具：go get&#x2F;mod</li></ol><p><img src="/ByteDance-1/9.png" alt="Proxy"></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><h3 id="4-1-单元测试"><a href="#4-1-单元测试" class="headerlink" title="4.1 单元测试"></a>4.1 单元测试</h3><ul><li>测试文件以 <code>_test.go</code> 结尾</li><li>函数 <code>func TestXxx(t *testing.T)</code></li><li>初始化逻辑放入 <code>TestMain(m *testing.M)</code></li></ul><p>print.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloTom</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tom&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>print_test.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHelloTom</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>output := HelloTom()<br>expectOutput := <span class="hljs-string">&quot;Tom&quot;</span><br>assert.Equal(t, expectOutput, output)<br>&#125;<br></code></pre></td></tr></table></figure><p>覆盖率：<code>go test Xxx_test.go Xxx.go --cover</code></p><h3 id="4-2-Mock"><a href="#4-2-Mock" class="headerlink" title="4.2 Mock"></a>4.2 Mock</h3><p>为一个函数&#x2F;方法打桩，不再依赖本地文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFirstLine</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>open, err := os.Open(<span class="hljs-string">&quot;log&quot;</span>)<br><span class="hljs-keyword">defer</span> open.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>scanner := bufio.NewScanner(open)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br><span class="hljs-keyword">return</span> scanner.Text()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ProcessFirstLine</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>line := ReadFirstLine()<br>destLine := strings.ReplaceAll(line, <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;00&quot;</span>)<br><span class="hljs-keyword">return</span> destLine<br>&#125;<br></code></pre></td></tr></table></figure><p>以上函数读取 log 文件的第一行并将 “11” 替换为 “00”，依赖于本地的文件，而使用 Mock 可以避免依赖。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProcessFirstLine</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>firstLine := ProcessFirstLine()<br>assert.Equal(t, <span class="hljs-string">&quot;line00&quot;</span>, firstLine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProcessFirstLineWithMock</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>monkey.Patch(ReadFirstLine, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;line110&quot;</span><br>&#125;)<br><span class="hljs-keyword">defer</span> monkey.Unpatch(ReadFirstLine)<br>line := ProcessFirstLine()<br>assert.Equal(t, <span class="hljs-string">&quot;line000&quot;</span>, line)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-Benchmark"><a href="#4-3-Benchmark" class="headerlink" title="4.3 Benchmark"></a>4.3 Benchmark</h3><p>基准测试 <code>go test -bench .</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitServerIndex</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ServerIndex[i] = i+<span class="hljs-number">100</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Select</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> ServerIndex[rand.Intn(<span class="hljs-number">10</span>)]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSelect</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>InitServerIndex()<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Select()<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSelectParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>InitServerIndex()<br>b.ResetTimer()<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br>Select()<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-1/10.png" alt="result"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 区块链扩容调研</title>
    <link href="/Blockchain-scalability/"/>
    <url>/Blockchain-scalability/</url>
    
    <content type="html"><![CDATA[<p>一篇关于区块链 Layer 1 和 Layer 2 的扩容调研报告。</p><span id="more"></span><h2 id="一、区块链扩容"><a href="#一、区块链扩容" class="headerlink" title="一、区块链扩容"></a>一、区块链扩容</h2><h3 id="1-1-为什么需要扩容"><a href="#1-1-为什么需要扩容" class="headerlink" title="1.1 为什么需要扩容"></a>1.1 为什么需要扩容</h3><p>在比特币诞生之初，创始人中本聪并没有特意限制区块的大小，区块最大可以达到 32MB。当时，平均每个区块大小为 1-2KB，有人认为区块链上限过高容易造成计算资源的浪费，还容易发生 DDOS 攻击（分布式拒绝服务攻击）。因此，为了保证比特币系统的安全和稳定，中本聪决定临时将区块大小限制在 1MB。</p><p>随着越来越多的人关注和使用比特币，链上最高时有上万笔交易积压，很多用户为了尽快让自己的交易被打包，不得不增加手续费，有时候比特币转账交易费高达几十美元。网络拥堵时，一个比特币交易甚至需要花费好几天才能被打包，同理也使得以太坊上的gas费用居高不下。比特币和以太坊作为区块链 1.0 和 2.0 的代表，比特币每秒大约只能处理 7 个交易，性能只有 7TPS；以太坊每秒只能处理 15 个交易，性能只有 15TPS。而作为中心化的代表，淘宝在 17 年双十一超过了 200,000TPS，可见区块链的 TPS 跟中心化应用还有很大的差距。</p><p>与很多分布式系统一样，区块链技术中也有一个“不可能三角形”，比特币和以太坊在最早诞生时最关注的是去中心化和安全，牺牲了可扩展性。后来，市场上不断有一些新的区块链项目牺牲掉去中心化或者安全性来为可扩展性保驾护航，试图部署出一个吞吐量较高的区块链网络。迄今为止，还没有人找到去中心化、可扩展性和安全性三全其美的策略，打造出一个充分运行、基于加密货币的大规模区块链网络。但是，如果想把区块链的应用拓展到虚拟货币投资之外，必须得有支持其吞吐量扩容的解决方案。</p><p><img src="/Blockchain-scalability/1.png" alt="不可能三角"></p><h3 id="1-2-如何扩容"><a href="#1-2-如何扩容" class="headerlink" title="1.2 如何扩容"></a>1.2 如何扩容</h3><p>所谓的扩容方案是指“为了改善区块链交易速度使其达到规模化所提出的解决方案”，各层所提出的扩容方案，其最终目的都是为了解决区块链交易速度的问题。</p><p><img src="/Blockchain-scalability/2.png" alt="区块链分层"></p><p>目前主要可以分为链上（Layer 1）和链下（Layer 2）的扩容方案。链上扩容是指为了提高区块链的吞吐量而对其进行的任何直接修改，比如比特币修改共识机制来改变区块结构或直接增加区块大小，而以太坊的策略则是改变网络结构进行分片，不同的分片并行处理不同的交易，增加整体吞吐量。而链下扩容是指在不改变公链本身规则的前提下，将数据计算过程等信息移到链下进行，而主链仅记录结果，比如比特币的闪电网络，以太坊的侧链，状态通道和 Rollup 等。下文将对具体方案进行详细介绍。</p><p><img src="/Blockchain-scalability/3.png" alt="扩容方案"></p><h2 id="二、Layer-1-扩容"><a href="#二、Layer-1-扩容" class="headerlink" title="二、Layer 1 扩容"></a>二、Layer 1 扩容</h2><h3 id="2-1-扩块和隔离见证"><a href="#2-1-扩块和隔离见证" class="headerlink" title="2.1 扩块和隔离见证"></a>2.1 扩块和隔离见证</h3><p>想让一个区块打包更多的交易，最直观的有两种解决办法：一是增加区块大小；二是缩小交易数据的尺寸。这就分别产生了扩块和隔离见证两个扩容方案，当然这两个方案也可以一起使用，可是不论选择何种方案都避免不了区块链的分叉。</p><p>比特币社区中提及比较多的是 2MB 区块，一部分人希望通过硬分叉直接把区块大小限制从 1M 改到 2M，提升单个区块内的交易数，每秒打包的交易就会增加，从而提升 TPS。可是扩块有一些弊端：</p><ul><li>(1) 大区块传播速度变慢，验证速度变慢，导致频繁的重组，双花攻击概率提高；</li><li>(2) 大区块导致储存量大幅度增加，成本提高，节点可能减少，趋向中心化从而影响安全。</li></ul><p>比特币社区有一部分人不接受硬分叉，坚持使用隔离见证（Segwit）方案去优化主链结构，并且结合闪电网络等二层网络结构来改善支付体验。隔离见证的原理是压缩每笔交易的大小，从而增加每个区块可以记录的交易数量。此方案将比特币交易数据分为交易信息和签名信息，对于普通用户来说他们只关心每个账户有多少资产，不需要验证信息，隔离见证就是把区块内的数字签名信息拿出去，让每个区块可以承载更多交易，从而达到扩容的目的。可是这样做的扩容能力有限，依然难以满足大量转账的需求。</p><p>两种方案的支持者方争论不休，随着加密货币市场迎来了前所未有的关注度，比特币价格连创新高，这也让比特币的交易更加拥堵，最终在 2017 年 8 月 1 日导致了比特币历史上第一次重大硬分叉的出现，比特币区块大小由 1M 扩大到 8M，同时也诞生出新币种 BCH（比特币现金）。</p><h3 id="2-2-分片"><a href="#2-2-分片" class="headerlink" title="2.2 分片"></a>2.2 分片</h3><p>分片技术（sharding）来自中心化数据库技术，将大型数据库数据进行切分，并分布在特点的服务器中，以提高数据库性能。如果将分片技术运用到区块链中，就相当于将区块链网络里的所有待处理任务进行分解，全网的节点也进行分组，每一组同时处理一个分解后的任务，这样就从原先单一节点处理全网的所有任务变成了多组节点同时处理，如此以来，自然就能大大提升这条链的处理效率。但是分片技术的问题也是显而易见的：分片多用于以太坊网络中，那么跨片区智能合约交易如何处理？片区如何划分？各片区如何同步？</p><p><img src="/Blockchain-scalability/4.png" alt="分片"></p><p>分片技术根据不同的分片机制可以划分为三种：</p><ul><li>网络分片（network sharding）</li><li>交易分片（transaction sharding）</li><li>状态分片（state sharding）</li></ul><h4 id="2-2-1-网络分片"><a href="#2-2-1-网络分片" class="headerlink" title="2.2.1 网络分片"></a>2.2.1 网络分片</h4><p>网络分片是最基础的一种分片方式，就是将整个区块链网络划分成多个子网络（也就是一个分片），网络中的所有分片并行处理网络中不同的交易。</p><p>但是这个方案会使网络的安全性和去中心化性会下降，比如原来 A 想要在某交易中作恶，因为共识机制的原因，A 需要控制全网的大部分节点或算力才行，但现在因为分片把节点分散到一个个小的区域中，A 只用控制包含这个交易的小区域的大部分节点算力就行。</p><p>幸好分片技术另外一个非常重要的机制就是随机分配，在区块链领域建立随机性的方式主要是利用可验证随机函数（VRF, Verifiable Random Function）。利用随机性，网络可以随机抽取节点形成分片。这样一种随机抽样的方式可以防止恶意节点过度填充单个分片，这样想要作恶的人，就很难知道一个小区域中的节点都有谁，作恶成本会大幅提高，从而分片技术能在保证安全与去中心化的同时，解决效率与可扩展性问题。</p><h4 id="2-2-2-交易分片"><a href="#2-2-2-交易分片" class="headerlink" title="2.2.2 交易分片"></a>2.2.2 交易分片</h4><p>网络分片是其他所有分片的基础，交易分片的前提是先进行网路分片。交易分片主要涉及的问题是哪些交易应该按照特定的属性被分配到哪些分片当中。</p><ul><li>基于 UTXO 的账本系统。在基于 UTXO 的账本系统中，一笔交易可能由多个输入和多个输出构成，我们没有办法按照地址进行交易分片来有效地避免双花问题。比较直观的交易分片方式是按照交易的 hash 值最后几位进行分片。但是这样也有可能导致双花交易，所以不同分片之间不得不进行通信。</li><li>基于账户系统。在基于账户系统中，一笔交易只有一个输入，而输入的地址将被记录在账户系统中。该账户系统在交易分片的每个分片中是全局可见的，因此我们只需要将交易按照发送者的地址进行分片，即可保证同一个账户发出的多笔交易将被在同一个分片当中被处理，这样该分片可以有效的检测双花交易而不需要复杂的跨分片的通信。</li></ul><h4 id="2-2-3-状态分片"><a href="#2-2-3-状态分片" class="headerlink" title="2.2.3 状态分片"></a>2.2.3 状态分片</h4><p>状态分片的关键是将整个存储区分开，让不同的分片存储不同的部分，每个节点只负责托管自己的分片数据，而不是存储完整的区块链状态。状态分片可以减少状态的冗余存储，使得整个区块链网络具有存储的可扩展性。</p><p>在账户型系统中，状态分片是按照账户的地址进行分片的，并且一个特定的分片只会保留一部分状态，而不像是交易分片那样每个节点都保存整个网络中的所有状态。这导致可能需要进行频繁的跨分片通信和状态交换。跨分片通信可能又会降低状态分片的性能。</p><p>在状态分片的情况下，重新分配节点是非常困难的。由于每个分片只保留了网络状态的一部分，所以在一次重新调整网络的过程中，必须要防止调整过大而导致在同步完成前可能会出现的整个系统失效的问题。为了防止系统的中断，必须对网络进行逐步调整，以确保每个分片在所有节点被清空前仍有足够多的旧节点。而新节点在加入分片之前，需要等待同步完该分片中的状态信息之后才可以正式加入分片并提供算力。</p><h3 id="2-3-Casper"><a href="#2-3-Casper" class="headerlink" title="2.3 Casper"></a>2.3 Casper</h3><p>比特币和以太坊当前都采用工作量证明（PoW）共识机制，这是个低效的系统，因为它消耗会大量的电力和能量。而且这个机制可以通过购买更快更强的 ASIC 设备比其他人拥有更高的概率挖到区块，这导致比特币并没有像它希望的那样分散化。如果采取其他共识机制（PoS），改变区块形成的规则，提高系统效率即可增加每秒处理交易。Csaper 就是以太坊选择实行的 PoS 协议，值得一提的是，Casper 并非专为扩容而设计，但它会对以太坊网络容量产生积极影响。</p><p><img src="/Blockchain-scalability/5.png" alt="PoS"></p><p>在介绍 Casper 之前我们首先要了解无利害关系问题（Nothing at stake），这一问题是由于 PoS 机制不会消耗节点的算力，所以在共识系统出现分叉情况时，出块节点可以在“不受任何损失”的前提下，同时为多条链出块，从而有可能获得“所有收益”。Casper 是一种基于保证金的经济激励共识协议。协议中的节点作为“锁定保证金的验证人”，必须先缴纳保证金才可以参与出块和共识形成。Casper 共识协议通过对这些保证金的直接控制来约束验证人的行为。具体来说就是，如果一个验证人作出了任何 Casper 认为“无效”的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消，从而解决了无利害关系问题。</p><p>从扩容的角度来说，修改后，可以从根本上改变区块形成的规则，往有利于交易量增加的方向修改。但是无论如何改变，共识算法仍然是分布式算法，需要多个节点达成一致，处理的上限是一台机器处理能力的上限。并且共识机制是加密货币的核心，涉及加密货币的整体逻辑，需要全盘考虑对旧区块的承接、安全性、后续发展等问题，还需要做大量的技术尝试。</p><h2 id="三、Layer-2-扩容"><a href="#三、Layer-2-扩容" class="headerlink" title="三、Layer 2 扩容"></a>三、Layer 2 扩容</h2><p>第二层扩容也称链下扩容，是不改变公链基础协议的一种应用层上的扩展方案，即不改动区块链本身的规则（区块大小，共识机制等）。由 Layer 2 协议，区块链事务的“状态生成”可以独立于 Layer 1 之外进行。换句话说 Layer 2 扩容方案是尽可能在不牺牲区块链网络安全性的情况下实现高吞吐量的状态生成。</p><h3 id="3-1-侧链协议"><a href="#3-1-侧链协议" class="headerlink" title="3.1 侧链协议"></a>3.1 侧链协议</h3><p>侧链是与公链并排运行并与之通信的独立区块链，它使用另一个代币与公链代币相互锚定，从而创建了双向桥。侧链是完全独立的，具有自己的共识机制和安全性保证。通过这种解决方案，可以实现数字资产从第一个区块链到第二个区块链的转移，又可以在稍后的时间点从第二个区块链安全返回到第一个区块链。其中第一个区块链通常被称为主区块链或者主链，每二个区块链则被称为侧链。</p><p><img src="/Blockchain-scalability/7.png" alt="侧链协议"></p><p>由于没有第一层设计的负担，侧链可以支持超出其基础层能力的某些特性，包括但不限于可扩展性和互操作性，同时不依赖于第一层的存储，可以建设多条侧链提供非常高的 TPS。而且得益于其独立性，如果侧链上出现了代码漏洞和大量资金被盗等问题，主链的安全性和稳定性都不会受到影响。缺点是它不是一个无信任的环境，用户需要将资金托管转移到侧链，从侧链取回资产时的安全性问题需要被考虑，侧链目前不那么成熟，去中心化也更差。</p><h3 id="3-2-状态通道"><a href="#3-2-状态通道" class="headerlink" title="3.2 状态通道"></a>3.2 状态通道</h3><p>状态通道是固定一组参与者（通常是两名参与者）之间的协议，用以实现安全的链下交易，其中支付通道专门用来支付。支付通道协议具体情况是两名参与者各自通过链上交易在链上锁定保证金，一旦锁定完成，参与者双方即可互相发送形式为轮次、金额、签名的状态更新来实现转账，无需与主链进行交互，只要双方的余额都还为正值即可。一旦参与者中有一方想要停止使用支付通道，可以执行退出操作：将最后的状态更新提交至主链，结算下来的余额会退给发起支付通道的两方。主链可以通过核实签名和最后结余来验证状态更新的有效性，从而防止参与者使用无效状态来退出支付通道。</p><p>该方案会用到一个协议叫 HTLC（Hashed Timelock Contract），其实就是限时转账。A 给 B 转账，A 先冻结一笔钱，并提供一个哈希值，如果在一定时间内 B 能提出一个字符串匹配，则这笔钱转给 B。过了一定时间没有<br>提交这个字符串的话，A 就可以拿回这笔钱。</p><p><img src="/Blockchain-scalability/12.png" alt="HTLC"></p><p>状态通道带来的优点是交互延迟在毫秒级别，是唯一能够逼近当今互联网用户体验的区块链扩容技术；交易手续费极低，从根本上比所有其他 Layer 2 技术的交易手续费低；水平扩展性强，加节点就能增加总系统容量，TPS 无上限，且互相之间不隔离，不需要有跨分片或者跨链之类的复杂操作。但它的退出模式存在一个问题，即主链无法验证支付通道是否提交了全部交易，也就是说，在提交了状态更新之后是否不再出现新的状态更新。而且它的使用场景较为局限：长期合作关系的双方的支付，偶发性交易难以适用，并且通道不能用于将资金在链外发送给尚未参与的人。此外，状态通道只能在两个参与者之间开设。闪电网络就是比特币使用状态通道的例子。</p><p><img src="/Blockchain-scalability/6.png" alt="闪电网络"></p><p>状态通道相较于侧链协议有更强的隐私性，并且有即时的最终确定性。但是状态通道需要所有参与者 100% 的在线，在侧链中，你就不需要一直在线。</p><h3 id="3-3-Plasma"><a href="#3-3-Plasma" class="headerlink" title="3.3 Plasma"></a>3.3 Plasma</h3><p>Plasma 由 Vitalik 和 Joseph Poon 在 2017 年共同提出，Plasma 是一种链下交易的技术，从一个新的方向实现了状态通道。它允许创建附加在以太坊主链上的子链，这些子链反过来可以产生他们自己的子链。其结果就是，我们可以在子链级别执行许多复杂的操作，运行拥有数千名用户的整个应用程序，并且只需与以太坊主链进行尽可能少的交互。子链可以更快地操作，且交易费用更低，因为它的操作不需要在整个以太坊区块链存留副本。</p><p>区别于状态通道，Plasma 中能够运行智能合约，如果说状态通道是对交易吞吐量的扩容，那么它是对计算能力的扩容。Plasma 是将计算和数据存储都迁移到 Layer 2 进行，由 Layer 2 的执行者周期性地向主链递交 Merkle 根形式的状态承诺。如果执行者递交无效的状态，用户可以向主链上的智能合约提供错误性证明（fraud proof），一旦确认执行者出现欺诈行为，智能合约会没收他的保证金。</p><p><img src="/Blockchain-scalability/8.png" alt="Plasma"></p><p>虽然说我们可以通过错误性证明，使得提供无效承诺的执行者在主链上遭到惩罚，但 Plasma 的数据并没有提交到链上，如果 Plasma 的执行者拒绝在主链上公开数据，那么用户则无法提供错误性证明，所以 Plasma 面临的最大问题是交易数据可用性。针对这个问题，Plasma 衍生出一些相应的方案，如延长资产从 Layer 2 退出的时间：当出现作恶行为，就能允许资产从 Plasma 链转移回主链。所以在 Plasma 上退出一笔资产的周期会长达一周左右，如果在争议期间没有人提交欺诈证明，那么资产才可以安全退出到主链。相比较而言，普通的侧链就没有这个安全特性。</p><h3 id="3-4-Rollup"><a href="#3-4-Rollup" class="headerlink" title="3.4 Rollup"></a>3.4 Rollup</h3><p>之前介绍的几种链下扩容方案虽然诞生时间很早，但是发展的却比较缓慢，其背后的原因归根结底是数据的可用性（Data Availability）问题。无论是状态通道还是 Plasma 侧链，完整的交易记录和见证数据都只保存在链下，出现争端时如果参与者没有及时提供正确的交易和见证数据，交易的安全性就无法保证。这时一种名为 Rollup 的方案被提了出来。</p><p><img src="/Blockchain-scalability/9.png" alt="Rollup"></p><p>Rollup 可以被认为是一种压缩技术，多笔交易可以压缩在一起（几千笔交易可以被打包到一个 Rollup 区块中），既能减少交易数据规模，又能降低交易验证负担，因此使得以太坊区块链能处理更多交易。它将所有 Layer 2 上的交易数据快照发送到主链上某个智能合约内，用主链上的单个合约来保管所有的资金，通过在主链上为每一笔交易公开一些数据，让任何人都能通过观察区块链上的 calldata（交易输入数据）来获得 Layer 2 的所有数据。Rollup 区块的状态是由用户以及链下运营者来维护的，因此不会占用主链的存储空间。所有交易的收据都存储在以太坊区块链上，这就提升了 Layer 2 交易的安全性。具体的实现方案目前主要分为 ZK Rollup 和 Optimistic Rollup 两种。</p><h4 id="3-4-1-ZK-Rollup"><a href="#3-4-1-ZK-Rollup" class="headerlink" title="3.4.1 ZK Rollup"></a>3.4.1 ZK Rollup</h4><p>ZK Rollup 是靠着在主链完成零知识证明，链上无需包含签名数据，因为零知识证明就足以证明交易的有效与否，交易有效性就立刻确认，也即数据可用性放在链上，所以 ZK Rollup 对数据存储方面带来了一定程度上的扩展性提升。它的缺点是验证链路的构造没有一个通用的解决方案，所以目前没有很好的办法做到很广义的虚拟机逻辑，简单来说，ZK Rollup 必须对每一个用例定制，程序正确性的验证相对复杂，二层打包节点负担重，成本高，计算零知识证明所需时间长，用户延迟的体验角度仍然比较差，目前只适合简单的转账。</p><h4 id="3-4-2-Optimistic-Rollup"><a href="#3-4-2-Optimistic-Rollup" class="headerlink" title="3.4.2 Optimistic Rollup"></a>3.4.2 Optimistic Rollup</h4><p>ZK Rollup 包含一个 SNARK 零知识证明，合约用它来验证在老的用户状态上施加这批交易，但是生成 SNARK 的成本非常高，所以 Optimistic Rollup 采用了欺诈证明来验证交易有效性。Optimistic Rollup 的理念是由 John Adler 首先构想出来的，它保留了 calldata，主链可以获得所有 Layer 2 的数据，但那些刷新 Layer 2 状态的交易不会在链上被验证，只让主链存储一系列的历史状态根，添加了一个新的状态的一段时间后才将新状态最终敲定，也就是数据可用性放在链下。采用欺诈证明，对提交无效状态的执行者进行惩罚。其链下 OVM 虚拟机可以支持任意智能合约逻辑的实现，与以太坊 EVM 虚拟机搭配使用，开发者就可以用 Solidity 来写代码，实现 DApp 和智能合约之间的无缝互操作性。它的缺点是安全问题，只有使用一到两周的欺诈证明挑战期才足够安全。在挑战期过去以前，没有交易能被认为是确定的。</p><h4 id="3-4-3-比较"><a href="#3-4-3-比较" class="headerlink" title="3.4.3 比较"></a>3.4.3 比较</h4><p><img src="/Blockchain-scalability/10.png" alt="比较"></p><ul><li><ol><li>Optimistic rollup 和 ZK rollup 的主要区别在于采用了不同的数据证明方式。Optimistic rollup 使用欺诈证明：子链上的交易结果并不直接生成相关证明接入主链，子链仅向主链报告结果。如果有人发现结果错误，他们可以向链上发布一个证明，证明处理计算错误。合约将验证证明，并对结果进行更正。ZK rollup 使用零知识证明: 子链将自身交易采用 ZK-SNARK 技术生成加密证明，证明状态根是执行子链上交易的正确结果。无论计算量有多大，证明都可以在链上快速验证。</li></ol></li><li><ol start="2"><li>Optimistic Rollup 基于加密经济学有效性博弈，只有过了挑战期才能确认交易生效。ZK Rollup 的延迟相对较小，如果一个打包区块中有 1000 笔交易，在普通的服务器上大概需要 20 分钟就可以构造出一个证明。</li></ol></li><li><ol start="3"><li>通用性方面，Optimistic Rollup 明显好于 ZK Rollup，当然它的设计目标就是支持任意智能合约。而 ZK Rollup 目前仅适用于支付之类的特定交易，对于通用智能合约，由于创建零知识证明的成本非常高，部署起来困难较大。</li></ol></li></ul><p>短期看来 Optimistic Rollup 由于较好的通用性会受到开发者的青睐；但从长期来看，随着零知识证明虚拟机的演进，ZK Rollup 会在通用性上不断提高。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>状态通道有一些独特的性质，让它在扩容领域有着独特的地位，它的诸多属性在很多应用中都非常重要。比如游戏、IoT 设备网络、去中心的互联网服务提供商等。Plasma 和状态通道相比，Plasma 中能够运行智能合约，而状态通道则不被允许。分片系统要比 Plasma 链更不易于遭受拒绝服务攻击，分片链提供的防御也更易于普及。但 Plasma 链可以被迭代，新的设计可以更快地被实现，因为每条 Plasma 链都可以在无需与该生态系统中的其他链进行协调的情况下单独地进行部署，而且由单个运营商运行的 Plasma 链还可以提供比分片系统更多的隐私保护。而在分片系统中，所有的数据都是公开的。</p><p>相比于 Plasma 和 ZK Rollup，Optimistic Rollup 做了一些权衡，所以带来的扩展性提升幅度最小，但 Optimistic Rollup 不依赖于什么过于前沿的技术或悬而未决的问题，所以实际推广中 Optimistic Rollup 更好落地。而 ZK Rollup 可以解决 Optimistic Rollup 上的几个根本问题，消除了令人厌恶的尾部风险（通过复杂但可行的攻击方法从 Optimistic Rollup 中盗取资金），将提取资金的时间从几周缩减到几分钟，支持快速的交易确认和退出，并且默认保护隐私。对于需要提高流动性的项目而言，资本运作效率 ZK Rollup 高于 Optimistic Rollup。</p><p>不同的扩容技术有它不同的优缺点，导致适应不同的应用场景，未来不同的扩容技术之间也会是相互合作关系，某一场景下同时使用多种扩容技术。以太坊基金会在今年1月25日宣布淘汰“以太坊 2.0”的说法，改称为“共识层”，设计人员在其中加入当下的一些先进技术，如分片技术、Casper 协议等等。相信伴随着以太坊的全面升级，其 TPS 必将有很大改善，但其中技术上的一些问题还有待大家共同攻坚克难。</p><p><img src="/Blockchain-scalability/11.png" alt="Eth 2.0"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 登链社区. 突破不可能三角. <a href="https://learnblockchain.cn/column/12">https://learnblockchain.cn/column/12</a>.<br>[2] Croman, K., et al. On Scaling Decentralized Blockchains (A Position Paper).<br>[3] Gangwal A, Gangavalli H R, Thirupathi A. A Survey of Layer-Two Blockchain Protocols.</p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Go」 各种类型相互转换</title>
    <link href="/Go-typeTransfer/"/>
    <url>/Go-typeTransfer/</url>
    
    <content type="html"><![CDATA[<p>在做 leetcode 和自己写 go 程序的时候，总是会遇到一些类型转换的问题，在这里总结一下。</p><span id="more"></span><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul><li><p>int → int64: <code>i := int64(int)</code></p></li><li><p>int → uint64: <code>ui := uint64(int)</code></p></li><li><p>int → float: <code>f := float64(int)</code></p></li><li><p>int → string: <code>str := strconv.Itoa(int)</code></p></li><li><p>int64 → string: <code>str := strconv.FormatInt(int64, 10)</code></p></li></ul><h2 id="uint"><a href="#uint" class="headerlink" title="uint"></a>uint</h2><ul><li>uint64 → string: <code>str := strconv.FormatUint(uint64, 10)</code></li></ul><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><ul><li><p>float → int: <code>i := int(float)</code></p></li><li><p>float → string: <code>str := strconv.FormatFloat(float64, &#39;E&#39;, -1, 64)</code></p></li></ul><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li><p>string → int: <code>i, err := strconv.Atoi(string)</code></p></li><li><p>string →float: <code>f, err := strconv.ParseFloat(string, 64)</code></p></li><li><p>string → bool: <code>b, err := strconv.ParseBool(&quot;true&quot;)</code></p></li><li><p>string → []byte: <code>b := []byte(string)</code></p></li></ul><h2 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h2><p>[]byte → string: <code>str := string([]byte)</code></p><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><ul><li>bool → string: <code>string := strconv.FormatBool(true)</code></li></ul><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ul><li><p>interface→int: <code>interface.(int64)</code></p></li><li><p>interface→string: <code>interface.(string)</code></p></li><li><p>interface→float: <code>interface.(float64)</code></p></li><li><p>interface→bool: <code>interface.(bool)</code></p></li></ul><h2 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> a := <span class="hljs-number">1</span><br> fmt.Println(<span class="hljs-string">&quot;a type by reflect: &quot;</span>, reflect.TypeOf(a))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Linux 使用教程</title>
    <link href="/Tutorial-Linux/"/>
    <url>/Tutorial-Linux/</url>
    
    <content type="html"><![CDATA[<p>Linux，全称 GNU&#x2F;Linux，是一种免费使用和自由传播的类 UNIX 操作系统。作为研究生，我一开始学习 Linux 的源动力自然也是任职要求上的那一条：熟悉 Linux 环境。那么 Linux 系统到底好在哪里？</p><span id="more"></span><h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><p>很多公司包括我们自己的实验室服务器都是用的 Linux 系统，其优点概括而言就是开源、免费、生态好、安全性高。</p><p>首先 Linux 系统稳定性极高且不容易染毒（从来没有听说过要装什么杀毒软件或者需要清理内存，而且我们实验室的服务器永远都不会关机），它自带的命令功能十分强大（比如你可以用简单的几行命令就搞定软件的下载安装整个步骤），还拥有开放的源代码和高度的可定制性。其次，Linux 系统的远程管理非常方便。通过 ssh 或者 telnet 的连接，在很小的带宽环境下也能很轻松实现远程操作。就如服务器摆在眼前一样的感觉。这是 windows 系统无法比拟的。</p><h2 id="Linux-发行版本"><a href="#Linux-发行版本" class="headerlink" title="Linux 发行版本"></a>Linux 发行版本</h2><p><img src="/Tutorial-Linux/1.png" alt="发行版说简单点就是将 Linux 内核与应用软件做一个打包。"></p><p>关于不同版本的安装网上教程很多，就不在此赘述。</p><h2 id="Linux-启动过程"><a href="#Linux-启动过程" class="headerlink" title="Linux 启动过程"></a>Linux 启动过程</h2><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p><ul><li><p><strong>内核的引导</strong><br>  当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</p></li><li><p><strong>运行 init</strong><br>  init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。</p></li><li><p><strong>系统初始化</strong><br>  在init的配置文件中有这么一行： <code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了 &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而 rc.sysinit 是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p></li><li><p><strong>建立终端</strong><br>  rc 执行完毕后，返回 init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。 init 接下来会打开终端，以便用户登录系统。</p></li><li><p><strong>用户登录系统</strong><br>  一般来说，用户的登录方式有三种：<br>  （1）命令行登录<br>  （2）ssh登录<br>  （3）图形界面登录</p></li></ul><p><img src="/Tutorial-Linux/2.png" alt="启动过程"></p><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><p><img src="/Tutorial-Linux/3.jpg" alt="树状目录结构"></p><blockquote><p>&#x2F;</p></blockquote><blockquote><blockquote><p>&#x2F;bin：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;boot：<br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;dev ：<br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;etc：<br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;home：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lib：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;media：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;opt：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;proc：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sbin：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;selinux：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;srv：<br> 该目录存放一些服务启动之后需要提取的数据。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sys：<br>该文件系统是内核设备树的一个直观反映。<br>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;tmp：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;usr：<br>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;bin：<br>系统用户使用的应用程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;src：<br>内核源代码默认的放置目录。</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>&#x2F;var：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p></blockquote></blockquote><h2 id="Linux-权限管理"><a href="#Linux-权限管理" class="headerlink" title="Linux 权限管理"></a>Linux 权限管理</h2><p>初学 Linux 我遇到过很多次没有权限而产生的报错，之前的解决办法一直是使用 <code>su</code> 命令给自己 root 权限，注意此时命令行的 <code>$</code> 会变成 <code>#</code> 。Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown (change owner) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组</p><p><img src="/Tutorial-Linux/4.jpg" alt="文件属性及权限"></p><p>第一位表示文件的属性： <code>d</code> 是目录， <code>-</code> 是文件， <code>l</code> 表示链接文档等等。</p><p>接下来的字符中，以三个为一组，且均为 <code>rwx</code> 的三个参数的组合。</p><ul><li><code>r</code> 代表可读(read)</li><li><code>w</code> 代表可写(write)</li><li><code>x</code> 代表可执行(execute)</li><li><code>-</code> 代表没有此权限</li></ul><p>而这三组也分别对应属主（该文件的所有者）权限、属组权限、其他用户权限。</p><p>我们可以使用 chmod 更改文件上述的 9 个属性，将三组权限看作三个二进制数，开启设 1 关闭设 0<br>如可以使用我们常见的 <code>chmod 777 文件名</code> 来开启所有权限。</p><h2 id="Linux-用户管理"><a href="#Linux-用户管理" class="headerlink" title="Linux 用户管理"></a>Linux 用户管理</h2><p>此节是关于 Linux 的用户以及用户组管理的，我目前用的不多，请参考<a href="https://www.runoob.com/linux/linux-user-manage.html">菜鸟教程</a>。</p><h2 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h2><p>同上，请参考<a href="https://www.runoob.com/linux/linux-filesystem.html">菜鸟教程</a></p><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><ul><li>ls （list files）: 列出目录及文件名</li><li>cd （change directory）：切换目录</li><li>pwd （print work directory）：显示目前的目录</li><li>mkdir （make directory）：创建一个新的目录</li><li>rmdir （remove directory）：删除一个空的目录</li><li>cp （copy file）: 复制文件或目录</li><li>rm （remove）: 删除文件或目录</li><li>mv （move file）: 移动文件与目录，或修改文件与目录的名称</li><li>cat （concatenate）：显示文件内容或是将多个文件合并成一个文件</li><li>yum（Yellow dog Updater, Modified）：一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器</li><li>apt（Advanced Packaging Tool）：一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器</li></ul><p>你可以使用 man [命令] 来查看各个命令的使用文档，如： <code>man cp</code> 。此外文本编辑器 <a href="https://www.runoob.com/linux/linux-vim.html">vim</a> 也是很值得学习一下的。</p><p>我们通常会在命令后添加参数来执行更多功能，具体参数和使用方法请参考<a href="https://blog.csdn.net/weixin_66975803/article/details/123693997">这篇笔记</a>。</p><h2 id="Linux-更多命令"><a href="#Linux-更多命令" class="headerlink" title="Linux 更多命令"></a>Linux 更多命令</h2><ul><li><p><a href="https://blog.csdn.net/weixin_45004203/article/details/125885958">进程相关</a>：<code>top</code>, <code>ps</code>, <code>pidof</code>, <code>kill</code>, <code>killall</code>, <code>pkill</code></p></li><li><p>端口相关：<code>lsof -i:port</code>, <code>netstat -nltp | grep port</code></p></li></ul><h2 id="Bash-Shell"><a href="#Bash-Shell" class="headerlink" title="Bash Shell"></a>Bash Shell</h2><p>我之前一直知道 Shell 这个东西，但是对于它的认识很模糊，关于 Shell 有如下两条解释：</p><ul><li><p>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，不启动 Shell 的话，用户就没办法使用 Linux。</p></li><li><p>Shell 是一个命令语言解释器, 在操作系统的最外层, 是用户（用户程序）与操作系统（Linux）内核的接口程序，用户输入的每个命令都由 Shell 先翻译再传给 Linux 内核, 并将处理后的结果输出至屏幕。</p></li></ul><p>常用的 Shell 功能有两种形式外在形式： GUI 和 cmdline。</p><p>Shell 的使用方法有两种：1. 直接输入命令； 2. 使用 .sh 脚本。 对于脚本语法感兴趣请学习 <a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a>。</p><p>Bash (GUN Bourne-Again Shell）是许多 Linux 发行版本默认的 Shell。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我在这篇文章里面列出了我自己认为 Linux 中比较重要的内容，学习它的办法唯有多用，逐渐感受它的强大与可靠，你一定会理解为什么它会受到那么多公司的青睐。 Linux 上手可能会比 Windows 要困难一点，尤其是在没有装图形化界面的服务器上，各位同学不必害怕，熟能生巧，习惯以后真的非常好用。相信不久后你也可以在简历里面加上一句 “熟悉 Linux 开发环境” 了。</p><p>附两个我常用的在本地与服务器传文件的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmd">// 文件从远程系统上用户的主目录复制到本地当前目录<br>scp username@ip_address:/home/username/filename .<br><br>// 将本地文件复制到远程系统上用户名的主目录<br>scp filename username@ip_address:/home/username<br><br>// 也可以复制目录<br>scp -r source_dir username@ip_address:/home/username/target_dir<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Markdown 使用教程</title>
    <link href="/Tutorial-Markdown/"/>
    <url>/Tutorial-Markdown/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，在 2004 年由 John Gruber 创建。它允许人们使用易读易写的纯文本格式编写文档。<br>本文介绍使用 Markdown 编写博客时常用的标记符号供后续使用时参考。</p><span id="more"></span><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>使用 # 号标记，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><h2 id="Markdown-格式"><a href="#Markdown-格式" class="headerlink" title="Markdown 格式"></a>Markdown 格式</h2><p>可以实现的格式： <em>斜体文本</em> ， <strong>粗体文本</strong> ， <em><strong>粗斜体文本</strong></em> ， <del>删除线</del> ， <u>带下划线文本</u></p><p>分割线</p><hr><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套<br>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p><code>Println()</code> 函数输出 “Hello, world!” :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>欢迎访问我的 <a href="https://github.com/qanlyma">Github 仓库</a>: <a href="https://github.com/qanlyma">https://github.com/qanlyma</a></p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p><img src="/Tutorial-Markdown/love.jpg" alt="我最喜欢的彩虹六号"></p><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><table><thead><tr><th align="left">左  对  齐</th><th align="right">右  对  齐</th><th align="center">居  中  对  齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="Markdown-高级"><a href="#Markdown-高级" class="headerlink" title="Markdown 高级"></a>Markdown 高级</h2><h3 id="支持部分-HTML-元素"><a href="#支持部分-HTML-元素" class="headerlink" title="支持部分 HTML 元素"></a>支持部分 HTML 元素</h3><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><strong>文本加粗</strong><br>** 正常显示星号 **</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Hexo 基础命令</title>
    <link href="/Tutorial-Hexo/"/>
    <url>/Tutorial-Hexo/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建新网站"><a href="#创建新网站" class="headerlink" title="创建新网站"></a>创建新网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><h3 id="清除缓存文件"><a href="#清除缓存文件" class="headerlink" title="清除缓存文件"></a>清除缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h3 id="在本地启动-hexo"><a href="#在本地启动-hexo" class="headerlink" title="在本地启动 hexo"></a>在本地启动 hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="更换电脑"><a href="#更换电脑" class="headerlink" title="更换电脑"></a>更换电脑</h3><p>hexo 目录下的文件和 github 上的文件是不同的，public 文件夹的文件通过 <code>hexo d</code> 上传到 github，其他的文件则留在本地目录下。</p><ol><li>将本地文件传入 github 新建分支 <code>hexo</code>，并设为默认。</li><li>在新电脑上克隆新分支到本地，切换到 <code>username.github.io</code> 目录，执行 <code>npm install</code> 安装依赖（node_modules文件）。</li><li>安装 hexo： <code>npm install -g hexo-cli</code>，安装必要的插件，例如需要部署到 gitPage： <code>npm install hexo-deployer-git --save</code>。</li><li>更改后依次执行 <code>git add .</code>、<code>git commit -m &quot;...&quot;</code>、<code>git push</code>。</li><li>更新前使用 <code>git pull</code>。</li></ol><p><strong>.md 文件建议使用 UTF-8，其他格式可能会乱码。</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
