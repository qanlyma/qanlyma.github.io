<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「学」 Practice</title>
    <link href="/Note-practice1/"/>
    <url>/Note-practice1/</url>
    
    <content type="html"><![CDATA[<p>生成平台后端项目。</p><span id="more"></span><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1 整体架构"></a>1 整体架构</h2><p>系统保持前后端分离 + Spring Boot 单体技术架构，包括前端控制台，业务后台，算法服务之间采用 HTTP 协议通信，JSON 数据格式进行交互。</p><ul><li>前端采用 Vue.js 2.x、Bootstrap 和 ElementUI 开发，并使用 Nginx 作为反向代理服务器。</li><li>后端基于 Spring Boot 实现，包括公共模块和业务模块，并使用 RocketMQ 进行异步任务处理。</li><li>文件存储使用 MinIO 服务器，专门存储图片和视频数据。</li><li>数据库使用 MySQL 存储关系型数据，Redis 用于缓存和非关系型数据存储。</li><li>业务后台与算法服务通过 HTTP 协议交互，可根据性能需求增加相应服务器。</li></ul><p><img src="/Note-practice1/1.png"></p><h2 id="2-项目目录"><a href="#2-项目目录" class="headerlink" title="2 项目目录"></a>2 项目目录</h2><p><img src="/Note-practice1/2.png"></p><h3 id="2-1-aspect"><a href="#2-1-aspect" class="headerlink" title="2.1 aspect"></a>2.1 aspect</h3><p>这个包用于存放切面类，这些类主要用于实现 AOP（面向切面编程）的功能，如事务管理、日志记录等。在此项目中用于记录每一次从前端收到的请求和返回值并输出到 log。</p><h3 id="2-2-config"><a href="#2-2-config" class="headerlink" title="2.2 config"></a>2.2 config</h3><p>配置相关的类或文件通常放在这个包中，比如 Spring 框架的配置类、数据库连接配置、安全配置等：</p><ul><li>配置和初始化 MinIO 客户端，使得应用程序能够与 MinIO 服务器进行交互。</li><li>Mybatis 的分页功能，MyBatis是一个流行的持久层框架，它简化了 Java 应用程序与关系数据库之间的交互。MyBatis 的主要功能是将 Java 对象与 SQL 数据库中的记录进行映射，从而简化数据库操作。</li><li>WebSocket 的配置，WebSocket是一种全双工通信协议，允许在客户端和服务器之间建立持久连接，从而实现实时数据传输。</li><li>Swagger 的配置，使其能够自动生成 API 文档。</li></ul><h3 id="2-3-controller"><a href="#2-3-controller" class="headerlink" title="2.3 controller"></a>2.3 controller</h3><p>该包下的类通常是控制器，负责接收前端请求并调用服务层处理业务逻辑，然后返回响应给前端。这是 MVC 架构中的 C（Controller）部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/generateApi&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;生成任务服务&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenerateTaskController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> GenerateTaskService generateTaskService;<br>    <span class="hljs-meta">@PostMapping(&quot;/taskGenerate&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;任务生成&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseData <span class="hljs-title function_">taskGenerate</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> GenerateParams params)</span> &#123;<br>        <span class="hljs-keyword">return</span> generateTaskService.taskGenerate(params);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@RestController</code> 注解，说明它是一个 RESTful 风格的控制器，所有的方法返回值都会直接写入 HTTP 响应体中，而不是返回视图名。</li><li><code>@RequestParam</code> 可以将请求参数绑定到你的控制器方法参数上。当客户端向服务器发送请求时，如果 URL 中包含请求参数，那么 Spring MVC 会尝试匹配并将这些请求参数绑定到使用 <code>@RequestParam</code> 注解的方法参数上。</li><li>这个控制器类中定义了一个 POST 请求的处理方法 <code>taskGenerate</code>，该方法接收一个 <code>GenerateParams</code> 类型的请求体参数，并调用 <code>GenerateTaskService</code> 的 <code>taskGenerate</code> 方法处理这个请求，最后返回处理结果。</li><li>POST 请求的 URL 路径是 <code>/generateApi/taskGenerate</code>，这是由类级别的 <code>@RequestMapping(&quot;/generateApi&quot;)</code> 和方法级别的 <code>@PostMapping(&quot;/taskGenerate&quot;)</code> 两个注解共同决定的。</li><li>方法参数前的 <code>@Valid</code> 注解表示启用对这个参数的数据校验，<code>@RequestBody</code> 注解表示这个参数的值来自于请求体。</li></ul><h3 id="2-4-entity"><a href="#2-4-entity" class="headerlink" title="2.4 entity"></a>2.4 entity</h3><p>实体类通常存放于此包中，每一个类代表了数据库中的一个表结构，用于 ORM（对象关系映射）操作。</p><ul><li><code>@Data</code> 是 Lombok 的注解，会自动为类的所有属性生成 getter 和 setter 方法，以及 equals、canEqual、hashCode、toString 方法。</li><li><code>@TableName</code> 是 MyBatis-Plus 的注解，表示这个类对应的数据库表名。</li><li>类中的每个属性都对应着数据表中的一个字段，用 <code>@TableField</code> 注解标注。<code>value</code> 属性表示对应的数据库字段名。</li></ul><h3 id="2-5-enums"><a href="#2-5-enums" class="headerlink" title="2.5 enums"></a>2.5 enums</h3><p>枚举类型放在这个包里，用于定义一些固定值的集合，例如状态码、操作类型等。</p><h3 id="2-6-handle"><a href="#2-6-handle" class="headerlink" title="2.6 handle"></a>2.6 handle</h3><p>用于处理特定任务的类，例如异常处理、数据转换等。</p><h3 id="2-7-listener"><a href="#2-7-listener" class="headerlink" title="2.7 listener"></a>2.7 listener</h3><p>监听器类位于此包内，它们可以监听应用程序中的某些事件，如上下文初始化&#x2F;销毁、请求开始&#x2F;结束等，并执行相应的操作。此包中定义了一个名为 TaskListener 的类，它是一个 RocketMQ 的消息监听器，当有新的消息到达时，RocketMQ 会自动调用这个类的 <code>onMessage</code> 方法。</p><ul><li><code>@Component</code>：这个类被标记为 Spring 的组件，所以 Spring 会自动创建这个类的实例，并且可以通过自动装配将这个实例注入到其他的 Bean 中。</li><li><code>@RocketMQMessageListener</code>：这是 RocketMQ 提供的注解，用于标记一个类为 RocketMQ 的消息监听器。<code>consumerGroup</code> 属性表示消费者组名，<code>topic</code> 属性表示要监听的主题，<code>consumeMode</code> 属性表示消费模式，这里设置为 <code>ConsumeMode.ORDERLY</code> 表示顺序消费。</li><li>在 <code>onMessage</code> 方法中，首先从 Redis 中获取一个锁，然后将接收到的消息转换为 <code>TaskCenterListener</code> 对象。然后根据任务的状态进行不同的处理。如果任务的状态是 0（排队中），则将状态改为 1（进行中）。如果任务的状态是 3 或 4（已结束），则不做任何处理并直接返回。</li><li>根据任务的算法类型调用不同的服务进行处理。如果在处理过程中发生了异常，那么将任务的状态设置为 4（异常结束），并记录异常信息。</li><li>在处理完任务后，会将任务的状态更新到 Redis 中，并更新任务的数据库记录。最后，释放 Redis 中的锁，表示任务处理结束。</li></ul><h3 id="2-8-mapper"><a href="#2-8-mapper" class="headerlink" title="2.8 mapper"></a>2.8 mapper</h3><p>MyBatis 的 Mapper 接口是用于定义数据库操作的方法的接口。每个方法对应数据库中的一种操作，如查询、插入、更新和删除等。这些方法的名称和参数需要与 Mapper XML 文件中的 SQL 语句对应。</p><h3 id="2-9-model"><a href="#2-9-model" class="headerlink" title="2.9 model"></a>2.9 model</h3><ul><li><p><strong>DTO</strong>：数据传输对象，用于在不同层之间传递数据，特别是在跨越网络边界时。通常用于将数据库查询结果或业务逻辑处理结果封装成一个对象，以便在不同层之间传输。</p></li><li><p><strong>Params</strong>：参数对象，用于封装控制器层接收到的请求参数。Params 对象通常用于将多个请求参数组合成一个对象，便于方法调用和参数校验。</p></li><li><p><strong>VO</strong>：值对象，用于封装业务逻辑层处理后的数据，通常用于展示层（如视图层）的数据展示。VO 通常包含业务逻辑处理后的最终结果，可以直接用于渲染页面或返回给前端。</p></li></ul><h3 id="2-10-service"><a href="#2-10-service" class="headerlink" title="2.10 service"></a>2.10 service</h3><p>服务层，包含了业务逻辑的实现。通常，控制器会调用服务层的方法来完成具体的业务需求。定义了不同的接口，并且在 <code>\impl</code> 中进行了实现。</p><p><code>@Service</code> 是 Spring 框架中的一个注解，用于标记类作为服务层的组件。它是 <code>@Component</code> 注解的一个特化形式，主要用于标识那些包含业务逻辑的服务类。通过使用 <code>@Service</code> 注解，Spring 容器可以自动检测并管理这些服务类，从而实现依赖注入和其他 Spring 功能。</p><h3 id="2-11-system"><a href="#2-11-system" class="headerlink" title="2.11 system"></a>2.11 system</h3><p>包含系统级别的组件，比如系统配置、工具方法等，用于检测使用的GPU使用率和内存等信息。</p><h3 id="2-12-util"><a href="#2-12-util" class="headerlink" title="2.12 util"></a>2.12 util</h3><p>工具类一般放在这个包中，提供一些通用的功能，如字符串处理、日期格式化、加密解密等。</p><h3 id="2-13-websocket"><a href="#2-13-websocket" class="headerlink" title="2.13 websocket"></a>2.13 websocket</h3><p>主要作用是管理 WebSocket 连接，允许服务器与客户端进行实时通信。通过使用 Redis，可以在分布式环境中管理 WebSocket 连接的状态。</p><h3 id="2-14-Application-java"><a href="#2-14-Application-java" class="headerlink" title="2.14 Application.java"></a>2.14 Application.java</h3><p>这是一个 Spring Boot 应用程序的主类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;org.example.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RequestContextListener <span class="hljs-title function_">requestContextListener</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestContextListener</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@SpringBootApplication</code>：这个注解表示这是一个 Spring Boot 应用程序。</li><li><code>@MapperScan(&quot;org.example.mapper&quot;)</code>：这个注解用于指定 MyBatis 的 Mapper 接口所在的包，Spring Boot 会自动扫描这个包下的接口，并创建对应的代理对象。这些接口用于操作数据库。</li><li><code>public static void main(String[] args)</code>：这是 Java 程序的入口点。在这个方法中，调用了 <code>SpringApplication.run(Application.class, args)</code> 来启动 Spring Boot 应用程序。</li><li><code>@Bean public RequestContextListener requestContextListener()</code>：这个方法定义了一个 Bean，Bean 的类型是 <code>RequestContextListener</code>.<code>RequestContextListener</code> 是一个 Servlet 监听器，作用是在每个 HTTP 请求开始和结束时，将请求的信息（如请求参数、请求头、Session 等）绑定和解绑到当前线程，这样在处理请求的过程中，可以在任何地方获取到当前请求的信息。</li></ul><h2 id="3-调用流程"><a href="#3-调用流程" class="headerlink" title="3 调用流程"></a>3 调用流程</h2><p><img src="/Note-practice1/3.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Java</title>
    <link href="/Note-Java/"/>
    <url>/Note-Java/</url>
    
    <content type="html"><![CDATA[<p>学习 <a href="https://www.runoob.com/java/java-tutorial.html">Java</a> 的笔记。</p><span id="more"></span><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。</p><ul><li>对象：对象是类的一个实例，有状态和行为。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li><li>方法：方法就是行为，一个类可以有很多方法。</li><li>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li></ul><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><ul><li><p>一个源文件只能有一个 public 类，源文件名必须和类名相同，否则会导致编译错误。</p></li><li><p>构造方法名称必须与类同名。</p></li></ul><p><img src="/Note-Java/1.png"></p><p>所有的 Java 程序由 <code>public static void main(String[] args)</code> 方法开始执行。</p><p><img src="/Note-Java/2.jpg"></p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type identifier [ = value][, identifier [= value] ...] ;<br></code></pre></td></tr></table></figure><ul><li><p>局部变量（Local Variables）：局部变量是在方法、构造函数或块内部声明的变量，它们在声明的方法、构造函数或块执行结束后被销毁，局部变量在声明时需要初始化，否则会导致编译错误。</p></li><li><p>实例变量（Instance Variables）：实例变量是在类中声明，但在方法、构造函数或块之外，它们属于类的实例，每个类的实例都有自己的副本，如果不明确初始化，实例变量会被赋予默认值（数值类型为 0，boolean 类型为 false，对象引用类型为 null）。</p></li><li><p>静态变量或类变量（Class Variables）：类变量是在类中用 static 关键字声明的变量，它们属于类而不是实例，所有该类的实例共享同一个类变量的值，类变量在类加载时被初始化，而且只初始化一次。</p></li><li><p>参数变量（Parameters）：参数是方法或构造函数声明中的变量，用于接收调用该方法或构造函数时传递的值，参数变量的作用域只限于方法内部。</p></li></ul><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul><li><p><strong>作用域</strong>：局部变量的作用域限于它被声明的方法、构造方法或代码块内。一旦代码执行流程离开这个作用域，局部变量就不再可访问。</p></li><li><p><strong>生命周期</strong>：局部变量的生命周期从声明时开始，到方法、构造方法或代码块执行结束时终止。之后，局部变量将被垃圾回收。</p></li><li><p><strong>初始化</strong>：局部变量在使用前必须被初始化。如果不进行初始化，编译器会报错，因为 Java 不会为局部变量提供默认值。</p></li><li><p><strong>声明</strong>：局部变量的声明必须在方法或代码块的开始处进行。声明时可以指定数据类型，后面跟着变量名，例如：int count;。</p></li><li><p><strong>赋值</strong>：局部变量在声明后必须被赋值，才能在方法内使用。赋值可以是直接赋值，也可以是通过方法调用或表达式。</p></li><li><p><strong>限制</strong>：局部变量不能被类的其他方法直接访问，它们只为声明它们的方法或代码块所私有。</p></li><li><p><strong>内存管理</strong>：局部变量存储在 Java 虚拟机（JVM）的栈上，与存储在堆上的实例变量或对象不同。</p></li><li><p><strong>垃圾回收</strong>：由于局部变量的生命周期严格限于方法或代码块的执行，它们在方法或代码块执行完毕后不再被引用，因此 JVM 的垃圾回收器会自动回收它们占用的内存。</p></li><li><p><strong>重用</strong>：局部变量的名称可以在不同的方法或代码块中重复使用，因为它们的作用域是局部的，不会引起命名冲突。</p></li><li><p><strong>参数和返回值</strong>：方法的参数可以视为一种特殊的局部变量，它们在方法被调用时初始化，并在方法返回后生命周期结束。</p></li></ul><h4 id="实例变量（成员变量）"><a href="#实例变量（成员变量）" class="headerlink" title="实例变量（成员变量）"></a>实例变量（成员变量）</h4><ul><li><p>成员变量声明在一个类中，但在方法、构造方法和语句块之外。</p></li><li><p>当一个对象被实例化之后，每个成员变量的值就跟着确定。</p></li><li><p>成员变量在对象创建的时候创建，在对象被销毁的时候销毁。</p></li><li><p>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</p></li><li><p>成员变量可以声明在使用前或者使用后。</p></li><li><p>访问修饰符可以修饰成员变量。</p></li><li><p>成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见。</p></li><li><p>成员变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；</p></li><li><p>成员变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：<code>ObjectReference.VariableName</code>。</p></li><li><p>可以通过对象访问成员变量，也可以通过类名访问静态成员变量。</p></li></ul><p>PS: 报错 <code>Cannot make a static reference to the non-static field ...</code>， 是因为在静态方法中，不能直接访问非静态成员（包括方法和变量）。因为，非静态的变量是依赖于对象存在的，对象必须实例化之后，它的变量才会在内存中存在。</p><h4 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h4><p>Java 中的静态变量是指在类中定义的一个变量，它与类相关而不是与实例相关，即无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。</p><ul><li><p>由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量。</p></li><li><p>常量也是与类相关的，但它是用 final 关键字修饰的变量，一旦被赋值就不能再修改。与静态变量不同的是，常量在编译时就已经确定了它的值，而静态变量的值可以在运行时改变。</p></li><li><p>当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。静态变量在内存中只有一份拷贝，被所有实例共享。</p></li></ul><h4 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h4><p>Java 中的参数变量是指在方法或构造函数中声明的变量，用于接收传递给方法或构造函数的值。参数变量与局部变量类似，但它们只在方法或构造函数被调用时存在，并且只能在方法或构造函数内部使用。</p><ul><li><p><strong>值传递</strong>：在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。</p></li><li><p><strong>引用传递</strong>：在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值。</p></li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的。在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">10</span>);<br>        sb.append(<span class="hljs-string">&quot;Runoob..&quot;</span>);<br>        System.out.println(sb);  <br>        sb.append(<span class="hljs-string">&quot;!&quot;</span>);<br>        System.out.println(sb); <br>        sb.insert(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        System.out.println(sb); <br>        sb.delete(<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);<br>        System.out.println(sb);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Note-Java/3.svg"></p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>有两个同名函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>   <span class="hljs-type">int</span> result;<br>   <span class="hljs-keyword">if</span> (num1 &gt; num2)<br>      result = num1;<br>   <span class="hljs-keyword">else</span><br>      result = num2;<br> <br>   <span class="hljs-keyword">return</span> result; <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">double</span> num1, <span class="hljs-type">double</span> num2)</span> &#123;<br>  <span class="hljs-keyword">if</span> (num1 &gt; num2)<br>    <span class="hljs-keyword">return</span> num1;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> num2;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你调用 max 方法时传递的是 int 型参数，则 int 型参数的 max 方法就会被调用；如果传递的是 double 型参数，则 double 类型的 max 方法体会被调用，这叫做方法重载；就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p><p>重载的方法必须拥有不同的参数列表，不能仅仅依据修饰符或者返回类型的不同来重载方法。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p><p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p><p>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同（类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected）。</p><p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><img src="/Note-Java/4.png"></p><ul><li><p>子类拥有父类非 private 的属性、方法。</p></li><li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。</p></li><li><p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p></li></ul><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;   <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        <span class="hljs-comment">//初始化属性值</span><br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;&#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;&#125; <br>&#125; <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Animal</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 implements 关键字可以变相的使 java 具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>super 关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p></li><li><p>this 关键字：指向自己的引用。</p></li></ul><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <code>super</code> 关键字调用父类的构造器并配以适当的参数列表。</p><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><ul><li><p>重写（Override）是指子类定义了一个与其父类中具有相同名称、参数列表和返回类型的方法，并且子类方法的实现覆盖了父类方法的实现。 即外壳不变，核心重写。重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。这样，在使用子类对象调用该方法时，将执行子类中的方法而不是父类中的方法。</p><ul><li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个类，则不能重写该类的方法。</p></li></ul></li><li><p>重载（Overload）是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。</p><ul><li><p>被重载的方法必须改变参数列表（参数个数或类型不一样）；</p></li><li><p>被重载的方法可以改变返回类型；</p></li><li><p>被重载的方法可以改变访问修饰符；</p></li><li><p>被重载的方法可以声明新的或更广的检查异常；</p></li><li><p>方法能够在同一个类中或者在一个子类中被重载。</p></li><li><p>无法以返回值类型作为重载函数的区分标准。</p></li></ul></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。</p><p>多态存在的三个必要条件：</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<code>Parent p = new Child();</code></li></ul><p><img src="/Note-Java/5.jpg"></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的接口控制。</p><p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（Interface）是一个抽象类型，是抽象方法的集合，接口通常以 <code>interface</code> 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p>接口与类相似点：</p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><p>接口与类的区别：</p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><p>接口特性：</p><ul><li>接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><p>抽象类和接口的区别：</p><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 8. 毕业论文（精简版）</title>
    <link href="/Project8-FabricMan/"/>
    <url>/Project8-FabricMan/</url>
    
    <content type="html"><![CDATA[<p>题目：《对于 Execute-Order-Validate 区块链高并发冲突问题的优化》<br>发表：<a href="https://zte.magtechjournal.com/EN/10.12142/ZTECOM.202402004">https://zte.magtechjournal.com/EN/10.12142/ZTECOM.202402004</a></p><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>伴随着区块链技术的成熟与进步，一种新型的 Execute-Order-Validate（EOV）区块链架构被提出，使得交易在执行阶段可以并行。这一架构的代表系统便是 Hyperledger Fabric。但是由于其的并行执行机制，在验证阶段可能会产生大量的 MVCC 冲突，导致大量交易被无效化。根据产生原因不同，我们将冲突分为区块内冲突和区块间冲突两种类型，并基于 Fabric v2.4 实现了优化方案 FabricMan。针对区块内冲突，我们在排序阶段设计了一个重排序算法来提高交易成功率，并根据交易依赖图实现了验证阶段的并行验证。我们还对同一区块内简单的资产转移交易实现了交易的合并，使其不会触发多次版本检验。针对区块间冲突，我们实现了一个基于缓存的版本验证机制，来提前检测并中止无效交易。我们将 FabricMan 与 Fabric 和 Fabric++ 两个系统进行了实验对比，结果表明在吞吐量、交易中止率、算法执行时间等多项实验指标上，FabricMan 均优于对比系统。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>区块链技术的流行开始于比特币[1]论文的发表，其本质上是一种分布式账本技术，而这种技术受欢迎的真正原因在于它提供了一种方式，使得在缺少可信第三方条件下的点对点交易变为可能。伴随着以太坊[2]中智能合约的出现，区块链技术凭借其去中心化、防篡改、可溯源等特性，被研究和应用在金融[3]、医疗[4,5]、供应链[6]和物联网[7]等多个领域。</p><p>从参与者的角度，区块链系统可以分为许可链和非许可链。非许可链又叫公链，是任意节点都可以匿名参与的区块链。由于节点身份未知，且相互不信任，这类区块链系统中往往会使用 proof of work 或其他共识机制来解决拜占庭容错共识问题[8]。而另一方面，许可链是由一组身份经过验证的节点组成的区块链系统。这类系统往往只应用于某些特定的场景，其中的节点虽然并不完全信任彼此但拥有共同的目标。许可链对参与节点进行约束，并且可以控制不同节点的读写权限，因此更加适用于企业级的应用。</p><p>然而，不论是像比特币、以太坊这样的非许可链还是像 Tendermint、Quorum 这样的许可链，大部分主流的区块链系统使用的都是 active replication[9]：首先通过共识协议或者 atomic broadcast 对交易进行排序，并打包成区块传递给节点；然后所有节点按照顺序执行交易，改变自己的账本状态。我们将这种系统叫做 OE（Order-Execute）architecture，该模型的局限性在于所有节点都必须按顺序串行执行所有交易，这无疑会限制系统的吞吐量。为了让交易的执行有更好的并行性，一种新型的 EOV（Execute-Order-Validate）模型被提了出来：在执行阶段，客户端会把交易提案发送给多个节点进行背书，此时进行背书的节点仅仅是区块链网络中节点的一个子集，不同的节点在同一时间可以对不同的交易进行背书，从而该系统拥有并行执行交易的能力。收集到足够数量的背书后，客户端会将所有背书响应打包成一笔交易发送给排序节点进行排序并出块。最后排序节点将区块发送给所有节点来验证并同步账本状态。该模型使用乐观的多版本并发控制技术来保证并行执行数据的一致性，随之而来的问题是验证阶段可能会出现的 MVCC（Multi-Version Concurrency Control）[10]冲突。</p><p>我们将 EOV 系统中的冲突分为两类，一是区块内读写冲突 (within-block conflicts)，即在同一个区块内先执行交易的写集更改了后面某一笔交易读集的版本号，使得后一笔交易在验证阶段无效。二是跨区块读写冲突 (cross-block conflicts)，即某一笔交易在执行阶段读的值，在到达验证阶段之前，被这期间提交的其他区块修改所导致的最终无效化。Ankur[11] 等人提出了一个名为 Fabric++ 的系统，通过对交易重排序来改善区块内读写冲突的问题，使得最终被无效的交易数量减少。但是经我们测试，该算法在交易冲突率较高时效率很低。为改善上述问题，我们以 Fabric v2.4 作为基础对 EOV 区块链系统做了几点优化，并将系统命名为 FabricMan。本文的主要贡献如下：</p><ul><li>我们设计并实现了一个时间复杂度较稳定的重排序算法来减少区块内的读写冲突，并设计实验与 Fabric++ 的算法相比较，发现在交易冲突率较高的情况下我们的算法更优秀。</li><li>基于重排序时生成的交易冲突图，我们在验证阶段对无关交易进行并行验证，以此发挥出多核 cpu 的优势。</li><li>在链码参数层面分析交易，我们对简单的资产转移交易进行合并，使得多笔交易在验证阶段只用验证一次读写集，最大化该类型交易的验证通过率。</li><li>我们实现了一个基于缓存的版本验证机制，在排序阶段提前检测并中止了部分无效交易，来减少跨区块的读写冲突。</li></ul><p>The rest of the paper is organized as follows: 第 2 章会介绍 Hyperledger Fabric 的结构以及其他的相关研究，第 3 章会对 Fabric 中存在的问题进行理论分析并提出解决思路，第 4 章会介绍 FabricMan 的设计和优化点，第 5 章对 FabricMan 的优化进行实验测试，并分别与 Fabric 和 Fabric++ 对比，最后第 6 章对我们的工作进行总结。</p><h2 id="2-Background-and-Related-Work"><a href="#2-Background-and-Related-Work" class="headerlink" title="2 Background and Related Work"></a>2 Background and Related Work</h2><h3 id="2-1-EOV-Architecture-in-Hyperledger-Fabric"><a href="#2-1-EOV-Architecture-in-Hyperledger-Fabric" class="headerlink" title="2.1 EOV Architecture in Hyperledger Fabric"></a>2.1 EOV Architecture in Hyperledger Fabric</h3><p> 基于 EOV 架构模块化设计区块链的代表之一便是 Hyperledger Fabric[12]，简称 Fabric。Fabric 中的所有节点在任何时候都是已知并经过授权的，主要分为三种类型：(1) client 节点负责提交交易提案（transaction proposals），并收集背书响应；(2) peer 节点负责 executes 和 validates 交易提案，并 commits 其读写集以维护本地的账本。不同的 peer 节点被划分到不同的 organizations，同一组织内的 peer 相互可信；(3) orderer 负责对接收到的交易进行排序，并按照预设的规则出块。区块中的交易顺序是由所有 orderer 节点基于共识协议共同决定的。系统中的交易流程如 Figure 1 所示，The workflow of a transaction consists of three phases: execution, ordering, and validation.</p><p> <img src="/Project8-FabricMan/fig1.png" alt="Figure 1"></p><h4 id="2-1-1-Execution-Phase"><a href="#2-1-1-Execution-Phase" class="headerlink" title="2.1.1 Execution Phase"></a>2.1.1 Execution Phase</h4><p>在执行阶段，客户端会按照提前设定好的背书政策（endorsement policy）将交易提案发送给 peer 节点的一个子集，called the endorsers。由于参与交易的多个组织之间是互不信任的，通常背书政策需要每个组织至少有一个 endorser 参与背书。endorsers 会按照本地维护的当前账本状态并行的模拟执行交易，并生成相应的读写集。这里的读集是一个（key，ver）二元组，写集是一个（key，val）二元组，这里的 key is a unique name representing the entry，ver 和 val 分别是实体最新的版本号（由最近更新此实体的区块高度和交易号表示）和值。执行完成后，endorsers 会将读写集与自己的签名返回给 client，当 client 收集到足够数量的来自不同 endorsers 的相同读写集时，便可以将它们打包成一笔交易发送给排序集合，来进入下一个阶段。</p><h4 id="2-1-2-Ordering-Phase"><a href="#2-1-2-Ordering-Phase" class="headerlink" title="2.1.2 Ordering Phase"></a>2.1.2 Ordering Phase</h4><p>在排序阶段，不同的 orderers 会不断从不同的 clients 接受交易。ordering service 需要达成两个目标：(a) 对交易顺序达成共识，(b) 将排好序的交易按照规则打包成区块并 deliver 给所有的 peers。Fabric v2.4 在 (a) 中使用的是 Raft[6] 协议，for achieving crash-fault-tolerant consensus。而 (b) 中的出块规则一般由最大出块间隔和区块包含最大交易数量共同形成。注意，系统并不保证所有节点会同时收到区块，但是可以确定所有节点收到的区块中的交易顺序是相同的。</p><h4 id="2-1-3-Validation-Phase"><a href="#2-1-3-Validation-Phase" class="headerlink" title="2.1.3 Validation Phase"></a>2.1.3 Validation Phase</h4><p>当节点收到来自 orderers 的一个区块时，首先检测是否有 orderers 的签名以及区块结构的合法性，若通过检测则将区块加入一个验证队列，保证其可以加入区块链，然后依次进入 VSCC 和 MVCC 验证阶段。在 VSCC 阶段，节点会检查区块中每一笔交易的签名是否满足该链码特定的背书策略。若不满足，则将该交易标记为无效但依旧留在块中。在 MVCC 阶段，会按顺序对所有标记为有效的交易进行 Multi-Version Concurrency Control check。如果交易读集中某个 key 的版本号与当前世界状态中的版本号不一致，交易将会被标记无效。最后节点将区块写入本地账本，并根据每一笔交易的有效性修改当前世界状态。</p><h3 id="2-2-Optimization-of-Fabric"><a href="#2-2-Optimization-of-Fabric" class="headerlink" title="2.2 Optimization of Fabric++"></a>2.2 Optimization of Fabric++</h3><p>The vanilla Fabric 是按照交易抵达排序节点的先后顺序来确定区块内的交易顺序的，这样虽然可以快速进行排序，但同时可能导致潜在的不必要的序列化冲突。如 Table 1 所示，四笔交易按照 T1，T2，T3，T4 的顺序排列出块，T1 首先将 k1 的版本从 v1 更新至 v2。由于 T2、T3、T4 都需要读取 v1 版本的 k1，它们在验证阶段都会因为读取过时的版本被标记为无效，最终区块只会有一笔有效交易。被无效的交易若想被重新执行，则又需要通过新一轮的 simulation, ordering, and validation，这无疑大大降低了系统的效率。</p><p><img src="/Project8-FabricMan/tab1.png" alt="Table 1"></p><p>Ankur 等人对上述问题提出了一个名为 Fabric++ 的优化系统。他们发现之前例子中的四笔交易是存在一个无冲突排序的，即 T4，T2，T3，T1 如 Table 2 所示。导致区块产生冲突的原因是 Fabric 按照交易到达顺序进行排序。所以他们在 Fabric 的基础上增加了一个重排序算法，根据交易间读写集的关系来提前中止少量交易，并为剩余交易构建一个无冲突排序，以此来增加区块内的交易成功率。</p><p><img src="/Project8-FabricMan/tab2.png" alt="Table 2"></p><p>Fabric++ 的重排序算法主要分为五个步骤：(1)首先根据所有待排序交易的读写集构建冲突图。(2)然后应用 Tarjan[13] 的算法来识别所有强连通子图，并使用 Johnson[14] 的算法识别强连通子图中的所有环。(3)识别每一笔交易所在的环，并分别统计出现在多少个环中。(4)依次中止出现在最多环中的交易，直到冲突图无环。(5)最后利用剩余的交易建立一个可序列化的调度方案。</p><h3 id="2-3-Related-Work"><a href="#2-3-Related-Work" class="headerlink" title="2.3 Related Work"></a>2.3 Related Work</h3><p>目前对于 EOV 区块链的研究主要有性能测试[15-19]、安全性分析[20-23]、性能优化几个方向，本文主要关注对性能的优化。优化主要可以分为两类：(1)提升系统整体的吞吐量。(2)减少并行执行所带来的读写冲突。</p><p>Parth Thakkar[24] 等人通过配置 Block Size、Endorsement Policy、Channel、Resource Allocation、Ledger Database 等五个参数，对 Fabric v1.0 系统性能进行了较为全面的测试，并发现了其三个主要的性能瓶颈：(1)背书策略的验证。(2)块中交易的顺序策略验证。(3) CouchDB 的状态验证和提交。同时他们对上述问题进行了简单的优化：(1)使用以序列化形式为键的哈希映射来缓存反序列化的身份，以此减少加密操作的资源消耗。(2)并行验证多个交易的背书，以利用闲置的 CPU 并提高整体性能。(3)对于 CouchDB 的批量读写优化。达到了提升系统整体吞吐量的效果。</p><p>Christian Gorenflo[25] 等人重新构建了 Hyperledger Fabric v1.2。通过(1)在排序时仅传入交易 ID 而非整个交易。(2)在 committers 中积极缓存未组装的块，同时并行化尽可能多的验证步骤。(3)重新设计数据管理层，使用内存数据库取代原有数据存储。(4)分离负责背书和提交的节点角色。以此减少交易排序和验证期间的计算和 I&#x2F;O 开销，将交易吞吐量从每秒 3000 笔提高到 20000 笔。</p><p>Pingcheng Ruan[26] 等人研究了 Fabric++ 的方案，认为其没有考虑到跨区快交易之间的依赖性，重排序效果受限。他们提出了一种更细粒度并发控制策略下的重排序算法，并验证了其安全性，使得重排序效果得到提升。</p><p>Qiucheng Sun[27] 等人分析了 Fabric++ 实现的重排序算法，在信任方面发现问题。并基于贪心算法提出了一个可信的重排序算法。</p><h2 id="3-Problem-Analysis"><a href="#3-Problem-Analysis" class="headerlink" title="3 Problem Analysis"></a>3 Problem Analysis</h2><p>In this section，我们主要介绍 EOV 架构中存在的两种 MVCC 冲突，namely within-block conflicts and cross-block conflicts，并分析产生这两种冲突的原因，同时提出我们的发现与改进思路。</p><p>正如在第 2 章所提到的，Fabric 在执行阶段会生成交易的读写集。其中读集包含该交易读取的所有 key 的列表，以及相应的 version number。写集包含最终用于更新账本的键值对。在验证阶段，节点会根据本地数据库的当前状态对交易的读写集做 MVCC 验证。验证方法就是检测读集中的版本号是否与本地当前状态的版本号一致。若版本不一致，交易会被标记为无效，其写集无法被用于更新账本状态，此时便发生了 MVCC 冲突。为了检测这一冲突对系统带来的影响，我们在第 5 章描述的环境配置下，使用 SmallBank 智能合约在 Fabric v2.4 上进行了测试。我们改变合约中账户数量，从 3000 到 500，并使用已有帐户随机触发 Smallbank 合约中的交易，记录其有效以及中止交易的 TPS 如 Figure 2 所示。</p><p><img src="/Project8-FabricMan/fig2.png" alt="Figure 2"></p><p>实验中每个区块约包含 256 笔交易，当总的账户数量为 3000 时，从中随机选择账户进行交易的冲突率较低，此时成功交易的 TPS 较高，约占 90%。当系统中账户数量减少时，区内交易冲突率升高，被中止的交易占比增加。在总账户数量为 500 时，成功交易的 TPS 仅有 30%。可见在区块内交易冲突数量增加时，系统性能下降显著。</p><p>在高并发执行环境中，我们将 EOV 区块链中 MVCC 冲突分为两种：within-block conflicts and cross-block conflicts。</p><h3 id="3-1-Within-block-Conflicts"><a href="#3-1-Within-block-Conflicts" class="headerlink" title="3.1 Within-block Conflicts"></a>3.1 Within-block Conflicts</h3><p>Within-block conflicts 是发生在同一个区块不同交易之间的读写冲突。在构建区块时，如果将多个对同一个 key 进行读写的交易划分到同一区块中，就可能导致这一冲突。例如在 Table 3 的例子中，T1 、T2 按顺序被打包到一个区块中。在验证阶段，T1 先对 k1 进行了更新操作，使其版本号变为 v1。接下来轮到 T2 被验证，它的读集中包含 v0 版本的 k1，在进行 MVCC 验证时发现 v0 ≠ v1，所以 T2 被标记为无效。</p><p><img src="/Project8-FabricMan/tab3.png" alt="Table 3"></p><p><strong>Observation 1:</strong> 可以修改区块内交易的验证顺序，来减少区块内交易的冲突数量。块内冲突的根本原因是同一区块中两笔不同的交易对某个 key 进行了先写后读的操作，导致后一笔交易在验证读集时发生版本冲突。我们发现此例中若先验证 T2，将 k2 的版本进行修改，只读 k1 并不修改其版本，在后续验证 T1 时便不会产生冲突，这样两笔交易就可以同时通过验证提交到账本。</p><p>在 2.2 节中提到的 Fabric++ 在排序阶段使用了重排序算法，但是其在从强连通子图中检测所有的环时使用了 Johnson 的算法，这一算法的时间复杂度为 O((n+e)(c+1))，其中 n 是节点数量，e 是边的数量，c 是图中环的数量。冲突图中节点和边的数量受图大小的限制，可以控制在较小的值。但是环的数量却没有限制，可能非常大。文章[28]也指出了类似的问题：Fabric++ 在解决环时，每删除一个交易都需要重新计算循环中单个事务的出现次数，这使得整个算法的时间复杂度来到 O(n^3)。由于拓扑排序是图论中一种对有向无环图（DAG）进行顶点线性排序的算法，并且其算法执行时间非常稳定为 O(n+e)，我们可以基于拓扑排序提出一种新的重排序算法，使得在交易冲突率较高的环境下系统依旧可以较快的完成重排序。</p><p><strong>Observation 2:</strong> 交易重排序生成的冲突图可以体现交易之间的依赖信息，这一信息可以用于实现交易的并行验证。在 Fabric 区块链中，验证部分可以分为两个主要阶段：VSCC 和 MVCC。VSCC 用于评估交易中的背书是否符合链码指定的背书政策，由于交易背书的验证之间是相互独立的，这一步在 Fabric 系统中已经实现了并行。而 MVCC 用于确保在背书阶段交易期间读取的 key 的版本与提交时节点账本中的当前状态相同，这一步是在通过 VSCC 检测的交易上按顺序执行的。文章[24]指出 Fabric 的性能瓶颈之一是验证阶段对区块内所有交易的串行 MVCC 验证，如果能够利用交易之间的依赖性将无关交易并行验证，那么就可以充分利用多核 CPU 的优势以提升系统的性能。</p><p><strong>Observation 3:</strong> 转账交易是测试中的主要交易类型之一，并且其逻辑简单、参数固定，适于合并。由于 Fabric 作为联盟链较难获取公开的区块数据，且不同用户搭建的链之间数据不互通，难以获取具有统计意义的数据，在此引用文章[29]对以太坊的交易分析。该文章对以太坊上一段时间内的交易进行并行执行，发现发生冲突的主要三种交易类型为：ERC20 代币交易占 60%，去中心化金融（DeFi）交易占 29%，游戏和收藏品交易占 10%。因此我们认为对转账交易之间的合并具有一定意义。我们希望通过合并其读写集的方式将转账交易进行合并，避免转账交易之间的冲突，以此提升此种类型交易的吞吐量。</p><h3 id="3-2-Cross-block-Conflicts"><a href="#3-2-Cross-block-Conflicts" class="headerlink" title="3.2 Cross-block Conflicts"></a>3.2 Cross-block Conflicts</h3><p>Cross-block conflicts 是发生在不同区块之间的读写冲突。由于 Execute-Order-Validate 的结构特性，交易在 simulated execution 和 verifcation submission 之间有一定的时延。如果有两笔交易在两个不同的区块中，在前一个区块进行验证之前，后一个区块中的交易读取了前一个区块中某笔交易写的 key，从而导致后一个区块中发生脏读，最终引起 MVCC 冲突。如 Figure 3 所示，T1 和 T2 是处在不同区块中的两笔交易。在执行交易时，T1 读取 k1 的当前版本号 v0 并加入其读集。从验证阶段可以看出 T1 的写集对 k1 进行了修改，但由于这一步是模拟执行，执行结果并不会更改数据库状态，所以紧随其后的 T2 执行阶段读取到的依旧是 v0 版本的 k1。之后包含 T1 的区块先进入验证阶段，并更新了节点当前状态中 k1 的版本号到 v1。当验证包含 T2 的区块时，节点就会检测出 T2 的读集中存在 k1 的版本冲突，从而导致交易无效。</p><p><img src="/Project8-FabricMan/fig3.png" alt="Figure 3"></p><p>此外，在网络拥堵等特殊情况下也会产生区块间冲突。例如一笔交易 T1 读取了 v0 版本的 k1，但是在网络拥堵的环境下，T1 花费很长时间才到达排序节点并进入新的区块。但在此之前排序节点已经处理过高于 v0 版本的 k1 的交易 T2。注定无法通过 MVCC 验证的 T1，却依旧需要经历排序、出块和验证阶段，直到最后在验证交易读写集的版本时才会将其中止。</p><p><strong>Observation 4:</strong> 排序节点有机会提前中止区块间冲突产生的无效交易。所有交易都会到达排序节点进行出块，由于交易读集中 key 的版本号都是在交易模拟执行时从账本中读取的，所以此时账本中该 key 的版本号一定不低于读集中的版本。所以如果当前区块中或节点后续收到的某个交易读集中的 key 低于此版本，则可以直接判定为无效交易。</p><h2 id="4-Design-of-FabricMan"><a href="#4-Design-of-FabricMan" class="headerlink" title="4 Design of FabricMan"></a>4 Design of FabricMan</h2><p>In the previous section，我们分析了 EOV 区块链中的区块内和区块间两种冲突问题，并发现了四个可以优化的方向。本章首先介绍我们对排序阶段流程的修改，之后介绍我们针对四个优化方向分别设计的交易重排序、并行验证、交易合并和缓存机制四个模块。</p><p>我们对 EOV 区块链的修改主要集中在排序阶段，如 Figure 4 所示。排序节点从多个不同的客户端接受交易，并按照交易到达的顺序将其加入一个 batch 数组，直到满足出块条件。出块条件由两部分组成：一是 batch 中交易数量到达设定的阈值，二是构建 batch 的时间到达设置的最大出块时间。满足其中任何一个条件的 batch 将不再加入新的交易，而是进入下一步的处理，新到达排序节点的交易会加入一个新创建的 batch。</p><p><img src="/Project8-FabricMan/fig4.png" alt="Figure 4"></p><p>对满足出块条件的 batch，本系统首先通过排序节点维护的版本缓存表对 batch 中的所有交易进行过滤，在此期间系统会读取交易的读写集并与缓存进行比较。若不符合判定规则，系统会中止该交易并反馈给客户端。若通过缓存表过滤，系统会判断交易是否为转账交易，若是，则将其移动到转账交易数组，并与其他转账交易合并。最终 batch 中剩余的交易都是通过缓存过滤的非转账交易，系统会对它们进行重排序，中止冲突交易，并根据依赖关系划分交易子图。最后系统会使用合并交易、转账交易和重排序后的 batch 构建新的区块，将交易子图添加进区块头部，然后将区块发送给所有对等节点。</p><h3 id="4-1-Transaction-Reordering"><a href="#4-1-Transaction-Reordering" class="headerlink" title="4.1 Transaction Reordering"></a>4.1 Transaction Reordering</h3><p>在对一个交易集合 S 进行重排序时，首先需要识别交易间的依赖关系，来构建交易冲突图。在冲突图中，如果一笔交易 Ti 指向另一笔交易 Tj，则表示 Ti 的写集与 Tj 的读集有交集，记为 Ti → Tj。这表示在排序出块时，Tj 需要在 Ti 之前，否则 Tj 会因为读取过时的版本而被无效。在构建冲突图时，每一个节点代表一笔交易，由上述定义可知一个节点的出度表示该交易会影响多少个交易的有效性，入度表示受到多少其他交易的影响。此外，构建无冲突排序需要解决的一个重要问题就是图中出现的环。有环的图是无法进行序列化排序的，这需要我们在算法中移除一些交易来使原本的冲突图变为无环图。</p><p>我们的算法是基于拓扑排序的，但是由于拓扑排序无法适用于有环的图，所以我们做了一些改进。From a high-level perspective，算法主要分为五个步骤：(1)首先根据交易集合 S 中每一笔交易的读写集构建冲突图，并记录每个节点的入度和出度。(2)选择一个入度最小的节点作为待处理节点，若有多个节点满足条件，则选择一个出度最大的节点，若仍有多个则任选其中一个节点。(3)将指向待处理节点的其他节点从图中移除，直到待处理节点的入度为 0。(4)将待处理节点加入排序队列并从图中移除。(5)重复上述(2)(3)(4)步直到冲突图中无剩余节点。最后将排序队列进行反序，便可以得到一个无冲突的序列化排序。The pseudo-code of Algorithm 1 implements these five steps。注意在步骤 (2) 中，由于需要将待处理节点的入度变为 0，所以我们优先选择入度最小的节点，以留下更多的交易。又因为节点的出度是其在排序后会影响的交易数量，而最终排序是排序队列的反序，即在算法中先进入排序队列的交易会在较后的位置。所以我们优先选择出度最大的交易进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs code">Algorithm 1 Reorder Sorting<br><br>func ReorderSort(Transaction[] S) &#123;<br>    // Step 1: <br>    Graph cg = buildConflictGraph(S)<br>    Graph incg = invert cg<br>    map[Transaction]int indegree = Calculate in-degrees using cg<br>    map[Transaction]int outdegree = Calculate out-degrees using cg<br><br>    // Step 2: <br>    while S is not empty:<br>        for each Transaction tx in S:<br>            if indegree[tx] &lt; minIndegree:<br>                minIndegree = indegree[tx]<br>                nodeToSort = node<br>            else if indegree[tx] == minIndegree and outdegree[tx] &gt; outdegree[nodeToSort]:<br>                nodeToSort = node<br><br>        // Step 3: <br>        for each nodeToRemove in incg[nodeToSort]:<br>            if nodeToRemove not in S:<br>                continue<br>            remove nodeToRemove from S<br>            for each tx in cg[nodeToRemove]:<br>                indegree[tx]--        <br>            for each tx in incg[nodeToRemove]:<br>                outdegree[tx]--<br><br>        // Step 4: <br>        append nodeToSort to result<br>        for each tx in cg[nodeToSort]:<br>            indegree[tx]--<br>        remove nodeToSort from S<br><br>    // Step5: <br>    return result.invert()<br>&#125;<br></code></pre></td></tr></table></figure><p>为了理解算法中的实现细节，我们举一个例子。假设交易集合 S 中有 T0 到 T5 六笔交易，通过 Step(1) 根据交易读写集构建出的冲突图如 Figure 5 所示，每个节点的入度和出度如 Table 4 所示。由 Step(2)，我们选择 T5 作为 nodeToSort，因为它此时是集合 S 中入度最小的节点。由于它的入度为 0 所以跳过 Step(3)。Step(4) 会将 T5 加入 result 队列，并将其从集合 S 中删除，然后将它指向的 T2 节点的入度减一。</p><p><img src="/Project8-FabricMan/fig5.png" alt="Figure 5"></p><p><img src="/Project8-FabricMan/tab4.png" alt="Table 4"></p><p>进入下一个循环，此时我们发现 T0、T2、T4 的入度都是 1，均为此时入度最小的节点，但是 T4 有最大的出度。根据 Step(2) 我们选择 T4 作为 nodeToSort。然后 Step(3) 从 S 中删除指向 T4 的节点 T2，使得 T4 的入度为 0，此时的冲突图如 Figure 6 所示，点的入度和出度如 Table 5 所示。Step(4) 将 T4 加入 result 队列，并将其从集合 S 中删除，然后将 T1 和 T3 的入度分别减一。</p><p><img src="/Project8-FabricMan/fig6.png" alt="Figure 6"></p><p><img src="/Project8-FabricMan/tab5.png" alt="Table 5"></p><p>此时图中只剩下一个由 T0、T1、T3 组成的环，由于其入度出度都一样，我们选择 T0 作为 nodeToSort，移除 T1，将 T0 加入 result 队列，最后将 T3 加入 result 队列。将 result 队列反序，我们便得到了最终的重排序结果，即 T3、T0、T4、T5。此排序过程主体部分与拓扑排序时间复杂度相当，为 O(n+e)，并且该算法并不受到图中环的数量影响，消除了 Fabric++ 算法中的这一缺陷。值得一提的是，我们的算法并不保证中止图中最少数量的交易使图无环，因为这是一个 NP 难的问题。我们只是提供了一个非常轻量级的方式来中止少量交易，从而生成一个可序列化排序方案。</p><h3 id="4-2-Parallel-Verification"><a href="#4-2-Parallel-Verification" class="headerlink" title="4.2 Parallel Verification"></a>4.2 Parallel Verification</h3><p>在进行交易重排序时，算法会生成交易之间的冲突图，如 Algorithm 1 的 3、4 行所示，其中 cg 是生成的冲突图，由一个二维数组表示，cg[i] 是一维数组，若其中有一个元素 j 则表示 Tj 必须出现在 Ti 之前，即 Ti→Tj。而 incg 是 cg 的逆图，同样用二维数组表示，若 incg[i] 中有一个元素 j 则表示 Tj 必须出现在 Ti 之后，即 Tj→Ti。</p><p>在重排序完成后，系统会将算法中止的交易从冲突图中删除，最终剩下 cg’ 和 incg’ 两个无环子图，然后对其进行 DFS（深度优先遍历）操作来寻找子图中的连通分量，并进一步划分为相互不连通的子图，伪代码如表所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs code">Algorithm 2 划分子图<br><br>func FindConnectedComponents(cg’, incg’) &#123;<br>    n = length of cg’<br>    visited = array of n elements initialized with false<br>    components = empty array<br>    for i = 0 to n-1 :<br>        if visited[i] is false :<br>            component = empty array<br>            // 利用深度优先遍历检测节点间依赖关系<br>            DFS(cg’, incg’, i, visited, component)<br>            append component to components<br>    return components<br>&#125;<br><br>func DFS(cg’, incg’, vertex, visited, component) &#123;<br>    append vertex to component<br>    visited[vertex] = true<br>    neighbors = cg’[vertex] + incg’[vertex]<br>    for each neighbor in neighbors :<br>        if visited[neighbor] is false :<br>            DFS(cg’, incg’, neighbor, visited, component)<br>&#125;<br></code></pre></td></tr></table></figure><p>系统得到存储子图信息的 components 数组后，对其进行序列化处理并在出块时将其放入区块头部。在验证阶段节点会对其进行反序列化操作，然后根据数组信息对独立的交易子图调用 Goroutine 并行完成后续 MVCC 验证操作。</p><h3 id="4-3-Transaction-Merging"><a href="#4-3-Transaction-Merging" class="headerlink" title="4.3 Transaction Merging"></a>4.3 Transaction Merging</h3><p>假设有三个账户 A、B、C 的初始余额都为 10，初始版本都是 v0。在进行简单的转账交易时，有两笔交易 T1（A 给 B 转账 10 个数字货币）和 T2（B 给 C 转账 10 个数字货币），并且被打包到 Fabric 的同一区块中，读写集如 Table 6 所示。由于 T1 和 T2 都对 B 进行了读写，所以在 Fabric 中只有排序在前的一笔交易可以通过验证。</p><p><img src="/Project8-FabricMan/tab6.png" alt="Table 6"></p><p>我们通过在背书阶段模拟执行时对交易链码的参数和读写集进行分析，来标记简单的转账交易，并在交易读集的结构体中加入 Value 字段用于表示其初始值。在排序阶段，节点会识别不同链码下的转账交易，并对同一链码的转账交易构建转帐表。首先节点会将账户的初始余额加入 moneyMap 表中，并将其对应的版本号加入 versionMap 表。然后对每一笔转账交易进行处理：若发起转账的账户余额小于转账金额，则直接将交易中止；若余额足够则将发送方余额减去转账金额，接收方余额增加转账金额。等到将所有转账交易处理完毕，系统会利用 versionMap 中的 key 和对应的版本号构建合并交易的读集，利用 moneyMap 中的 key 和 value 构建合并交易的写集。</p><p>在此例中，排序节点读取 T1 的读写集，由于 T1 已经在前一阶段被识别为转账交易，排序节点首先记录读集中 A 和 B 的初始值，然后根据写集 A 和 B 值的变化推测出转账金额，将 A 的值减 10，B 的值加 10，若此时余额不足则将交易中止。同理操作 T2，只不过在记录初始值时忽略已经存在的 B。最终得到合并交易的读写集如 Table 7 所示。由于验证阶段只对合并交易的读写集验证一次，因此 T1 和 T2 对账本状态的修改都可以生效。</p><p><img src="/Project8-FabricMan/tab7.png" alt="Table 7"></p><p>合并交易构建完成后，系统会在出块时将其放在区块第一笔交易的位置，并将被合并的转账交易依次放在其之后的位置。在区块中保留被合并的交易有两点好处：一是为了在验证合并交易后将交易成功与否的信息反馈给客户端，二是将交易数据保留在链上以便日后的审查。在验证阶段，节点检测到合并交易会对其进行有效性的验证，若通过验证则依次将交易成功的信息反馈给发送被合并交易的客户端，否则返回错误信息并将所有被合并交易标记为无效。</p><h3 id="4-4-Caching-Mechanism"><a href="#4-4-Caching-Mechanism" class="headerlink" title="4.4 Caching Mechanism"></a>4.4 Caching Mechanism</h3><p>为了缓解 3.2 节中提到的 Cross-block conflicts 读写冲突问题，我们在排序节点使用哈希表实现了一个缓存，用于缓存收到交易的读写集中的 key 和版本号。缓存表中一共包含 key、version 和 updated 三个字段，其中哈希表的 key 是智能合约链码中某实体的唯一名称，version 表示对应 key 在交易中读取到的最新版本号，由区块号和交易号形成的二元组表示，updated 字段则表示对应的 key 是否有可能被新的区块所更新。该缓存在交易到达排序节点时，会检查每一笔交易的读集。若读集中的某个 key 小于缓存中的版本号，则直接将交易中止，这可以防止由于网络中某些陈旧的交易占用系统资源。若读集中的某个 key 大于缓存中的版本号，或不存在于缓存，则更新缓存储存最新的版本号。若读集中的某个 key 等于缓存中的版本号，则看其是否有 updated 标记，若有则中止交易。在进行完重排序后，排序节点得到了一个包含无冲突交易排序的区块，系统正常运行下，这个区块的写集都会被应用于账本的更新。此时排序节点会检查每一笔交易的读集，若缓存中包含与读集相同的 key，则在缓存对应的值中加上 updated 标记。这表示该 key 已被更新，该版本已不是此 key 的最新版本。</p><p>如 Figure 7 所示，T1 和 T2 是处在不同区块中的两笔交易。在执行交易时，T1 读取 k1 的当前版本号 v0 并加入其读集，此时节点的本地状态并未发生变化，T2 也读取了 k1 和其版本号 v0。在排序阶段，当读取到 T1 读集中的 k1 时，orderer 将其与缓存中的值进行比较并发现缓存中不存在 k1，于是将 k1:v0 加入缓存。经过重排序后，orderer 再次检查交易序列，发现 k1 出现在序列交易的读集中，于是将缓存更新为 k1:v0-updated，表示当前节点的帐本中 k1 的版本大于 v0。随后包含交易 T2 的区块到来，orderer 检测到其读集中 k1 的版本为 v0，而缓存中 k1 的版本为 v0-updated，于是中止 T2。</p><p><img src="/Project8-FabricMan/fig7.png" alt="Figure 7"></p><p>使用此缓存机制存在一个问题，假如上述示例中 T1 由于某些意外原因（如签名问题）未能通过最终的验证阶段。此时节点世界状态中 k1 的版本号依旧为 v0，但是 orderer 中 k1 的版本号已经被更新为 v0-updated，这会导致后续读取 k1 的交易都无法通过。针对这一问题，我们在 orderer 的缓存中加入计时器，如果某个 key 在一个出块间隔时间内未被更新，则将其移出缓存。这同时也保证了缓存所占空间不会无限制增加。</p><h2 id="5-Experimental-Evaluation"><a href="#5-Experimental-Evaluation" class="headerlink" title="5 Experimental Evaluation"></a>5 Experimental Evaluation</h2><p>为了验证本文提出改进方案的有效性，我们基于 Fabric v2.4 实现了第四章提出的改进方案，并将系统命名为 FabricMan。由于原本的 Fabric++ 代码是基于 Fabric v1.2 实现的，为了方便对比，我们同样基于 Fabric v2.4 实现了 Fabric++ 的改进。并且在本章对 Fabric、Fabric++ 和 FabricMan 等三个系统在吞吐量、交易成功率、算法运行时间等关键指标上开展实验评估工作。</p><h3 id="5-1-Setup-and-Workload"><a href="#5-1-Setup-and-Workload" class="headerlink" title="5.1 Setup and Workload"></a>5.1 Setup and Workload</h3><p>本文实验场景为单通道区块链系统，其中包含 2 个组织，每个组织包含 2 个对等节点，节点通过 Docker 容器部署。共识机制采用 Raft 共识，并使用 LevelDB 作为状态数据库。实验使用 1 台 36 核 CPU(Intel Core i9-10980XE 3.0GHz) 服务器进行，256GB RAM，并运行在 Ubuntu 20.04.5 LTS 环境下。</p><p>实验采用 Smallbank 和自定义链码两种工作负载，并在 caliper-benchmarks 测试框架下进行测试。Smallbank 合约为每个用户创建一个支票账户和一个储蓄账户，包括六个函数，其中五个以某种方式更新账户余额：TransactSavings 和 DepositChecking 分别增加储蓄账户和支票账户的一定金额。SendPayment 在两个支票账户之间转移资金。WriteCheck 减少支票账户余额，而 Amalgamate 将所有资金从储蓄账户转移到支票账户。此外，还有一个只读事务 Query，它读取用户的支票账户和储蓄账户。在单次运行中，我们以相同的概率随机运行这六种函数中的一个，并随机选取某个或某两个系统中存在的账户进行交易。通过改变系统中账户数量，来控制区块内可能产生交易冲突的概率。而在自定义链码中我们定义了复杂读写交易，从系统中读取四个账户的余额并对其中两个进行修改，这涉及到四个账户的读和两个账户的写。</p><p>在第 3 章中我们使用 Smallbank 对 Fabric 测试了在不同账户数量情况下有效交易和中止交易吞吐量的情况，可以得到不同账户对应的交易冲突率情况如 Table 8 所示。在后续实验中我们依旧采用该实验中账户数量取值，用于测量系统在不同交易冲突率情况下的表现。</p><p><img src="/Project8-FabricMan/tab8.png" alt="Table 8"></p><h3 id="5-2-The-Impact-of-Block-Size"><a href="#5-2-The-Impact-of-Block-Size" class="headerlink" title="5.2 The Impact of Block Size"></a>5.2 The Impact of Block Size</h3><p>区块大小是影响区块链吞吐量和延迟的重要因素之一，我们首先测试改变区块大小对 Fabric、Fabric++ 和 FabricMan 吞吐量的影响。我们使用 Smallbank 合约，并在系统账户为 3000 时的低冲突率环境下完成这个实验。第一步我们改变 FabricMan 的区块大小（BS）从 64 到 512 ，测试其在不同交易发送率下的吞吐量，结果如 Figure 8 所示。我们发现随着交易发送率增加，系统吞吐量也逐渐提升，直到大约 240 tps 时达到饱和。此时的交易发送率为 512，后续实验采用该发送率发送交易以测得系统最佳性能。随着区块大小从 64 增加到 256，系统吞吐量也有所增加，而区块大小为 512 时，系统吞吐量下降。这是因为增加区块中的交易数会导致冲突交易变多，减少成功交易的吞吐量，并且较大的区块在系统中传输时间也会增加。</p><p><img src="/Project8-FabricMan/fig8.png" alt="Figure 8"></p><p>我们对另外两个对比系统也进行了类似的实验，区块大小对三个系统吞吐量的影响如 Figure 9 所示。可以看出随着区块内交易数量增加，FabricMan 和 Fabric++ 中成功交易的吞吐量与 Fabric 差距越大。这是因为同一区块内交易数量越多，发生冲突概率越大，重排作用越明显。在区块大小为 256 时三个系统吞吐量都到达峰值，因此在后续实验中，我们使用 256 作为区块中包含交易的最大数量，设置最大出块间隔为 1 秒，并将交易发送率设置为每秒 512 笔。</p><p><img src="/Project8-FabricMan/fig9.png" alt="Figure 9"></p><h3 id="5-3-The-Comparison-of-Reordering-Algorithm"><a href="#5-3-The-Comparison-of-Reordering-Algorithm" class="headerlink" title="5.3 The Comparison of Reordering Algorithm"></a>5.3 The Comparison of Reordering Algorithm</h3><p>为了检测本文提出的重排序算法性能，我们准备了多个打包好的区块（每个区块中包含 256 笔交易），分别使用 FabricMan 和 Fabric++ 的重排序算法进行重排序，比较其排序时间和区块内最终有效交易的数量以及有效交易的吞吐量。在此实验中我们使用自定义链码的复杂读写交易来提高交易之间的关联性和冲突率，以更好的检测两种算法性能。我们控制系统中账户数量从 1500 逐步减少到 1000，Figure 10 显示了两种算法对区块进行重排序的时间。可以看出 Fabric++ 在区块内冲突率增加时所需时间增长明显，在账户数量为 1000 的时候已经无法正常出块。</p><p><img src="/Project8-FabricMan/fig10.png" alt="Figure 10"></p><p>并且实验中我们发现在同一轮次实验中（账户数量相同时），Fabric++ 在不同区块排序时间差别巨大。而 FabricMan 重排算法时间稳定在 1500us 左右，不随着区块内交易冲突增加而发生明显变化。但是由于 FabricMan 的重排算法并不能像 Fabric++ 一样在每一轮选出存在最多环中的节点，所以最终成功交易略少于 Fabric++ 中的区块，如 Figure 11 所示。但是其稳定的时间复杂度可以让它在 1000 及以下账户数量的高冲突率环境中依旧正常出块。</p><p><img src="/Project8-FabricMan/fig11.png" alt="Figure 11"></p><p>最后我们比较了两系统在吞吐量上的差异，结果如 Figure 12 所示，实验中 FabricMan 仅加入了重排序模块的优化。我们发现 FabricMan 在各个账户数量的设置下，吞吐量均高于 Fabric++。这是因为在账户数量为 1300 到 1400 时区块内冲突率较低，同一区块内两种排序算法得到的有效交易数量相当，但是 FabricMan 重排序算法有更短的排序时间。当账户数量小于 1400 时，系统冲突率增加明显，虽然 Fabric++ 重排序算法可以得到更多的有效交易，但是其重排序所花时间增长显著。</p><p><img src="/Project8-FabricMan/fig12.png" alt="Figure 12"></p><h3 id="5-4-The-Effect-of-Parallel-Verification"><a href="#5-4-The-Effect-of-Parallel-Verification" class="headerlink" title="5.4 The Effect of Parallel Verification"></a>5.4 The Effect of Parallel Verification</h3><p>本节我们测试给 FabricMan 验证节点分配不同的 CPU 核心数量对并行验证时间的影响。由于许可区块链在进行节点身份的加密和解密运算时同样需要使用大量的 CPU 资源，这会影响到我们的实验结果。为了消除该部分的影响，我们使用多个打包好的区块，分别在 CPU 核心数为 1 到 16 的验证节点进行 MVCC 验证时间的模块化测试。实验使用 Smallbank 合约，并设置不同的账户数量（AC）表示不同的冲突率。为了使在不同冲突率下验证的交易数一致，本实验在出块时不采用重排序，仅使用交易子图的划分算法。测试结果如 Figure 13 所示，可以看出随着使用的核心数的增加，不同冲突率区块的 MVCC 验证时间有明显减少。而核心数到达 8 以上时间减少不明显，这是因为该阶段与数据库交互和最长交易冲突链的串行验证成为瓶颈。区块冲突率越高时，形成的最长冲突链越长，相应的验证时间也越长。</p><p><img src="/Project8-FabricMan/fig13.png" alt="Figure 13"></p><h3 id="5-5-The-Effect-of-Transaction-Merging"><a href="#5-5-The-Effect-of-Transaction-Merging" class="headerlink" title="5.5 The Effect of Transaction Merging"></a>5.5 The Effect of Transaction Merging</h3><p>我们使用 1000 个账户发送 Smallbank 合约中的非转账交易或转账交易，其中非转账交易交易无法合并，而转账交易是可以进行合并的。发送转账交易的占比由 15% 逐步提升至 85%，Fabric、Fabric++ 和 FabricMan 系统中成功交易的占比如 Figure 14 所示。转账交易占比较低时，Fabric++ 和 FabricMan 因为使用重排序，成功交易的比例高于 Fabric。当转账交易占比增加，FabrciMan 由于交易合并机制，成功交易比例增加，在转账交易占比为 85% 时 FabricMan 中 90% 以上的交易都可以成功提交。而由于转账交易相较于 Smallbank 中的非转账交易的读写集更复杂，交易间关联性更强，所以随着转账交易占比增加 Fabric 和 Fabric++ 中 MVCC 冲突数量增加，成功交易比例降低。</p><p><img src="/Project8-FabricMan/fig14.png" alt="Figure 14"></p><h3 id="5-6-Combinations-of-Optimizations"><a href="#5-6-Combinations-of-Optimizations" class="headerlink" title="5.6 Combinations of Optimizations"></a>5.6 Combinations of Optimizations</h3><p>最后我们对系统的整体性能进行测试。我们使用 smallbank 合约作为工作负载，并将第四章提到的所有优化应用于 FabricMan 系统，在不同账户数量下进行测试。与 Fabric 和 Fabric++ 中有效交易的吞吐量进行对比结果如 Figure 15 所示，系统中的交易中止率如 Figure 16 所示。可见当账户数量为 3000 时，此时交易中止率较低，Fabric 的吞吐量在三个系统中最低，不到 200 tps。Fabric++ 由于重排序的作用，吞吐量略高，约为 220 tps。而 FabricMan 由于重排序和并行验证以及对其中转账交易的合并，吞吐量约为 240 tps，为三者最高。当账户数量从 3000 逐步减少到 500 时，区块内交易中止率不断增加，Fabric 的有效交易吞吐量下降严重，只有不到最初的一半。而 FabricMan 的有效吞交易吐量下降较为缓慢，且交易中止率最低，在高并发冲突环境下仍能保持较高吞吐量。</p><p><img src="/Project8-FabricMan/fig15.png" alt="Figure 15"></p><p><img src="/Project8-FabricMan/fig16.png" alt="Figure 16"></p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6 Conclusion"></a>6 Conclusion</h2><p>本文针对新型的 EOV 区块链并发执行交易产生 MVCC 冲突影响性能的问题，提出了一种综合考虑块内冲突和块间冲突，并且能够进行并行验证和交易合并的区块链架构 FabicMan。针对块内冲突，本文提出一种比 Fabric++ 重排序算法在时间上更加稳定的算法对区块内交易重排序，增加交易验证的成功率。同时还提出使用交易冲突图信息在验证节点对无关交易并行验证，并且对简单的资产转移交易进行交易合并的方案，从而提升 EOV 区块链系统性能。针对块间冲突，本文提出一种利用交易读写集和版本号在排序节点提前中止冲突交易的缓存机制。实验结果表明 FabricMan 在吞吐量、交易中止率、执行时间等方面均优于对比方案。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Nakamoto S. Bitcoin: A peer-to-peer electronic cash system[J]. 2008.</p><p>[2] Buterin V. A next-generation smart contract and decentralized application platform[J]. white paper, 2014, 3(37): 2-1.</p><p>[3] Qin K, Zhou L, Gervais A. Quantifying blockchain extractable value: How dark is the forest?[C]&#x2F;&#x2F;2022 IEEE Symposium on Security and Privacy (SP). IEEE, 2022: 198-214.</p><p>[4] Azaria A, Ekblaw A, Vieira T, et al. Medrec: Using blockchain for medical data access and permission management[C]&#x2F;&#x2F;2016 2nd international conference on open and big data (OBD). IEEE, 2016: 25-30.</p><p>[5] Fan K, Wang S, Ren Y, et al. Medblock: Efficient and secure medical data sharing via blockchain[J]. Journal of medical systems, 2018, 42: 1-11.</p><p>[6] Abeyratne S A, Monfared R P. Blockchain ready manufacturing supply chain using distributed ledger[J]. International journal of research in engineering and technology, 2016, 5(9): 1-10.</p><p>[7] Dai H N, Zheng Z, Zhang Y. Blockchain for Internet of Things: A survey[J]. IEEE internet of things journal, 2019, 6(5): 8076-8094.</p><p>[8] Vukolić M. The quest for scalable blockchain fabric: Proof-of-work vs. BFT replication[C]&#x2F;&#x2F;Open Problems in Network Security: IFIP WG 11.4 International Workshop, iNetSec 2015, Zurich, Switzerland, October 29, 2015, Revised Selected Papers. Springer International Publishing, 2016: 112-125.</p><p>[9] Charron-Bost B, Pedone F, Schiper A. Replication[M]. Springer Berlin Heidelberg, 2010.</p><p>[10] Papadimitriou C H, Kanellakis P C. On concurrency control by multiple versions[J]. ACM Transactions on Database Systems (TODS), 1984, 9(1): 89-99.</p><p>[11] Sharma A, Schuhknecht F M, Agrawal D, et al. Blurring the lines between blockchains and database systems: the case of hyperledger fabric[C]&#x2F;&#x2F;Proceedings of the 2019 International Conference on Management of Data. 2019: 105-122.</p><p>[12] Androulaki E, Barger A, Bortnikov V, et al. Hyperledger fabric: a distributed operating system for permissioned blockchains[C]&#x2F;&#x2F;Proceedings of the thirteenth EuroSys conference. 2018: 1-15.</p><p>[13] Tarjan R. Depth-first search and linear graph algorithms[J]. SIAM journal on computing, 1972, 1(2): 146-160.</p><p>[14] Johnson D B. Finding all the elementary circuits of a directed graph[J]. SIAM Journal on Computing, 1975, 4(1): 77-84.</p><p>[15] Dinh T T A, Wang J, Chen G, et al. Blockbench: A framework for analyzing private blockchains[C]&#x2F;&#x2F;Proceedings of the 2017 ACM international conference on management of data. 2017: 1085-1100.</p><p>[16] Baliga A, Solanki N, Verekar S, et al. Performance characterization of hyperledger fabric[C]&#x2F;&#x2F;2018 Crypto Valley conference on blockchain technology (CVCBT). IEEE, 2018: 65-74.</p><p>[17] Shalaby S, Abdellatif A A, Al-Ali A, et al. Performance evaluation of hyperledger fabric[C]&#x2F;&#x2F;2020 IEEE International Conference on Informatics, IoT, and Enabling Technologies (ICIoT). IEEE, 2020: 608-613.</p><p>[18] Sukhwani H, Wang N, Trivedi K S, et al. Performance modeling of hyperledger fabric (permissioned blockchain network)[C]&#x2F;&#x2F;2018 IEEE 17th international symposium on network computing and applications (NCA). IEEE, 2018: 1-8.</p><p>[19] Jiang L, Chang X, Liu Y, et al. Performance analysis of Hyperledger Fabric platform: A hierarchical model approach[J]. Peer-to-Peer Networking and Applications, 2020, 13: 1014-1025.</p><p>[20] Andola N, Gogoi M, Venkatesan S, et al. Vulnerabilities on hyperledger fabric[J]. Pervasive and Mobile Computing, 2019, 59: 101050.</p><p>[21] Yamashita K, Nomura Y, Zhou E, et al. Potential risks of hyperledger fabric smart contracts[C]&#x2F;&#x2F;2019 IEEE International Workshop on Blockchain Oriented Software Engineering (IWBOSE). IEEE, 2019: 1-10.</p><p>[22] Brandenburger M, Cachin C, Kapitza R, et al. Blockchain and trusted computing: Problems, pitfalls, and a solution for hyperledger fabric[J]. arXiv preprint arXiv:1805.08541, 2018.</p><p>[23] Dabholkar A, Saraswat V. Ripping the fabric: Attacks and mitigations on hyperledger fabric[C]&#x2F;&#x2F;Applications and Techniques in Information Security: 10th International Conference, ATIS 2019, Thanjavur, India, November 22–24, 2019, Proceedings 10. Springer Singapore, 2019: 300-311.</p><p>[24] Thakkar P, Nathan S, Viswanathan B. Performance benchmarking and optimizing hyperledger fabric blockchain platform[C]&#x2F;&#x2F;2018 IEEE 26th international symposium on modeling, analysis, and simulation of computer and telecommunication systems (MASCOTS). IEEE, 2018: 264-276.</p><p>[25] Gorenflo C, Lee S, Golab L, et al. FastFabric: Scaling hyperledger fabric to 20 000 transactions per second[J]. International Journal of Network Management, 2020, 30(5): e2099.</p><p>[26] Ruan P, Loghin D, Ta Q T, et al. A transactional perspective on execute-order-validate blockchains[C]&#x2F;&#x2F;Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data. 2020: 543-557.</p><p>[27] Sun Q, Yuan Y, Guo T, et al. A Trusted Solution to Hyperledger Fabric Reordering Problem[C]&#x2F;&#x2F;2021 8th International Conference on Dependable Systems and Their Applications (DSA). IEEE, 2021: 202-207.</p><p>[28] Wu H, Liu H, Li J. FabricETP: A high-throughput blockchain optimization solution for resolving concurrent conflicting transactions[J]. Peer-to-Peer Networking and Applications, 2023, 16(2): 858-875.</p><p>[29] Garamvölgyi P, Liu Y, Zhou D, et al. Utilizing parallelism in smart contracts on decentralized blockchains by taming application-inherent conflicts[C]&#x2F;&#x2F;Proceedings of the 44th International Conference on Software Engineering. 2022: 2315-2326.</p>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 7. 实验设计参考</title>
    <link href="/Project7-Experiment/"/>
    <url>/Project7-Experiment/</url>
    
    <content type="html"><![CDATA[<p>参考几篇关于 Fabirc 改进论文的实验部分，来设计改进后系统的测试方法并进行测试。注：并未记录所有的实验，只是选取了对我的实验有帮助的部分进行了翻译。</p><span id="more"></span><h2 id="1-Fabric-1"><a href="#1-Fabric-1" class="headerlink" title="1 Fabric [1]"></a>1 Fabric [1]</h2><p>引入了一个类似于 Bitcoin 的加密货币，称之为 Fabric Coin（Fabcoin）用于测试系统的性能。</p><p>Fabcoin 中的每个状态都是一个元组，形式为 (key, val) &#x3D; (txid.j, (amount, owner, label))，表示作为交易的第 j 个输出创建的币状态，带有标识符 txid，并分配给具有公钥 owner 的实体的金额单位，带有标签 label。标签是用于识别给定类型币（例如，’USD’、’EUR’、’FBC’）的字符串。交易标识符是唯一标识每个 Fabric 交易的短值。Fabcoin 实现包括三个部分：（1）客户端钱包，（2）Fabcoin 链码，（3）用于 Fabcoin 实现其认可策略的自定义 VSCC。</p><h3 id="1-1-实验环境"><a href="#1-1-实验环境" class="headerlink" title="1.1 实验环境"></a>1.1 实验环境</h3><p>(1) 节点运行 Fabric 版本 v1.1.0-preview2，通过本地日志记录进行性能评估；(2) 节点托管在一个 IBM Cloud（SoftLayer）数据中心（DC）中，作为专用 VMs，通过 1 Gbps（名义上的）网络互连；(3) 所有节点都是 2.0 GHz 的 16-vCPU VMs，运行 Ubuntu，具有 8 GB 的 RAM 和 SSD 作为本地磁盘；(4) 单一通道排序服务运行一个典型的 Kafka 配置，包括 3 个 ZooKeeper 节点，4 个 Kafka 节点和 3 个 Fabric 排序者，都在不同的 VMs 上；(5) 总共有 5 个对等节点，都属于不同的组织（orgs）并且都是 Fabcoin 认可者；(6) 签名使用默认的 256 位 ECDSA 方案。为了测量和分析跨多个节点的交易流程中的延迟，节点时钟在整个实验过程中都与 NTP 服务同步。所有 Fabric 节点之间的通信都配置为使用 TLS。</p><p>在每个实验中，第一阶段我们调用仅包含 Fabcoin 铸币操作的交易来生成硬币，然后在实验的第二阶段中，我们调用 Fabcoin 花费操作来花费之前铸币的硬币（实际上运行单输入、单输出的花费交易）。在吞吐量测量时，我们使用越来越多的 Fabric CLI 客户端（经修改以发出并发请求）在单个 VM 上运行，直到端到端吞吐量饱和，并报告略低于饱和的吞吐量。吞吐量数字报告为实验稳定状态期间的平均值，不考虑“尾部”，在尾部一些客户端线程已经停止提交他们的交易。在每个实验中，客户端线程集体调用至少 500,000 次铸币和花费交易。</p><h3 id="1-2-实验结果"><a href="#1-2-实验结果" class="headerlink" title="1.2 实验结果"></a>1.2 实验结果</h3><h4 id="1-2-1-区块大小的选择"><a href="#1-2-1-区块大小的选择" class="headerlink" title="1.2.1 区块大小的选择"></a>1.2.1 区块大小的选择</h4><p>对 0.5 MB 到 4 MB 不同的区块大小设置进行实验。</p><p><img src="/Project7-Experiment/1.png"></p><p>可以观察到吞吐量在区块到达 2 MB 后便没有显著增加了，反而延迟更差。因此，我们采用 2 MB 作为之后实验的块大小，以最大化测量的吞吐量为目标，假设大约 500 ms 的端到端延迟是可以接受的。</p><h4 id="1-2-2-节点-CPU-的影响"><a href="#1-2-2-节点-CPU-的影响" class="headerlink" title="1.2.2 节点 CPU 的影响"></a>1.2.2 节点 CPU 的影响</h4><p>Fabric 节点运行许多 CPU 密集型的加密操作。为了估算 CPU 性能对吞吐量的影响，我们进行了一组实验，在这些实验中，4 个节点分别运行在 4、8、16 和 32 个 vCPU VMs 上，同时进行了粗粒度的块验证延迟分级，以识别瓶颈。验证阶段，特别是 Fabcoin 的 VSCC 验证，由于涉及到大量数字签名验证，因此在计算上是密集的。我们通过在节点本地测量验证阶段的延迟来计算节点的验证吞吐量。</p><p><img src="/Project7-Experiment/2.png"></p><p>我们可以观察到，验证工作明显限制了吞吐量。此外，Fabcoin VSCC 的验证性能随着 CPU 增加几乎是线性的，因为 Fabric 的 VSCC 的背书策略验证是并行的。然而，读写检查和账本访问阶段是顺序的，随着核心数（vCPUs）增加，它们变得更加显著。这在花费交易中尤为明显，因为比铸币交易更多的花费交易可以放入 2 MB 的区块，这会延长顺序验证阶段的持续时间（即读写检查和账本访问）。</p><p>最后，在这个实验中，我们在拥有 32 个 vCPU 的节点上测量到每秒超过 3560 个 SPEND 交易的平均吞吐量。MINT 吞吐量一般略低于 SPEND 吞吐量，但差异在 10% 以内，32 个 vCPU 的节点达到了超过 3420 个 tps 的平均吞吐量。</p><h4 id="1-2-3-阶段性的延迟分析"><a href="#1-2-3-阶段性的延迟分析" class="headerlink" title="1.2.3 阶段性的延迟分析"></a>1.2.3 阶段性的延迟分析</h4><p><img src="/Project7-Experiment/3.png"></p><p>在之前的实验中，我们在报告的峰值吞吐量时进行了粗粒度的延迟分析。排序阶段包括广播传递延迟以及在验证开始之前的节点内部延迟。表格报告了铸币和花费的平均延迟、标准差和尾延迟。我们观察到排序阶段占据了整体延迟的主导地位。我们还看到平均延迟低于 550 毫秒，具有次秒级的尾延迟。特别是在我们的实验中，最高的端到端延迟来自于负载建立过程中的第一个区块。</p><h2 id="2-Optimizing-Fabric-2"><a href="#2-Optimizing-Fabric-2" class="headerlink" title="2 Optimizing Fabric [2]"></a>2 Optimizing Fabric [2]</h2><p>本文先是对 Fabric 1.0 进行了测试，总结并优化了其中的几个性能瓶颈，测试部分见我之前翻译的<a href="https://qanlyma.github.io/Paper-Fabric-Optimizing/#IV-EXPERIMENTAL-METHODOLOGY">文章</a>。</p><p>注：此论文的三个优化已经被 Fabric 1.1 采用。</p><h2 id="3-FastFabric-3"><a href="#3-FastFabric-3" class="headerlink" title="3 FastFabric [3]"></a>3 FastFabric [3]</h2><h3 id="3-1-实验环境"><a href="#3-1-实验环境" class="headerlink" title="3.1 实验环境"></a>3.1 实验环境</h3><p>我们使用了一台 1 Gbit&#x2F;s 交换机连接的十五台本地服务器。每台服务器配备了两个 2.10 GHz 的 Intel Xeon CPU E5-2620 v2 处理器，总共提供 24 个硬件线程和 64 GB 的 RAM。我们使用 Fabric 1.2 作为基准，并逐步添加我们的改进以进行比较。默认情况下，Fabric 配置为使用 LevelDB 作为对等方状态数据库，排序节点将已完成的区块存储在内存中，而不是在磁盘上。此外，我们在不使用 Docker 容器的情况下运行整个系统，以避免额外的开销。</p><p>我们确保实现不会改变 Fabric 的验证行为，所有测试都是使用不冲突和有效的交易进行的。这是因为有效的交易必须通过每个验证检查步骤，并且它们的写入集将在提交期间应用于状态数据库。相比之下，无效的交易可以被丢弃。因此，我们的结果评估了最坏情况下的性能。</p><p>在实验中，我们专门关注排序者或提交者时，会隔离相应的系统部分。在排序者实验中，我们从客户端向排序者发送预加载的已认可交易，而模拟的提交者会简单地丢弃已创建的区块。同样，在提交者的基准测试期间，我们将预加载的区块发送给提交者，并创建模拟的认可方和区块存储，它们会丢弃已验证的区块。</p><p>然后，在端到端设置中，我们实现了完整的系统：</p><ul><li>背书节点根据提交者已验证的区块的复制世界状态认可客户端的交易提案；</li><li>排序者从已认可的交易创建区块并将其发送给提交者；</li><li>提交者验证并提交更改到其内存中的世界状态，并将已验证的区块发送给背书节点和区块存储；</li><li>区块存储使用 Fabric 1.2 数据管理来将区块存储在其文件系统中，将状态存储在 LevelDB 中。</li></ul><p>为了进行公平比较，我们在所有实验中使用相同的交易链码：每个交易模拟从一个帐户向另一个帐户的资金转移，读取并修改状态数据库中的两个键。此外，我们使用默认的背书策略，即接受单个背书方签名。</p><h3 id="3-2-实验结果"><a href="#3-2-实验结果" class="headerlink" title="3.2 实验结果"></a>3.2 实验结果</h3><p>实验结果见此<a href="https://qanlyma.github.io/Paper-Fabric-Fast/#IV-RESULTS">文章</a>。</p><p>在最后端到端的测量中，我们设置了单一的排序节点，它使用三个 ZooKeeper 服务器和三个 Kafka 服务器的集群，具有默认的主题复制因子为三，并将其连接到一个对等节点。来自此对等节点的区块被发送到一个单一的数据存储服务器，该服务器将世界状态存储在 LevelDB 中，将区块存储在文件系统中。为了进行横向扩展，五个背书节点复制对等方状态并提供足够的吞吐量来处理客户端背书负载。最后，客户端安装在自己的服务器上；此客户端从五个背书节点服务器请求背书，然后将已背书的交易发送到排序服务。在我们的本地数据中心，总共使用了连接到相同 1 Gbit&#x2F;s 交换机的十五台服务器。</p><p><img src="/Project7-Experiment/4.png"></p><p>我们从客户端发送了共计 100,000 笔已背书的交易给排序节点，排序节点将它们分成每个块包含 100 笔交易的区块，并将它们传递给对等节点。为了估算吞吐量，我们测量了对等节点上提交的区块之间的时间，并对单次运行的平均时间进行了测量。这些运行重复了 100 次。表格显示相对于 Fabric 1.2 基准测试，吞吐量有了显著的 6-7 倍的改进。</p><h2 id="4-Fabric-4"><a href="#4-Fabric-4" class="headerlink" title="4 Fabric++ [4]"></a>4 Fabric++ [4]</h2><p>提出了 reorder 和 early abort 两种优化方案。集群由六台相同的服务器组成，这些服务器位于同一机架内，并通过千兆以太网连接。其中四台机器充当对等节点，一台机器运行排序服务，而另一台机器充当客户端，负责提交交易提案。每台服务器都由两颗四核的 Intel Xeon CPU E5-2407（SandyBridge 架构）组成，主频为 2.2 GHz，拥有 32 KB 的 L1 缓存，256 KB 的 L2 缓存以及 10 MB 的共享 L3 缓存。每个 NUMA 区域都连接有 24 GB 的 DDR3 内存。操作系统采用的是 64 位的 Arch Linux，内核版本为 4.17。Fabric 被设置为使用 LevelDB 作为当前状态数据库。</p><h3 id="4-1-实验环境"><a href="#4-1-实验环境" class="headerlink" title="4.1 实验环境"></a>4.1 实验环境</h3><p><img src="/Project7-Experiment/6.png"></p><h4 id="4-2-1-Throughput-under-Smallbank"><a href="#4-2-1-Throughput-under-Smallbank" class="headerlink" title="4.2.1 Throughput under Smallbank"></a>4.2.1 Throughput under Smallbank</h4><ol><li><p>选择交易：根据概率 Pw，以均匀方式从五个修改交易中选择一个要执行的交易，或者以概率 1-Pw 选择读取交易。这意味着修改交易和读取交易之间的选择是随机的，并且概率 Pw 控制了执行修改交易的频率。</p></li><li><p>确定账户：对于每个选中的交易，通过遵循 Zipf 分布来确定要访问的账户。Zipf 分布的偏斜度可以通过设置 s 值来调整。如果 s 值为 0，分布将是均匀的，而较高的 s 值将导致分布更加偏斜，即更倾向于访问一小部分账户。</p></li></ol><p><img src="/Project7-Experiment/5.png"></p><h4 id="4-2-2-Throughput-under-custom-workload"><a href="#4-2-2-Throughput-under-custom-workload" class="headerlink" title="4.2.2 Throughput under custom workload"></a>4.2.2 Throughput under custom workload</h4><p>工作负载完全由一个高度可配置的交易组成，该交易对一组账户余额执行一定数量的读取和写入访问。初始时，我们创建了一定数量的账户（N），每个账户都初始化为一个随机整数。我们的交易在这些账户的子集上执行一定数量的读取和写入操作（RW）。在这些账户中，存在一定数量的热门账户（HSS），它们以更高的概率被选中进行读取或写入访问。选择用于读取的热门账户的概率（HR）和选择用于写入的热门账户的概率（HW）也可以进行配置。</p><p><img src="/Project7-Experiment/7.png"></p><h3 id="4-2-实验结果"><a href="#4-2-实验结果" class="headerlink" title="4.2 实验结果"></a>4.2 实验结果</h3><p>实验结果见此<a href="https://qanlyma.github.io/Paper-Fabric-Plus/#6-EXPERIMENTAL-EVALUATION">文章</a>。</p><p>Caliper 在高交易触发率下表现不佳，我们以每个客户端每秒 150 次的较低速率触发交易，总共每秒触发 600 次交易。将区块大小调整为 512 次交易。使用 N &#x3D; 10,000、RW &#x3D; 4、HR &#x3D; 40%、HW &#x3D; 10%、HSS &#x3D; 1% 来测试我们的自定义工作负载。</p><p><img src="/Project7-Experiment/8.png"></p><h2 id="5-FabricSharp-5"><a href="#5-FabricSharp-5" class="headerlink" title="5 FabricSharp [5]"></a>5 FabricSharp [5]</h2><p>实验结果见此<a href="https://qanlyma.github.io/Paper-Fabric-Sharp/#5-EXPERIMENTS">文章</a>。</p><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6 参考文献"></a>6 参考文献</h2><p>[1] Androulaki E , Barger A , Bortnikov V , et al. Hyperledger fabric: a distributed operating system for permissioned blockchains[C]&#x2F;&#x2F; European Conference on Computer Systems.ACM, 2018.</p><p>[2] Nathan S , Thakkar P , Vishwanathan B . Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform: IEEE, 10.1109&#x2F;MASCOTS.2018.00034[P]. 2018.</p><p>[3] Gorenflo C ,  Lee S ,  Golab L , et al. FastFabric: Scaling Hyperledger Fabric to 20,000 Transactions per Second[J]. IEEE, 2019.</p><p>[4] Sharma A ,  Schuhknecht F M ,  Agrawal D , et al. Blurring the Lines between Blockchains and Database Systems: the Case of Hyperledger Fabric[C]&#x2F;&#x2F; ACM SIGMOD 2019. ACM, 2019.</p><p>[5] Ruan P ,  Loghin D ,  Ta Q T , et al. A Transactional Perspective on Execute-order-validate Blockchains[J].  2020.</p>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 6. 测试合约及脚本</title>
    <link href="/Project6-Contract/"/>
    <url>/Project6-Contract/</url>
    
    <content type="html"><![CDATA[<p>本文记录用于测试的智能合约以及脚本，对于源码的优化修改请看我的 <a href="https://github.com/qanlyma/fabricMan">Github 仓库</a>。</p><span id="more"></span><p>首先说明一下我整个实验的文件构成：</p><p><img src="/Project6-Contract/1.png"></p><ul><li><p><code>caliper-benchmarks</code> 是用于性能测试的框架，js 测试文件就在其中。</p></li><li><p><code>fabricMan</code> 是我对 fabric 源码的修改，使用该源码编译生成 docker 镜像。</p></li><li><p><code>twoPeerNet</code> 是在本地使用 docker 搭建的一个区块链网络，包含了各种配置文件和 shell 脚本。</p></li></ul><h2 id="1-simpletest-go"><a href="#1-simpletest-go" class="headerlink" title="1 simpletest.go"></a>1 simpletest.go</h2><p>该合约功能较为简单，主要有以下几个函数：</p><ul><li><p>Init 函数：这是链码的初始化函数，它在链码部署时被调用，但在后续的交易中不会再次调用。</p></li><li><p>Invoke 函数：这是链码的调用函数，它根据传入的函数名称执行不同的操作。根据传入的函数名，它会调用 Open、Delete、Query、Transfer 或 Copy 函数，或者返回格式错误的错误消息。</p></li><li><p>Open 函数：接受两个参数，账户名和初始金额，检查账户是否已存在，如果不存在则创建账户并存储初始金额。</p></li><li><p>Delete 函数：接受一个参数，账户名，然后删除该账户。</p></li><li><p>Query 函数：接受一个参数，账户名，然后返回账户的当前余额。</p></li><li><p>Transfer 函数：接受三个参数，源账户名、目标账户名和要转移的金额。它会检查源账户的余额是否足够，如果足够则执行转账操作。</p></li><li><p>R2w2 函数：接受四个参数，对前两个账户进行读操作，对后两个进行写操作，是用于重排序测试而添加的函数。</p></li><li><p>main 函数：程序的入口点，用于启动链码。它使用 shim.Start 函数启动链码，如果启动失败，则输出错误信息。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;strconv&quot;</span><br><br><span class="hljs-string">&quot;github.com/hyperledger/fabric-chaincode-go/shim&quot;</span><br>pb <span class="hljs-string">&quot;github.com/hyperledger/fabric-protos-go/peer&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> ERROR_SYSTEM = <span class="hljs-string">&quot;&#123;\&quot;code\&quot;:300, \&quot;reason\&quot;: \&quot;system error: %s\&quot;&#125;&quot;</span><br><span class="hljs-keyword">const</span> ERROR_WRONG_FORMAT = <span class="hljs-string">&quot;&#123;\&quot;code\&quot;:301, \&quot;reason\&quot;: \&quot;command format is wrong\&quot;&#125;&quot;</span><br><span class="hljs-keyword">const</span> ERROR_ACCOUNT_EXISTING = <span class="hljs-string">&quot;&#123;\&quot;code\&quot;:302, \&quot;reason\&quot;: \&quot;account already exists\&quot;&#125;&quot;</span><br><span class="hljs-keyword">const</span> ERROR_ACCOUNT_ABNORMAL = <span class="hljs-string">&quot;&#123;\&quot;code\&quot;:303, \&quot;reason\&quot;: \&quot;abnormal account\&quot;&#125;&quot;</span><br><span class="hljs-keyword">const</span> ERROR_MONEY_NOT_ENOUGH = <span class="hljs-string">&quot;&#123;\&quot;code\&quot;:304, \&quot;reason\&quot;: \&quot;account&#x27;s money is not enough\&quot;&#125;&quot;</span><br><br><span class="hljs-keyword">type</span> SimpleChaincode <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *SimpleChaincode)</span></span> Init(stub shim.ChaincodeStubInterface) pb.Response &#123;<br><span class="hljs-comment">// nothing to do</span><br><span class="hljs-keyword">return</span> shim.Success(<span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *SimpleChaincode)</span></span> Invoke(stub shim.ChaincodeStubInterface) pb.Response &#123;<br>function, args := stub.GetFunctionAndParameters()<br><br><span class="hljs-keyword">if</span> function == <span class="hljs-string">&quot;open&quot;</span> &#123;<br><span class="hljs-keyword">return</span> t.Open(stub, args)<br>&#125;<br><span class="hljs-keyword">if</span> function == <span class="hljs-string">&quot;delete&quot;</span> &#123;<br><span class="hljs-keyword">return</span> t.Delete(stub, args)<br>&#125;<br><span class="hljs-keyword">if</span> function == <span class="hljs-string">&quot;query&quot;</span> &#123;<br><span class="hljs-keyword">return</span> t.Query(stub, args)<br>&#125;<br><span class="hljs-keyword">if</span> function == <span class="hljs-string">&quot;transfer&quot;</span> &#123;<br><span class="hljs-keyword">return</span> t.Transfer(stub, args)<br>&#125;<br><span class="hljs-keyword">if</span> function == <span class="hljs-string">&quot;r2w2&quot;</span> &#123;<br><span class="hljs-keyword">return</span> t.R2w2(stub, args)<br>&#125;<br><br><span class="hljs-keyword">return</span> shim.Error(ERROR_WRONG_FORMAT)<br>&#125;<br><br><span class="hljs-comment">// open an account, should be [open account money]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *SimpleChaincode)</span></span> Open(stub shim.ChaincodeStubInterface, args []<span class="hljs-type">string</span>) pb.Response &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_WRONG_FORMAT)<br>&#125;<br><br>account := args[<span class="hljs-number">0</span>]<br>money, _ := stub.GetState(account)<br><span class="hljs-keyword">if</span> money != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_ACCOUNT_EXISTING)<br>&#125;<br><br>stub.PutState(account, []<span class="hljs-type">byte</span>(args[<span class="hljs-number">1</span>]))<br><br><span class="hljs-keyword">return</span> shim.Success(<span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// delete an account, should be [delete account]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *SimpleChaincode)</span></span> Delete(stub shim.ChaincodeStubInterface, args []<span class="hljs-type">string</span>) pb.Response &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_WRONG_FORMAT)<br>&#125;<br><br>stub.DelState(args[<span class="hljs-number">0</span>])<br><br><span class="hljs-keyword">return</span> shim.Success(<span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// query current money of the account,should be [query accout]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *SimpleChaincode)</span></span> Query(stub shim.ChaincodeStubInterface, args []<span class="hljs-type">string</span>) pb.Response &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_WRONG_FORMAT)<br>&#125;<br><br>money, _ := stub.GetState(args[<span class="hljs-number">0</span>])<br><br><span class="hljs-keyword">if</span> money == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_ACCOUNT_ABNORMAL)<br>&#125;<br><br><span class="hljs-keyword">return</span> shim.Success(money)<br>&#125;<br><br><span class="hljs-comment">// transfer money from account1 to account2, should be [transfer account1 account2 money]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *SimpleChaincode)</span></span> Transfer(stub shim.ChaincodeStubInterface, args []<span class="hljs-type">string</span>) pb.Response &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_WRONG_FORMAT)<br>&#125;<br>money, _ := strconv.Atoi(args[<span class="hljs-number">2</span>])<br><br>moneyBytes1, _ := stub.GetState(args[<span class="hljs-number">0</span>])<br>moneyBytes2, _ := stub.GetState(args[<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">if</span> moneyBytes1 == <span class="hljs-literal">nil</span> || moneyBytes2 == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_ACCOUNT_ABNORMAL)<br>&#125;<br><br>money1, _ := strconv.Atoi(<span class="hljs-type">string</span>(moneyBytes1))<br>money2, _ := strconv.Atoi(<span class="hljs-type">string</span>(moneyBytes2))<br><span class="hljs-keyword">if</span> money1 &lt; money &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_MONEY_NOT_ENOUGH)<br>&#125;<br><br>money1 -= money<br>money2 += money<br><br>stub.PutState(args[<span class="hljs-number">0</span>], []<span class="hljs-type">byte</span>(strconv.Itoa(money1)))<br>stub.PutState(args[<span class="hljs-number">1</span>], []<span class="hljs-type">byte</span>(strconv.Itoa(money2)))<br><br><span class="hljs-keyword">return</span> shim.Success(<span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// read 2 account and write 2 account, should be [r2w2 account1 account2 account3 account4]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *SimpleChaincode)</span></span> R2w2(stub shim.ChaincodeStubInterface, args []<span class="hljs-type">string</span>) pb.Response &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-number">4</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_WRONG_FORMAT)<br>&#125;<br><br>moneyBytes1, _ := stub.GetState(args[<span class="hljs-number">0</span>])<br>moneyBytes2, _ := stub.GetState(args[<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">if</span> moneyBytes1 == <span class="hljs-literal">nil</span> || moneyBytes2 == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> shim.Error(ERROR_ACCOUNT_ABNORMAL)<br>&#125;<br><br>stub.PutState(args[<span class="hljs-number">2</span>], moneyBytes1)<br>stub.PutState(args[<span class="hljs-number">3</span>], moneyBytes2)<br><br><span class="hljs-keyword">return</span> shim.Success(<span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>shim.Start(<span class="hljs-built_in">new</span>(SimpleChaincode))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-js-模块"><a href="#2-js-模块" class="headerlink" title="2 js 模块"></a>2 js 模块</h2><h3 id="2-1-operation-base-js"><a href="#2-1-operation-base-js" class="headerlink" title="2.1 operation-base.js"></a>2.1 operation-base.js</h3><p>OperationBase 类是一个继承自 WorkloadModuleBase 的基类，它包含了一些方法和属性，用于执行特定操作的性能测试。这些方法包括初始化、断言连接器类型、断言设置、创建连接器请求等。</p><p>这个文件中的 OperationBase 类是 Hyperledger Caliper 性能测试框架的一部分，它提供了一些通用的功能和规范，以便在具体的区块链性能测试模块中执行不同的操作。子类可以继承 OperationBase 并根据需要实现抽象方法，以执行特定操作的性能测试。这有助于在一个统一的框架下执行不同区块链平台的性能测试。</p><h3 id="2-2-simple-state-js"><a href="#2-2-simple-state-js" class="headerlink" title="2.2 simple-state.js"></a>2.2 simple-state.js</h3><p>这个文件中的 SimpleState 类是一个用于管理账户状态的工具，它允许生成新的账户、查询账户和执行账户之间的资金转移。这在性能测试等场景中可能非常有用，因为它可以模拟不同账户之间的交互。</p><ul><li><p>getOpenAccountArguments 方法：用于获取创建新账户所需的参数。每次调用这个方法都会生成一个新的账户，并返回账户名称和初始资金。</p></li><li><p>getQueryArguments 方法：用于获取查询账户所需的参数。它会随机选择一个账户进行查询操作。</p></li><li><p>getTransferArguments 方法：用于获取转账操作所需的参数。它会随机选择两个账户和转账金额。</p></li><li><p>getCopyArguments 方法：用于获取我新加的函数 Copy 的参数。</p></li></ul><h3 id="2-3-open-js"><a href="#2-3-open-js" class="headerlink" title="2.3 open.js"></a>2.3 open.js</h3><p>这个文件定义了一个用于在系统下测试（SUT）中初始化各种账户的工作负载模块 Open。该模块继承了一个通用的操作基类 OperationBase，并使用 SimpleState 类来管理账户状态。通过实现 createSimpleState 和 submitTransaction 方法，这个模块可以模拟打开新账户的操作，并通过 sutAdapter 向 SUT 发送相应的请求。最后，通过导出 createWorkloadModule 函数，其他代码可以轻松地创建并配置该工作负载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OperationBase</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/operation-base&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SimpleState</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/simple-state&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Open</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">OperationBase</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">createSimpleState</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">workerIndex</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">initialMoney</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">moneyToTransfer</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">submitTransaction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> createArgs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleState</span>.<span class="hljs-title function_">getOpenAccountArguments</span>();<br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sutAdapter</span>.<span class="hljs-title function_">sendRequests</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createConnectorRequest</span>(<span class="hljs-string">&#x27;open&#x27;</span>, createArgs));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkloadModule</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Open</span>();<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">createWorkloadModule</span> = createWorkloadModule;<br></code></pre></td></tr></table></figure><ul><li><p>Open 类是一个工作负载模块，它继承了 OperationBase 类，这意味着它继承了 OperationBase 类中定义的方法和属性。这个类的主要功能是执行账户的初始化操作。</p></li><li><p>constructor 方法：这个构造函数调用了 super()，以初始化基类 OperationBase。通常，在派生类的构造函数中，需要首先调用基类的构造函数。</p></li><li><p>createSimpleState 方法：这个方法是在基类 OperationBase 中定义的抽象方法，子类必须实现它。在这个特定的子类中，它被实现为创建一个新的 SimpleState 对象，以便进行账户状态的初始化。</p></li><li><p>submitTransaction 方法：这个方法是特定于 Open 类的方法，用于生成并提交交易以打开新账户。它首先调用 simpleState.getOpenAccountArguments() 来获取创建新账户所需的参数，然后使用 sutAdapter（SUT 适配器）将请求发送到系统下测试中。</p></li></ul><h3 id="2-4-query-js"><a href="#2-4-query-js" class="headerlink" title="2.4 query.js"></a>2.4 query.js</h3><p>这个文件定义了一个用于查询各种账户的工作负载模块 Query。该模块继承了一个通用的操作基类 OperationBase，并使用 SimpleState 类来管理账户状态。通过实现 createSimpleState 和 submitTransaction 方法，这个模块可以模拟查询账户的操作，并通过 sutAdapter 向 SUT 发送相应的请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OperationBase</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/operation-base&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SimpleState</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/simple-state&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Query</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">OperationBase</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">createSimpleState</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> accountsPerWorker = <span class="hljs-variable language_">this</span>.<span class="hljs-property">numberOfAccounts</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalWorkers</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">workerIndex</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">initialMoney</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">moneyToTransfer</span>, accountsPerWorker);<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">submitTransaction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> queryArgs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleState</span>.<span class="hljs-title function_">getQueryArguments</span>();<br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sutAdapter</span>.<span class="hljs-title function_">sendRequests</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createConnectorRequest</span>(<span class="hljs-string">&#x27;query&#x27;</span>, queryArgs));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkloadModule</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Query</span>();<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">createWorkloadModule</span> = createWorkloadModule;<br></code></pre></td></tr></table></figure><ul><li><p>Query 类是一个工作负载模块，它继承了 OperationBase 类，这意味着它继承了 OperationBase 类中定义的方法和属性。这个类的主要功能是执行账户查询操作。</p></li><li><p>constructor 方法：这个构造函数调用了 super()，以初始化基类 OperationBase。通常，在派生类的构造函数中，需要首先调用基类的构造函数。</p></li><li><p>createSimpleState 方法：这个方法是在基类 OperationBase 中定义的抽象方法，子类必须实现它。在这个特定的子类中，它被实现为创建一个新的 SimpleState 对象，以便进行账户状态的查询。它还会计算每个工作者所需的账户数量，以确保查询分布均匀。</p></li><li><p>submitTransaction 方法：这个方法是特定于 Query 类的方法，用于生成并提交查询交易以查询账户。它首先调用 simpleState.getQueryArguments() 来获取执行查询所需的参数，然后使用 sutAdapter（SUT 适配器）将请求发送到系统下测试中。</p></li></ul><h3 id="2-5-transfer-js"><a href="#2-5-transfer-js" class="headerlink" title="2.5 transfer.js"></a>2.5 transfer.js</h3><p>这个文件定义了一个用于在不同账户之间执行资金转移操作的工作负载模块 Transfer。该模块继承了一个通用的操作基类 OperationBase，并使用 SimpleState 类来管理账户状态。通过实现 createSimpleState 和 submitTransaction 方法，这个模块可以模拟账户之间的资金转移操作，并通过 sutAdapter 向 SUT 发送相应的请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OperationBase</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/operation-base&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SimpleState</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils/simple-state&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transfer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">OperationBase</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">createSimpleState</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> accountsPerWorker = <span class="hljs-variable language_">this</span>.<span class="hljs-property">numberOfAccounts</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalWorkers</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">workerIndex</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">initialMoney</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">moneyToTransfer</span>, accountsPerWorker);<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">submitTransaction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> transferArgs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">simpleState</span>.<span class="hljs-title function_">getTransferArguments</span>();<br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sutAdapter</span>.<span class="hljs-title function_">sendRequests</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createConnectorRequest</span>(<span class="hljs-string">&#x27;transfer&#x27;</span>, transferArgs));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkloadModule</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transfer</span>();<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">createWorkloadModule</span> = createWorkloadModule;<br></code></pre></td></tr></table></figure><ul><li><p>Transfer 类是一个工作负载模块，它继承了 OperationBase 类，这意味着它继承了 OperationBase 类中定义的方法和属性。这个类的主要功能是执行资金转移操作。</p></li><li><p>constructor 方法：这个构造函数调用了 super()，以初始化基类 OperationBase。通常，在派生类的构造函数中，需要首先调用基类的构造函数。</p></li><li><p>createSimpleState 方法：这个方法是在基类 OperationBase 中定义的抽象方法，子类必须实现它。在这个特定的子类中，它被实现为创建一个新的 SimpleState 对象，以便进行账户状态的转账。它还会计算每个工作者所需的账户数量，以确保转账分布均匀。</p></li><li><p>submitTransaction 方法：这个方法是特定于 Transfer 类的方法，用于生成并提交资金转移交易。它首先调用 simpleState.getTransferArguments() 来获取执行资金转移所需的参数，然后使用 sutAdapter（SUT 适配器）将请求发送到系统下测试中。</p></li></ul><h2 id="3-config-yaml"><a href="#3-config-yaml" class="headerlink" title="3 config.yaml"></a>3 config.yaml</h2><p>测试的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">simpleArgs:</span> <span class="hljs-string">&amp;simple-args</span><br>  <span class="hljs-attr">initialMoney:</span> <span class="hljs-number">10000</span><br>  <span class="hljs-attr">moneyToTransfer:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">numberOfAccounts:</span> <span class="hljs-string">&amp;number-of-accounts</span> <span class="hljs-number">1000</span><br><br><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">simple</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">&gt;-</span><br><span class="hljs-string">    This is an example benchmark for Caliper, to test the backend DLT&#x27;s</span><br><span class="hljs-string">    performance with simple account opening &amp; querying transactions.</span><br><span class="hljs-string"></span>  <span class="hljs-attr">workers:</span><br>    <span class="hljs-attr">number:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">rounds:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">label:</span> <span class="hljs-string">open</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&gt;-</span><br><span class="hljs-string">        Test description for the opening of an account through the deployed</span><br><span class="hljs-string">        contract.</span><br><span class="hljs-string"></span>      <span class="hljs-attr">txNumber:</span> <span class="hljs-string">*number-of-accounts</span><br>      <span class="hljs-attr">rateControl:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">fixed-rate</span><br>        <span class="hljs-attr">opts:</span><br>          <span class="hljs-attr">tps:</span> <span class="hljs-number">50</span><br>      <span class="hljs-attr">workload:</span><br>        <span class="hljs-attr">module:</span> <span class="hljs-string">benchmarks/scenario/simple/open.js</span><br>        <span class="hljs-attr">arguments:</span> <span class="hljs-string">*simple-args</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">label:</span> <span class="hljs-string">query</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">Test</span> <span class="hljs-string">description</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">query</span> <span class="hljs-string">performance</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">deployed</span> <span class="hljs-string">contract.</span><br>      <span class="hljs-attr">txNumber:</span> <span class="hljs-string">*number-of-accounts</span><br>      <span class="hljs-attr">rateControl:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">fixed-rate</span><br>        <span class="hljs-attr">opts:</span><br>          <span class="hljs-attr">tps:</span> <span class="hljs-number">100</span><br>      <span class="hljs-attr">workload:</span><br>        <span class="hljs-attr">module:</span> <span class="hljs-string">benchmarks/scenario/simple/query.js</span><br>        <span class="hljs-attr">arguments:</span> <span class="hljs-string">*simple-args</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">label:</span> <span class="hljs-string">transfer</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">Test</span> <span class="hljs-string">description</span> <span class="hljs-string">for</span> <span class="hljs-string">transfering</span> <span class="hljs-string">money</span> <span class="hljs-string">between</span> <span class="hljs-string">accounts.</span><br>      <span class="hljs-attr">txNumber:</span> <span class="hljs-number">50</span><br>      <span class="hljs-attr">rateControl:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">fixed-rate</span><br>        <span class="hljs-attr">opts:</span><br>          <span class="hljs-attr">tps:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">workload:</span><br>        <span class="hljs-attr">module:</span> <span class="hljs-string">benchmarks/scenario/simple/transfer.js</span><br>        <span class="hljs-attr">arguments:</span><br>          <span class="hljs-string">&lt;&lt;</span> <span class="hljs-string">:</span> <span class="hljs-string">*simple-args</span><br>          <span class="hljs-attr">money:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><ul><li><p><code>simpleArgs: &amp;simple-args</code>：定义了一个命名的数据结构 simple-args，它包含了一些初始参数值。</p></li><li><p>workers：指定了测试中工作人员（或并发用户）的数量，这里是 1。</p></li><li><p>rounds：这是测试的轮次配置，包括多个轮次的描述。每个轮次测试不同的操作。</p><ul><li><p>label：轮次的名称或标签。</p></li><li><p>description：轮次的描述。</p></li><li><p>txNumber：执行事务的数量。</p></li><li><p>rateControl：控制事务执行的速率。</p></li><li><p>workload：指定了执行测试操作的工作负载模块和参数。</p><ul><li>module：指定了要使用的工作负载模块的路径。</li><li>arguments：指定了传递给工作负载模块的参数。在这里，使用了 YAML 锚点来引用之前定义的参数。</li></ul></li></ul></li></ul><h2 id="4-test-network-yaml"><a href="#4-test-network-yaml" class="headerlink" title="4 test-network.yaml"></a>4 test-network.yaml</h2><p>这个配置文件的主要目的是为 Caliper 基准测试工具提供有关要执行的性能测试的信息，包括测试的通道、智能合约、参与组织和连接配置等。它使您能够定义测试环境和参数，以便执行性能测试并评估区块链系统的性能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Caliper</span> <span class="hljs-string">Benchmarks</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><br><br><span class="hljs-attr">caliper:</span><br>  <span class="hljs-attr">blockchain:</span> <span class="hljs-string">fabric</span><br><br><span class="hljs-attr">channels:</span><br>  <span class="hljs-comment"># channelName of mychannel matches the name of the channel created by test network</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">channelName:</span> <span class="hljs-string">mychannel</span><br>    <span class="hljs-comment"># the chaincodeIDs of all the fabric chaincodes in caliper-benchmarks</span><br>    <span class="hljs-attr">contracts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">fabcar</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">fixed-asset</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">marbles</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">simple</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">smallbank</span><br><br><span class="hljs-attr">organizations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">mspid:</span> <span class="hljs-string">Org1MSP</span><br>    <span class="hljs-comment"># Identities come from cryptogen created material for test-network</span><br>    <span class="hljs-attr">identities:</span><br>      <span class="hljs-attr">certificates:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;User1&#x27;</span><br>        <span class="hljs-attr">clientPrivateKey:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;../twoPeerNet/crypto-config/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/keystore/priv_sk&#x27;</span><br>        <span class="hljs-attr">clientSignedCert:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;../twoPeerNet/crypto-config/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/signcerts/User1@org1.example.com-cert.pem&#x27;</span><br>    <span class="hljs-attr">connectionProfile:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;../twoPeerNet/crypto-config/peerOrganizations/org1.example.com/connection-org1.yaml&#x27;</span><br>      <span class="hljs-attr">discover:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Redis</title>
    <link href="/Note-Redis/"/>
    <url>/Note-Redis/</url>
    
    <content type="html"><![CDATA[<p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-Redis-的优势"><a href="#1-1-Redis-的优势" class="headerlink" title="1.1 Redis 的优势"></a>1.1 Redis 的优势</h3><ul><li><p>高性能：假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p></li><li><p>高并发：单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数）是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10 w，而 MySQL 单机的 QPS 很难破 1 w。所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p></li></ul><h3 id="1-2-Redis-与-Memcached"><a href="#1-2-Redis-与-Memcached" class="headerlink" title="1.2 Redis 与 Memcached"></a>1.2 Redis 与 Memcached</h3><ul><li>Redis 支持的数据类型更丰富，而 Memcached 只支持最简单的 key-value 数据类型；</li><li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。</li></ul><h3 id="1-3-Redis-线程模型"><a href="#1-3-Redis-线程模型" class="headerlink" title="1.3 Redis 线程模型"></a>1.3 Redis 线程模型</h3><p>Redis 单线程指的是 <code>接收客户端请求 -&gt; 解析请求 -&gt; 进行数据读写等操作 -&gt; 发送数据给客户端</code> 这个过程是由一个线程（主线程）来完成的，这也是常说 Redis 是单线程的原因。</p><p>但是 Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程（BIO）用于关闭文件、AOF 刷盘、异步释放 Redis 内存等操作。</p><p>之所以 Redis 采用单线程（网络 I&#x2F;O 和执行命令）那么快，有如下几个原因：</p><ul><li>Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了。</li><li>Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了 I&#x2F;O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ul><p>为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理</strong>。</p><h3 id="1-4-Redis-过期删除"><a href="#1-4-Redis-过期删除" class="headerlink" title="1.4 Redis 过期删除"></a>1.4 Redis 过期删除</h3><p>Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p><strong>过期删除策略</strong>：</p><ul><li><p>定时过期：每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p></li><li><p>惰性过期：只有当客户端访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</p></li><li><p>定期过期：每隔一段时间<strong>随机</strong>从数据库中取出一定数量的 key 进行检查，并删除其中的过期 key。如果过期的 key 与随机抽取总数的比值大于某数，则再次执行定期过期删除。Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25 ms。</p><p>  该策略通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。但是难以确定删除操作执行的时长和频率：如果执行的太频繁，就会对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</p></li></ul><p>Redis 选择「惰性删除+定期删除」这两种策略配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><h3 id="1-5-Redis-内存淘汰"><a href="#1-5-Redis-内存淘汰" class="headerlink" title="1.5 Redis 内存淘汰"></a>1.5 Redis 内存淘汰</h3><p>Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><ul><li><p>全局的键空间选择性移除</p><ul><li>noeviction：不进行数据淘汰，新写入操作会报错。</li><li>allkeys-random：随机移除某个 key。</li><li>allkeys-lru：通过 LRU 算法驱逐最久没有使用的键。</li><li>allkeys-lfu：通过 LFU 算法驱逐使用频率最少的键。</li></ul></li><li><p>设置过期时间的键空间选择性移除</p><ul><li>volatile-random：在设置了过期时间的键空间中，随机移除某个 key。</li><li>volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li><li>volatile-lru：在设置了过期时间的键空间中，移除最久没有使用的 key。</li><li>volatile-lfu：从所有配置了过期时间的键中，驱逐使用频率最少的键。</li></ul></li></ul><h4 id="LRU-与-LFU"><a href="#LRU-与-LFU" class="headerlink" title="LRU 与 LFU"></a>LRU 与 LFU</h4><p>传统 LRU（Least Recently Used）算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><p>Redis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。</p><p>但是 LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p><p>LFU（Least Frequently Used）算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p><h3 id="1-6-Redis-缓存设计"><a href="#1-6-Redis-缓存设计" class="headerlink" title="1.6 Redis 缓存设计"></a>1.6 Redis 缓存设计</h3><h4 id="1-6-1-缓存雪崩"><a href="#1-6-1-缓存雪崩" class="headerlink" title="1.6.1 缓存雪崩"></a>1.6.1 缓存雪崩</h4><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p><p><img src="/Note-Redis/7.png"></p><p>那么，当<strong>大量缓存数据在同一时间过期（失效）</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p><strong>解决方案</strong>：</p><ul><li>将缓存失效时间随机打散： 我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。</li><li>设置缓存不过期： 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。</li></ul><h4 id="1-6-2-缓存击穿"><a href="#1-6-2-缓存击穿" class="headerlink" title="1.6.2 缓存击穿"></a>1.6.2 缓存击穿</h4><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><strong>解决方案</strong>：</p><ul><li>互斥锁方案：保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间：由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间。</li></ul><h4 id="1-6-3-缓存穿透"><a href="#1-6-3-缓存穿透" class="headerlink" title="1.6.3 缓存穿透"></a>1.6.3 缓存穿透</h4><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。这种情况一般是业务误操作或黑客恶意攻击。</p><p><strong>解决方案</strong>：</p><ul><li>非法请求的限制：在 API 入口处判断求请求参数是否合理，是否含有非法值、字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li><li>设置空值或者默认值：针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li><li>使用布隆过滤器：通过查询布隆过滤器快速判断数据是否存在。</li></ul><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h2><p>Redis 提供了丰富的数据类型，常见的有五种：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p><img src="/Note-Redis/1.png"></p><h3 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h3><p>字符串</p><h3 id="2-2-Hash"><a href="#2-2-Hash" class="headerlink" title="2.2 Hash"></a>2.2 Hash</h3><p>哈希</p><h3 id="2-3-List"><a href="#2-3-List" class="headerlink" title="2.3 List"></a>2.3 List</h3><p>列表</p><h3 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h3><p>集合</p><h3 id="2-5-Zset"><a href="#2-5-Zset" class="headerlink" title="2.5 Zset"></a>2.5 Zset</h3><p>有序集合</p><h2 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3 持久化"></a>3 持久化</h2><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，Redis 共有三种数据持久化的方式：</p><ol><li>AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里</li><li>RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘</li><li>混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点</li></ol><ul><li>AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。</li><li>AOF 比 RDB 更安全，但 AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>RDB 性能比 AOF 好，数据集大的时候，AOF 比 RDB 启动效率低。</li><li>当两种方式同时开启时，数据恢复 Redis 会优先选择 AOF 恢复。</li></ul><h3 id="3-1-AOF"><a href="#3-1-AOF" class="headerlink" title="3.1 AOF"></a>3.1 AOF</h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><p><img src="/Note-Redis/2.png"></p><p><strong>为什么先执行命令，再把数据写入日志？</strong></p><ul><li>避免额外的检查开销：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题又不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li>不会阻塞当前写操作命令的执行：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p>当然，这样做也会带来风险：</p><ul><li>数据可能会丢失： 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li>可能阻塞其他操作： 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><h4 id="3-1-1-写回策略"><a href="#3-1-1-写回策略" class="headerlink" title="3.1.1 写回策略"></a>3.1.1 写回策略</h4><p>Redis 执行完写操作命令后，会将命令追加到缓冲区；然后通过 write() 系统调用，将缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</p><p>Redis 提供了 3 种写回硬盘的策略：</p><ul><li>Always：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li>Everysec：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li>No：意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><h4 id="3-1-2-重写机制"><a href="#3-1-2-重写机制" class="headerlink" title="3.1.2 重写机制"></a>3.1.2 重写机制</h4><p>Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p><img src="/Note-Redis/3.png"></p><p>举个例子，在没有使用重写机制前，假设前后执行了「set name xiaolin」和「set name xiaolincoding」这两个命令的话，就会将这两个命令记录到 AOF 文件。但是在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p><p>Redis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的：</p><ul><li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li><li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li></ul><h3 id="3-2-RDB"><a href="#3-2-RDB" class="headerlink" title="3.2 RDB"></a>3.2 RDB</h3><p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志。在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><p>Redis 的快照是全量快照，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行 save 命令，会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程；</li><li>执行 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞。</li></ul><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><h2 id="4-集群"><a href="#4-集群" class="headerlink" title="4 集群"></a>4 集群</h2><p>要想设计一个<strong>高可用</strong>的 Redis 服务，一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群。</p><h3 id="4-1-主从复制"><a href="#4-1-主从复制" class="headerlink" title="4.1 主从复制"></a>4.1 主从复制</h3><p>主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。</p><p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p><p><img src="/Note-Redis/4.png"></p><p>主从服务器之间的命令复制是异步进行的。</p><p>具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了，无法实现强一致性保证。</p><h3 id="4-2-哨兵模式"><a href="#4-2-哨兵模式" class="headerlink" title="4.2 哨兵模式"></a>4.2 哨兵模式</h3><p>哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。</p><p><img src="/Note-Redis/5.png"></p><h3 id="4-3-切片集群"><a href="#4-3-切片集群" class="headerlink" title="4.3 切片集群"></a>4.3 切片集群</h3><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p><ol><li>根据键值对的 key，按照 CRC16 算法 (opens new window)计算一个 16 bit 的值。</li><li>再用 16 bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ol><p><img src="/Note-Redis/6.png"></p><h3 id="4-4-集群脑裂"><a href="#4-4-集群脑裂" class="headerlink" title="4.4 集群脑裂"></a>4.4 集群脑裂</h3><p>在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p><p>这时，哨兵发现主节点失联了，它就认为主节点挂了，于是哨兵就会在从节点中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— 脑裂出现了。</p><p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点，然后从节点会向新主节点请求数据同步，因为第一次同步是全量同步的方式，此时的从节点会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题。</p><p><strong>解决方案</strong>：当主节点发现从节点下线或者通信超时的总数量大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Kubernetes</title>
    <link href="/Note-Kubernetes/"/>
    <url>/Note-Kubernetes/</url>
    
    <content type="html"><![CDATA[<p>Kubernetes 是一个用于自动化部署、扩展和管理容器化应用程序的容器编排平台。它的目标是处理大规模、高可用性的分布式系统。保证应用业务高峰并发时的高可用性；业务低峰时回收资源，以最小成本运行服务。为多个容器提供服务发现和负载均衡，使得用户无需考虑容器 IP 问题。</p><span id="more"></span><h2 id="1-k8s-简介"><a href="#1-k8s-简介" class="headerlink" title="1 k8s 简介"></a>1 k8s 简介</h2><h3 id="1-1-主要特性："><a href="#1-1-主要特性：" class="headerlink" title="1.1 主要特性："></a>1.1 主要特性：</h3><ul><li>高可用，不宕机，自动灾难恢复</li><li>灰度更新，不影响业务正常运转</li><li>一键回滚到历史版本</li><li>方便的伸缩扩展（应用伸缩，机器加减）、提供负载均衡</li><li>完善的生态</li></ul><h3 id="1-2-不同的应用部署方案："><a href="#1-2-不同的应用部署方案：" class="headerlink" title="1.2 不同的应用部署方案："></a>1.2 不同的应用部署方案：</h3><p><img src="/Note-Kubernetes/1.png"></p><ul><li><p><strong>传统部署方式</strong>：应用直接在物理机上部署，机器资源分配不好控制，出现 Bug 时，可能机器的大部分资源被某个应用占用，导致其他应用无法正常运行，无法做到应用隔离。</p></li><li><p><strong>虚拟机部署</strong>：在单个物理机上运行多个虚拟机，每个虚拟机都是完整独立的系统，性能损耗大。</p></li><li><p><strong>容器部署</strong>：所有容器共享主机的系统，轻量级的虚拟机，性能损耗小，资源隔离，CPU 和内存可按需分配</p></li></ul><p>当你的应用只是跑在一台机器，直接一个 docker + docker-compose 就够了，方便轻松；</p><p>当你的应用需要跑在 3，4 台机器上，你依旧可以每台机器单独配置运行环境 + 负载均衡器；</p><p>但是当你应用访问数不断增加，机器逐渐增加到十几台、上百台、上千台时，每次加机器、软件更新、版本回滚，都会变得非常麻烦，这时候 Kubernetes 就可以一展身手了，可以为你提供集中式的管理集群机器和应用，加机器、版本升级、版本回滚、不停机的灰度更新，确保高可用、高性能、高扩展。</p><h2 id="2-k8s-集群"><a href="#2-k8s-集群" class="headerlink" title="2 k8s 集群"></a>2 k8s 集群</h2><p><img src="/Note-Kubernetes/2.png"></p><ul><li><p><strong>master</strong>：主节点，控制平台，不需要很高性能，不跑任务，通常一个就行了，也可以开多个主节点来提高集群可用度。</p></li><li><p><strong>worker</strong>：工作节点，可以是虚拟机或物理计算机，任务都在这里跑，机器性能需要好点；通常都有很多个，可以不断加机器扩大集群；每个工作节点由主节点管理。</p></li><li><p><strong>pod</strong>：k8s 调度、管理的最小单位，一个 pod 可以包含一个或多个容器，每个 pod 有自己的虚拟 IP。一个工作节点可以有多个 pod，主节点会考量负载自动调度 pod 到某个节点运行。</p></li><li><p><strong>deployment</strong>：包含由模板和副本数（要运行的模板数量）定义的 pod 集合。如果我们有一个 deployment，其副本数为 10，其中 3 个 pod 由于机器故障而崩溃，这 3 个 pod 将会在集群中的其他机器上被调度运行起来。</p></li><li><p><strong>service</strong>：提供一个稳定的端点，它可以用来将流量定向到所需的 pod 上，即使底层 pod 由于更新、扩展和故障而发生变化。service 基于在 pod 清单文件元数据中定义的标签（键值对）知道应该向哪些 pod 发送流量。</p></li></ul><p><img src="/Note-Kubernetes/3.png"></p><p><strong>pod 的生命周期</strong>：</p><table><thead><tr><th>Phase</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>Kubernetes 已经创建并确认该 pod。此时可能有两种情况：1. pod 还未完成调度（例如没有合适的节点）；2. 正在从 docker registry 下载镜像</td></tr><tr><td>Running</td><td>该 pod 已经被绑定到一个节点，并且该 pod 所有的容器都已经成功创建。其中至少有一个容器正在运行，或者正在启动&#x2F;重启</td></tr><tr><td>Succeeded</td><td>pod 中的所有容器都已经成功终止，并且不会再被重启</td></tr><tr><td>Failed</td><td>pod 中的所有容器都已经终止，至少一个容器终止于失败状态：退出码不是 0，或者被系统 kill</td></tr><tr><td>Unknown</td><td>因为某些未知原因，不能确定 pod 的状态，通常的原因是 master 与 pod 所在节点之间的通信故障</td></tr></tbody></table><p><strong>为什么要使用 pod，不直接使用容器呢？</strong></p><p>pod 的存在主要是让几个紧密连接的容器之间共享资源，例如 IP 地址，共享存储等信息。如果直接调度容器的话，那么几个容器可能运行在不同的主机上，这样就增加了系统的复杂性。</p><p><strong>为什么不直接在一个容器上运行所有的应用？</strong></p><p>容器运行时（docker 等）无法监控到容器内所有应用的运行状态。每个容器中只运行一个应用程序，可以提高水平伸缩能力、复用性、便于管理其生命周期。</p><h2 id="3-k8s-组件"><a href="#3-k8s-组件" class="headerlink" title="3 k8s 组件"></a>3 k8s 组件</h2><p><img src="/Note-Kubernetes/4.png"></p><ul><li><p><strong>apiserver</strong> 负责接收 k8s 所有请求，所有增删改查和监听操作都交给 apiserver 处理后再提交给 etcd 存储。</p></li><li><p><strong>etcd</strong> 是一个分布式的键值存储系统。存储了 k8s 的关键配置和用户配置，仅 apiserver 才具备读写权限，其他组件必须通过 apiserver 的接口才能读写数据。其内部使用 Raft 协议。</p></li><li><p><strong>scheduler</strong> 是负责资源调度的进程，根据调度算法为新创建的 pod 选择一个合适的 worker 节点。</p></li><li><p><strong>controller-manager</strong> 是 k8s 集群里所有资源对象的自动化控制中心，通过 apiserver 监视集群的状态，确保集群的当前状态是否符合期望。</p></li><li><p><strong>kubelet</strong> 是从节点的监视器，与 master 节点的通讯器。与 apiserver 通信查看分配给该节点的应用程序容器，负责启动 pod 运行分配到节点的应用程序。</p></li><li><p><strong>kube-proxy</strong> 能够让容器跨集群的各个节点相互通信。kube-proxy 处理所有网络问题，例如如何将流量转发到适当的 pod 上，实现负载均衡。</p></li></ul><p>所有的组件都通过 apiserver 交互，将集群的状态存储在 etcd 中。多种组件（通过 apiserver）写入 etcd，以对集群进行更改，集群上的节点（通过 apiserver）监听 etcd，以查看其应该运行的 pod。</p><p><strong>k8s 工作流程</strong>：</p><ol><li>用户通过客户端发送创建 pod 的请求到 master 节点上的 apiserver</li><li>apiserver 会先把相关的请求信息写入到 etcd 中，再找 controller-manager 根据预设的资源模板创建 pod 清单</li><li>然后 controller-manager 会通过 apiserver 去找 scheduler 为新创建的 pod 选择最适合的 worker 节点</li><li>scheduler 会通过调度算法的预选策略和优选策略筛选出最适合的 worker 节点</li><li>然后再通过 apiserver 找到对应的 worker 节点上的 kubelet 去创建和管理 pod</li><li>kubelet 会直接跟容器引擎交互来管理容器的生命周期</li><li>用户通过创建承载在 kube-proxy 上的 service 资源，写入相关的网络规则，实现对 pod 的服务发现和负载均衡</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 14. 输入输出</title>
    <link href="/Algorithm-acm/"/>
    <url>/Algorithm-acm/</url>
    
    <content type="html"><![CDATA[<p>ACM 模板，可参考：<a href="https://ac.nowcoder.com/acm/contest/5657">牛客网 OJ 在线编程常见输入输出练习</a>。</p><span id="more"></span><ul><li><p>Scan 将碰到第一个空格或换行符之前的内容赋值给变量。如果 Scan 中有多个变量，变量值用空格或换行符分割。所以换行和空格是不能存储到变量内的。</p></li><li><p>Scanln 和 Scan 基本相同，唯一区别是当读取多个变量当时候，遇到换行符 Scanln 会直接结束，未读到输入值的变量为零值。</p></li><li><p>Scanf 按照指定格式对输入进行解析。</p></li></ul><h2 id="1-多行输入，每行两个整数"><a href="#1-多行输入，每行两个整数" class="headerlink" title="1 多行输入，每行两个整数"></a>1 多行输入，每行两个整数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        n, _ := fmt.Scan(&amp;a, &amp;b) <span class="hljs-comment">// 返回数据个数 n 和错误</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a + b)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-多组数据，每组第一行为-n，之后输入-n-行两个整数"><a href="#2-多组数据，每组第一行为-n，之后输入-n-行两个整数" class="headerlink" title="2 多组数据，每组第一行为 n，之后输入 n 行两个整数"></a>2 多组数据，每组第一行为 n，之后输入 n 行两个整数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a, b, n <span class="hljs-type">int</span><br>    fmt.Scan(&amp;n)<br>    <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>        fmt.Scan(&amp;a, &amp;b)<br>        fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a + b)<br>        n--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-若干行输入，每行输入两个整数，遇到特定条件终止"><a href="#3-若干行输入，每行输入两个整数，遇到特定条件终止" class="headerlink" title="3 若干行输入，每行输入两个整数，遇到特定条件终止"></a>3 若干行输入，每行输入两个整数，遇到特定条件终止</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span>                    <span class="hljs-comment">// 声明两个整数类型的变量a和b。</span><br>    <span class="hljs-keyword">for</span> &#123;                           <span class="hljs-comment">// 开始一个无限循环。</span><br>        _, err := fmt.Scan(&amp;a, &amp;b)  <span class="hljs-comment">// 从标准输入读取两个整数值，并将它们存储在a和b中。</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;             <span class="hljs-comment">// 如果读取过程中出现错误，</span><br>            <span class="hljs-keyword">break</span>                   <span class="hljs-comment">// 则跳出循环。</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">0</span> &#123;       <span class="hljs-comment">// 如果两个输入都是0，</span><br>            <span class="hljs-keyword">break</span>                   <span class="hljs-comment">// 则同样跳出循环。</span><br>        &#125;<br>        fmt.Println(a + b)          <span class="hljs-comment">// 否则打印这两个数的和。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-若干行输入，遇到-0-终止，每行第一个数为-n，表示本行后面有-n-个数"><a href="#4-若干行输入，遇到-0-终止，每行第一个数为-n，表示本行后面有-n-个数" class="headerlink" title="4 若干行输入，遇到 0 终止，每行第一个数为 n，表示本行后面有 n 个数"></a>4 若干行输入，遇到 0 终止，每行第一个数为 n，表示本行后面有 n 个数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        fmt.Scan(&amp;n)<br>        <span class="hljs-keyword">var</span> sum, a <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>            fmt.Scan(&amp;a)<br>            sum += a<br>            n--<br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, sum)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-输入的第一行包括一个正整数-t，表示数据组数。接下来-t-行，每行一组数据。每行的第一个整数为整数的个数-n"><a href="#5-输入的第一行包括一个正整数-t，表示数据组数。接下来-t-行，每行一组数据。每行的第一个整数为整数的个数-n" class="headerlink" title="5 输入的第一行包括一个正整数 t，表示数据组数。接下来 t 行，每行一组数据。每行的第一个整数为整数的个数 n"></a>5 输入的第一行包括一个正整数 t，表示数据组数。接下来 t 行，每行一组数据。每行的第一个整数为整数的个数 n</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n, t <span class="hljs-type">int</span><br>    fmt.Scan(&amp;t)<br>    <span class="hljs-keyword">for</span> t &gt; <span class="hljs-number">0</span> &#123;<br>        fmt.Scan(&amp;n)<br>        <span class="hljs-keyword">var</span> sum, a <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>            fmt.Scan(&amp;a)<br>            sum += a<br>            n--<br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, sum)<br>        t--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-输入数据有多组，每行表示一组输入数据。每行的第一个整数为整数的个数-n，不知道有多少行"><a href="#6-输入数据有多组，每行表示一组输入数据。每行的第一个整数为整数的个数-n，不知道有多少行" class="headerlink" title="6 输入数据有多组，每行表示一组输入数据。每行的第一个整数为整数的个数 n，不知道有多少行"></a>6 输入数据有多组，每行表示一组输入数据。每行的第一个整数为整数的个数 n，不知道有多少行</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        m, _ := fmt.Scan(&amp;n)<br>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">var</span> sum, a <span class="hljs-type">int</span><br>        <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>            fmt.Scan(&amp;a)<br>            sum += a<br>            n--<br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, sum)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-输入数据有多组，每行表示一组输入数据。每行不定有-n-个整数，空格隔开"><a href="#7-输入数据有多组，每行表示一组输入数据。每行不定有-n-个整数，空格隔开" class="headerlink" title="7 输入数据有多组，每行表示一组输入数据。每行不定有 n 个整数，空格隔开"></a>7 输入数据有多组，每行表示一组输入数据。每行不定有 n 个整数，空格隔开</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    inputs := bufio.NewScanner(os.Stdin)<br>    <span class="hljs-keyword">for</span> inputs.Scan() &#123; <span class="hljs-comment">// 每次读入一行</span><br>        data := strings.Split(inputs.Text(), <span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> data &#123;<br>            val, _ := strconv.Atoi(data[i])<br>            sum += val<br>        &#125;<br>        fmt.Println(sum)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-输入有两行，第一行-n；第二行是-n-个字符串，字符串之间用空格隔开"><a href="#8-输入有两行，第一行-n；第二行是-n-个字符串，字符串之间用空格隔开" class="headerlink" title="8 输入有两行，第一行 n；第二行是 n 个字符串，字符串之间用空格隔开"></a>8 输入有两行，第一行 n；第二行是 n 个字符串，字符串之间用空格隔开</h2><p>输出一行排序后的字符串，空格隔开，无结尾空格</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    in := bufio.NewScanner(os.Stdin)<br>    in.Scan()<br>    <span class="hljs-keyword">for</span> in.Scan()&#123;<br>        str := in.Text()<br>        s := strings.Split(str, <span class="hljs-string">&quot; &quot;</span>)<br>        sort.Strings(s)<br>        fmt.Println(strings.Join(s, <span class="hljs-string">&quot; &quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-多个测试用例，每个测试用例一行。每行通过空格隔开"><a href="#9-多个测试用例，每个测试用例一行。每行通过空格隔开" class="headerlink" title="9 多个测试用例，每个测试用例一行。每行通过空格隔开"></a>9 多个测试用例，每个测试用例一行。每行通过空格隔开</h2><p>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    in := bufio.NewScanner(os.Stdin)<br>    <span class="hljs-keyword">for</span> in.Scan() &#123; <br>        str := in.Text()<br>        s := strings.Split(str, <span class="hljs-string">&quot; &quot;</span>)<br>        sort.Strings(s)<br>        fmt.Println(strings.Join(s, <span class="hljs-string">&quot; &quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-多个测试用例，每个测试用例一行。通过’-’隔开"><a href="#10-多个测试用例，每个测试用例一行。通过’-’隔开" class="headerlink" title="10 多个测试用例，每个测试用例一行。通过’,’隔开"></a>10 多个测试用例，每个测试用例一行。通过’,’隔开</h2><p>对于每组用例输出一行排序后的字符串，用’,’隔开，无结尾空格</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    in := bufio.NewScanner(os.Stdin)<br>    <span class="hljs-keyword">for</span> in.Scan() &#123;<br>        strs := strings.Split(in.Text(), <span class="hljs-string">&quot;,&quot;</span>)<br>        sort.Strings(strs)<br>        fmt.Println(strings.Join(strs, <span class="hljs-string">&quot;,&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 MySQL</title>
    <link href="/Note-MySQL/"/>
    <url>/Note-MySQL/</url>
    
    <content type="html"><![CDATA[<p>MySQL 是最流行的关系型数据库管理系统，在 web 应用方面 MySQL 是最好的 RDBMS（Relational Database Management System，关系数据库管理系统）应用软件之一。</p><span id="more"></span><h2 id="1-基本架构"><a href="#1-基本架构" class="headerlink" title="1 基本架构"></a>1 基本架构</h2><p><img src="/Note-MySQL/1.png" alt="MySQL 基本架构"></p><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p><ul><li><p>Server 层负责建立连接、分析和执行 SQL。所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p></li><li><p>存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p></li></ul><h3 id="1-1-连接器"><a href="#1-1-连接器" class="headerlink" title="1.1 连接器"></a>1.1 连接器</h3><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">mysql -h<span class="hljs-variable">$ip</span> -P<span class="hljs-variable">$port</span> -u<span class="hljs-variable">$user</span> -p<br></code></pre></td></tr></table></figure><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><p>数据库里长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是使用长连接后占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。可以使用定期断开长连接或者客户端主动重置连接的方式释放内存。</p><p>在使用 Spring Boot 框架与 MySQL 数据库建立连接时，通常使用的是连接池，而不是单一的长连接或短连接。连接池是一种管理数据库连接的技术，它可以有效地管理和复用数据库连接，从而提高应用程序的性能和稳定性。</p><h3 id="1-2-查询缓存"><a href="#1-2-查询缓存" class="headerlink" title="1.2 查询缓存"></a>1.2 查询缓存</h3><p>MySQL 拿到一个查询请求（select 语句）后，会先查询缓存。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。</p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p><p><strong>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</strong></p><h3 id="1-3-分析器"><a href="#1-3-分析器" class="headerlink" title="1.3 分析器"></a>1.3 分析器</h3><p>MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><ul><li><p>词法分析：MySQL 会根据你输入的字符串识别出关键字，构建 SQL 语法树。</p></li><li><p>语法分析：根据词法分析的结果，语法解析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法。</p></li></ul><h3 id="1-4-优化器"><a href="#1-4-优化器" class="headerlink" title="1.4 优化器"></a>1.4 优化器</h3><p>优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><h3 id="1-5-执行器"><a href="#1-5-执行器" class="headerlink" title="1.5 执行器"></a>1.5 执行器</h3><p>确定了执行方案后，接下来 MySQL 就真正开始执行语句了，这个工作是由执行器和存储引擎交互完成的。</p><h3 id="1-6-存储"><a href="#1-6-存储" class="headerlink" title="1.6 存储"></a>1.6 存储</h3><p>一张数据库表的数据是保存在 <code>表名字.ibd</code> 的文件里的，这个文件也称为独占表空间文件。表空间由段（segment）、区（extent）、页（page）、行（row）组成，InnoDB 存储引擎的逻辑存储结构大致如下图：</p><p><img src="/Note-MySQL/3.png"></p><ul><li><p><strong>行（row）</strong></p><p>  数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p></li><li><p><strong>页（page）</strong></p><p>  记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>  InnoDB 的数据是按页为单位来读写的，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。默认每个页的大小为 16 KB，也就是最多能保证 16 KB 的连续存储空间。</p></li><li><p><strong>区（extent）</strong></p><p>  InnoDB 存储引擎是用 B+ 树来组织数据的。</p><p>  B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置可能并不是连续的，磁盘查询时就会有大量的随机 I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p><p>  解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p>  在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配。每个区的大小为 1 MB，对于 16 KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了。</p><ul><li>顺序 I&#x2F;O：数据块按顺序访问，磁头移动较少，寻道时间短，适合大文件的读写操作，如视频流媒体、大数据处理等。</li><li>随机 I&#x2F;O：数据块访问无规律，磁头频繁移动，寻道时间长，适合小文件和频繁访问不同数据块的场景，如数据库、文件系统等。</li></ul></li><li><p><strong>段（segment）</strong></p><p>  表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B+ 树的非叶子节点的区的集合</li><li>数据段：存放 B+ 树的叶子节点的区的集合</li><li>回滚段：存放的是回滚数据的区的集合</li></ul></li></ul><h3 id="1-7-Buffer-Pool"><a href="#1-7-Buffer-Pool" class="headerlink" title="1.7 Buffer Pool"></a>1.7 Buffer Pool</h3><p>MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。InnoDB 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。</p><p><img src="/Note-MySQL/11.png"></p><ul><li><p>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取其中的数据，否则再去磁盘中读取。</p></li><li><p>当修改数据时，首先修改 Buffer Pool 中数据所在的页，然后将其设置为脏页，最后由后台线程将脏页写入到磁盘。</p></li></ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16 KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的 16 KB 的大小划分出一个个缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。Buffer Pool 除了缓存索引页和数据页，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><h4 id="如何提高缓存命中率？"><a href="#如何提高缓存命中率？" class="headerlink" title="如何提高缓存命中率？"></a>如何提高缓存命中率？</h4><p>LRU（Least recently used）算法。该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p><ul><li><p>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</p></li><li><p>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</p></li></ul><p><strong>Buffer Pool 里有三种页和链表来管理数据。</strong></p><p><img src="/Note-MySQL/12.png"></p><ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表。</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于 LRU 链表。</li><li>Dirty Page（脏页），表示此页已被使用且已经被修改，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul><h4 id="脏页什么时候会被刷入磁盘？"><a href="#脏页什么时候会被刷入磁盘？" class="headerlink" title="脏页什么时候会被刷入磁盘？"></a>脏页什么时候会被刷入磁盘？</h4><p>引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。</p><p>在脏页还没有刷入磁盘时，MySQL 宕机了也不会丢失数据。InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘</li></ul><h4 id="MySQL-抖⼀下是什么意思？"><a href="#MySQL-抖⼀下是什么意思？" class="headerlink" title="MySQL 抖⼀下是什么意思？"></a>MySQL 抖⼀下是什么意思？</h4><p>InnoDB 导致 MySQL 抖动主要的原因是脏页在刷新到磁盘时，可能会给数据库带来性能开销，导致数据库操作出现了短暂的性能下降或响应变慢的情况。所以，当查询语句在需要内存的时候可能要求淘汰⼀个脏页，或由于刷脏页时会占用大量 IO 资源并影响到了更新语句，都可能是造成业务端感知 MySQL 抖了⼀下的原因。</p><p>在开启了慢 SQL 监控后，如果发现偶尔会出现一些用时稍长的 SQL，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p><h2 id="2-日志模块"><a href="#2-日志模块" class="headerlink" title="2 日志模块"></a>2 日志模块</h2><p>更新语句的流程会涉及到 undo log、redo log、binlog 这三种日志：</p><ul><li>undo log（回滚日志）：是 InnoDB 存储引擎层生成的日志，实现了原子性，主要用于<strong>事务回滚</strong>和 <strong>MVCC</strong></li><li>redo log（重做日志）：是 InnoDB 存储引擎层生成的日志，实现了持久性，主要用于掉电等<strong>故障恢复</strong></li><li>binlog（归档日志）：是 Server 层生成的日志，主要用于<strong>数据备份</strong>和<strong>主从复制</strong></li></ul><h3 id="2-1-undo-log"><a href="#2-1-undo-log" class="headerlink" title="2.1 undo log"></a>2.1 undo log</h3><p>一个事务在执行过程中，在提交事务之前，如果 MySQL 发生了崩溃，可以通过 undo log 回滚到事务之前的数据。</p><p>undo log 是一种用于撤销回退的日志，MySQL 会记录更新前的数据到 undo log 日志文件里面。当事务回滚时，可以利用 undo log 来进行回滚，做与原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据进行 insert 操作。</p><p>另外，undo log 还有一个作用，通过 Read View + undo log 实现 MVCC（多版本并发控制）。</p><p>undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</p><h3 id="2-2-redo-log"><a href="#2-2-redo-log" class="headerlink" title="2.2 redo log"></a>2.2 redo log</h3><p>如果 MySQL 每一次的更新操作都需要写进磁盘，找到对应的记录更新，那么整个过程 IO 成本、查找成本都很高。WAL（Write-Ahead Logging）技术解决了这个问题，它的关键点就是先写日志，再写磁盘。</p><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存。InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候。重做日志文件是以循环写的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p><p>redo log 将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。</p><p><img src="/Note-MySQL/4.png"></p><p>redo log 可以保证即使数据库发生异常重启，之前提交的记录也不会丢失，这个能力称为 crash-safe。</p><p><strong>redo log 与 undo log 的区别</strong>：</p><ul><li>redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值</li><li>undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值</li><li>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务</li><li>事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务</li></ul><h3 id="2-3-binlog"><a href="#2-3-binlog" class="headerlink" title="2.3 binlog"></a>2.3 binlog</h3><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog 文件。</p><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><p><strong>redo log 与 binlog 的区别</strong>：</p><ul><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是”在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 <code>update T set c=c+1 where ID=2</code>。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。因为 redo log 文件是循环写，会边写边擦除日志，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复。</p><p>MySQL 的主从复制依赖于 binlog，复制的过程就是将 binlog 中的数据从主库传输到从库上：</p><ol><li>写入 binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li>同步 binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li>回放 binlog：回放 binlog，并更新存储引擎中的数据。</li></ol><p>在完成主从复制之后，就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p><h4 id="MySQL-主从复制模型"><a href="#MySQL-主从复制模型" class="headerlink" title="MySQL 主从复制模型"></a>MySQL 主从复制模型</h4><ul><li><p>同步复制：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</p></li><li><p>异步复制（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。提交事务和复制这两个流程在不同的线程中独立执行，互不等待。这种模式一旦主库宕机，数据就会发生丢失。</p></li><li><p>半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</p></li></ul><h3 id="2-4-执行一条更新"><a href="#2-4-执行一条更新" class="headerlink" title="2.4 执行一条更新"></a>2.4 执行一条更新</h3><p>具体更新一条记录 <code>update T set c=c+1 where ID=2;</code> 的流程如下：</p><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id&#x3D;2 这一行记录：<ul><li>如果 id&#x3D;2 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器；</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务，InnoDB 层更新记录前，首先要记录相应的 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，为了减少磁盘 I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务两阶段提交。</li></ol><h3 id="2-5-两阶段提交日志"><a href="#2-5-两阶段提交日志" class="headerlink" title="2.5 两阶段提交日志"></a>2.5 两阶段提交日志</h3><p><img src="/Note-MySQL/2.png" alt="update T set c=c+1 where ID=2"></p><p>图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。redo log 的写入拆成了两个步骤：prepare 和 commit，这就是“两阶段提交”。</p><p><strong>两阶段提交是为了让两份日志之间的逻辑一致</strong>。</p><p>binlog 会采用追加写记录所有的逻辑操作，如果 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。当需要恢复到指定的某一秒时，你可以这么做：</p><ol><li>找到最近的一次全量备份，将这个备份恢复到临时库。</li><li>从备份的时间点开始，将备份的 binlog 依次取出来，重放到指定的那个时刻。</li></ol><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash：</p><ul><li><p>先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p></li><li><p>先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了”把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p></li></ul><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3 索引"></a>3 索引</h2><p>数据库索引是数据库管理系统中一个排序的数据结构，包含着对数据表里所有记录的引用指针。以协助快速查询、更新数据库表中数据。如果没有索引，数据库引擎需要扫描整个数据表来找到匹配的记录。而有了索引，数据库引擎可以直接跳到索引中存储的位置，快速定位到匹配的记录，从而大大加快查询速度。</p><ul><li>按「数据结构」分类：B+Tree 索引、Hash 索引、Full-text 索引</li><li>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）</li><li>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引</li><li>按「字段个数」分类：单列索引、联合索引</li></ul><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护</li></ul><p>什么时候适合用索引：</p><ul><li>字段有唯一性限制的，比如商品编码</li><li>经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引</li><li>经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了</li></ul><h3 id="3-1-B-Tree"><a href="#3-1-B-Tree" class="headerlink" title="3.1 B+Tree"></a>3.1 B+Tree</h3><p>B+Tree 是一种多叉树，叶子节点存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</p><p>InnoDB 里的 B+ 树中的每个节点都是一个数据页。</p><p><img src="/Note-MySQL/5.png"></p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以 B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高。</p><p><strong>主键索引</strong>的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；<strong>二级索引</strong>的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</p><p>通常情况下某个查询语句先使用二级索引查询主键值，再去聚簇索引中根据主键获得数据行。这个过程叫作「回表」，要查两个 B+ 树。不过当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</p><ul><li><p><strong>B+Tree vs B-Tree</strong></p><p>  B+Tree 只在叶子节点存储数据，而 B-Tree 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，磁盘 I&#x2F;O 次数更少。</p><p>  另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p></li><li><p><strong>B+Tree vs 二叉树</strong></p><p>  对于有 N 个叶子节点的 B+Tree，其搜索复杂度为 O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>  在实际的应用当中，d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3-4 层左右，也就是说一次数据查询操作只需要做 3-4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p></li><li><p><strong>B+Tree vs Hash</strong></p><p>  Hash 在做等值查询的时候效率很快，搜索复杂度为 O(1)。但是 Hash 表不适合做范围查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p></li></ul><h3 id="3-2-索引优化"><a href="#3-2-索引优化" class="headerlink" title="3.2 索引优化"></a>3.2 索引优化</h3><ol><li><p><strong>前缀索引优化</strong></p><p> 前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p></li><li><p><strong>覆盖索引优化</strong></p><p> 覆盖索引是指在 SQL 查询中，查询所需的所有字段都能在索引的 B+ 树叶子节点上找到的那些索引。通过覆盖索引，查询可以直接从二级索引中获取所需记录，而不需要通过聚簇索引（主键索引）回表查询数据，从而避免了额外的 I&#x2F;O 操作，提高了查询性能。</p><p> 假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？我们可以建立一个联合索引，即「商品 ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p></li><li><p><strong>主键索引自增</strong></p><p> 在 InnoDB 存储引擎中，默认情况下，主键索引是聚簇索引，数据被存储在 B+ 树的叶子节点上。这意味着，同一个叶子节点内的各个数据是按主键顺序存放的。因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p> 如果我们使用自增主键（如 AUTO_INCREMENT），每次插入的新数据都会按顺序添加到当前索引节点的末尾。这种插入方式是纯粹的追加操作，不需要移动已有的数据。当页面写满时，会自动开辟一个新的页面。这种插入数据的方法效率非常高。</p><p> 如果我们使用非自增主键（如 UUID 或其他随机值），每次插入主键的索引值都是随机的。因此，每次插入新的数据时，可能会插入到现有数据页中间的某个位置。这将不得不移动其他数据来为新数据腾出空间，甚至需要从一个页面复制数据到另一个页面，这种情况通常称为页分裂。页分裂不仅会导致大量的内存碎片，使索引结构变得不紧凑，还会影响查询效率。</p></li><li><p><strong>索引 NOT NULL</strong></p><p> 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂。</p><p> NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式（opens new window）中至少会用 1 字节空间存储 NULL 值列表，如下图的紫色部分：</p><p> <img src="/Note-MySQL/6.png"></p></li><li><p><strong>防止索引失效</strong></p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。</li><li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效。</li><li>联合索引需要遵循最左匹配原则，按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul></li></ol><h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4 事务"></a>4 事务</h2><p>在 MySQL 中，事务支持是在引擎层实现的，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是其被 InnoDB 取代的重要原因之一。</p><ul><li><strong>原子性</strong>（Atomicity），事务是不可分割的最小工作单位，事务中的所有操作要么全部成功，要么全部失败；通过 undo log 和回滚机制实现。</li><li><strong>一致性</strong>（Consistency），事务执行前后，数据库必须从一个一致状态转换到另一个一致状态；通过数据库的完整性约束检查和事务管理实现。</li><li><strong>隔离性</strong>（Isolation），事务的执行是独立的，一个事务的执行不应受到其他事务的干扰；通过 MVCC 或锁机制来实现。</li><li><strong>持久性</strong>（Durability），一旦事务提交，其对数据库的更改就是永久的，即使系统发生故障也不会丢失；通过 redo log 和数据页的持久化实现。</li></ul><h3 id="4-1-并行事务的问题"><a href="#4-1-并行事务的问题" class="headerlink" title="4.1 并行事务的问题"></a>4.1 并行事务的问题</h3><ul><li><p><strong>脏读</strong>（dirty read）</p><p>  如果一个事务<strong>读到</strong>了另一个<strong>未提交事务修改过的数据</strong>，就意味着发生了脏读现象。</p><p>  <img src="/Note-MySQL/7.png"></p><p>  假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而正好事务 B 也从数据库中读取余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据。如果事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</p></li><li><p><strong>不可重复读</strong>（non-repeatable read）</p><p>  在一个事务内<strong>多次读取同一个数据</strong>，如果出现前后两次读到的数据不一样的情况，就意味着发生了不可重复读现象。</p><p>  <img src="/Note-MySQL/8.png"></p><p>  事务 A 先开始从数据库中读取余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的。</p></li><li><p><strong>幻读</strong>（phantom read）</p><p>  在一个事务内多次查询某个符合查询条件的<strong>记录数量</strong>，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象。</p><p>  <img src="/Note-MySQL/9.png"></p><p>  事务 B 先从数据库查询账户余额大于 100 万的记录，发现共有 5 条。事务 A 插入了一条余额超过 100 万的账号，并提交了事务。然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条。</p></li></ul><h3 id="4-2-事务的隔离级别"><a href="#4-2-事务的隔离级别" class="headerlink" title="4.2 事务的隔离级别"></a>4.2 事务的隔离级别</h3><ul><li><p><strong>读未提交</strong>（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到。</p></li><li><p><strong>读已提交</strong>（read committed），指一个事务提交之后，它做的变更才能被其他事务看到。</p></li><li><p><strong>可重复读</strong>（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，InnoDB 引擎的默认隔离级别。</p></li><li><p><strong>可序列化</strong>（serializable ），会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p></li></ul><p><img src="/Note-MySQL/10.png"></p><p><strong>这四种隔离级别具体是如何实现的呢？</strong></p><p>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</p><p>对于「可序列化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</p><p>对于「读已提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</p><h3 id="4-3-MVCC"><a href="#4-3-MVCC" class="headerlink" title="4.3 MVCC"></a>4.3 MVCC</h3><p>MVCC 即多版本并发控制，为每个事务创建多个数据版本，每个版本对应一个特定时间点的数据库状态，不同事务可以基于各自的时间点来进行读取和写入操作，而不会相互干扰。</p><p>当前读和快照读是 MVCC 机制下的两种数据读取方法，各自适用于各种不同的应用场景。</p><ul><li><p>当前读（Current Read）</p><ul><li><p>当前读是指事务在读取数据时，总是读取最新提交的数据版本。</p></li><li><p>当前读能够读取其他事务已经提交的数据，同时在当前事务有未提交的修改时，也会读取自己所做的修改，可能会读取到未提交的数据。</p></li><li><p>当前读适用于需要获取最新数据状态的场景，比如，实时查询账户余额。然而，需要注意的是，在并发环境下，当前读可能会引发一致性问题。</p></li></ul></li><li><p>快照读（Snapshot Read）</p><ul><li><p>快照读，也称为一致性读，是指事务在读取数据时，会读取一个事务开始时的数据版本，即创建事务时的快照。</p></li><li><p>快照读仅会读取已提交的数据版本，不会读取其他事务未提交的数据。</p></li><li><p>快照读适用于需要事务隔离和数据一致性的场景。比如，在事务内部进行多次读取操作。</p></li><li><p>快照读能够提供事务开始时的数据一致性视图，避免了并发冲突和未提交数据的影响，但可能不够实时。</p></li></ul></li></ul><p><strong>数据库的三种并发场景：</strong></p><ul><li><p>读 - 读：不存在任何问题，也不需要并发控制；</p></li><li><p>读 - 写：有线程安全问题，事务可能出现隔离性问题，例如脏读、幻读、不可重复读；</p></li><li><p>写 - 写：有线程安全问题，可能存在更新丢失问题。</p></li></ul><p>如果没有 MVCC，读-写之间就必须加锁。锁是一种性能低下的组件。MVCC 就是一种不使用锁，去解决读写冲突问题。</p><p>MVCC 的实现主要依赖于：三个隐藏字段（trx_id、roll_pointer、row_id）、Undo log 及 ReadView。</p><p>不同事务或者相同事务的对同一记录的修改，会导致该记录的 undo log 生成一条记录版本线性表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录。所以，一个记录会被一堆事务进行修改，一个记录中就会存在很多 undo log。</p><p>那对某个事务来说，这么多 undo log，到底应该选择哪些 undo log 执行回滚呢？ReadView 机制就是用来为事务做可见性判断的，它可以判断版本链中的哪个版本是当前事务可见的。</p><p>ReadView 仅仅记录一个事务开始的时候，系统的事务 id 列表和相关的事务信息。</p><p>将要被修改的数据的最新记录中的 DB_TRX_ID（当前事务 id）取出来，与系统当前其他活跃事务的 id 去对比，如果 DB_TRX_ID 跟 Read View 的属性做了比较，不符合可见性，那么就通过 DB_ROLL_PTR 回滚指针去取出 undolog 中的 DB_TRX_ID 做比较，即遍历链表中的 DB_TRX_ID，直到找到满足条件的 DB_TRX_ID，这个 DB_TRX_ID 所在的旧记录，就是当前事务能看到的最新老版本数据。</p><h2 id="5-锁"><a href="#5-锁" class="headerlink" title="5 锁"></a>5 锁</h2><h3 id="5-1-全局锁"><a href="#5-1-全局锁" class="headerlink" title="5.1 全局锁"></a>5.1 全局锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush tables with read lock;<br></code></pre></td></tr></table></figure><p>执行 FTWRL 后，整个数据库就处于只读状态了。如果要释放全局锁，则要执行 <code>unlock tables</code>。</p><p>全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。如果数据库里有很多数据，备份就会花费很多的时间，期间业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><p>如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><h3 id="5-2-表级锁"><a href="#5-2-表级锁" class="headerlink" title="5.2 表级锁"></a>5.2 表级锁</h3><ul><li><p><strong>表锁</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">// 表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br>// 表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br></code></pre></td></tr></table></figure><p>  尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大会影响并发性能，InnoDB 实现了颗粒度更细的行级锁。</p></li><li><p><strong>元数据锁</strong>（MDL）</p><p>  MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做变更。不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 MDL 读锁；</li><li>对一张表做结构变更操作的时候，加的是 MDL 写锁；</li></ul><p>  当有线程在执行 select 语句（加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（释放 MDL 读锁）。</p><p>  反之，当有线程对表结构进行变更（加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（释放 MDL 写锁）。</p></li><li><p><strong>意向锁</strong></p><p>  意向锁的目的是为了快速判断表里是否有记录被加锁。如果没有意向锁，那么加独占表锁时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul></li><li><p><strong>AUTO-INC 锁</strong></p><p>  表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。</p><p>  AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>  但是，AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。因此，在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。</p></li></ul><h3 id="5-3-行级锁"><a href="#5-3-行级锁" class="headerlink" title="5.3 行级锁"></a>5.3 行级锁</h3><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身。只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身</li></ul><h3 id="5-4-死锁"><a href="#5-4-死锁" class="headerlink" title="5.4 死锁"></a>5.4 死锁</h3><p>死锁的四个必要条件：<strong>互斥</strong>、<strong>请求与保持</strong>、<strong>不可抢占</strong>、<strong>环路等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><ol><li><p>互斥条件：一个资源在任意时刻只能被一个进程持有。</p></li><li><p>请求与保持条件：当进程在等待其他资源时，它可以继续持有自己已经获得的资源。</p></li><li><p>不可抢占条件：资源只能由占有它的进程主动释放，而不能被其他进程抢占。</p></li><li><p>环路等待条件：每个进程都在等待下一个进程所占有的资源，形成一个循环等待的环路。</p></li></ol><p>在数据库层面，有两种策略通过打破循环等待条件来解除死锁状态：</p><ol><li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。</p></li><li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。</p></li></ol><h2 id="6-SQL"><a href="#6-SQL" class="headerlink" title="6 SQL"></a>6 SQL</h2><p>SQL（Structured Query Language）指结构化查询语言，可以访问和处理数据库，包括数据插入、查询、更新和删除。</p><ul><li><p>DDL：Data Definition Languages 语句，即数据库定义语句，用来创建数据库中的表、索引、视图、存储过程、触发器等，如 CREATE，ALTER，DROP，TRUNCATE，COMMENT，RENAME。</p></li><li><p>DML：Data Manipulation Language 语句，即数据操作语句，用来查询、添加、更新、删除等，如 SELECT，INSERT，UPDATE，DELETE，MERGE，CALL，LOCK TABLE。</p></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li>SELECT - 从数据库中提取数据</li><li>UPDATE - 更新数据库中的数据</li><li>DELETE - 从数据库中删除数据</li><li>INSERT INTO - 向数据库中插入新数据</li><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><code>SELECT</code> 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。</li><li><code>SELECT DISTINCT</code> 语句用于返回唯一不同的值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure><ul><li><code>WHERE</code> 子句用于提取那些满足指定条件的记录。</li><li><code>LIKE</code> 操作符用于在 <code>WHERE</code> 子句中搜索列中的指定模式。</li><li>通配符（<code>%</code>，<code>_</code>）可用于替代字符串中的任何其他字符。</li><li><code>IN</code> 操作符允许您在 <code>WHERE</code> 子句中规定多个值。</li><li><code>BETWEEN</code>&#x2F;<code>NOT BETWEEN</code> 操作符用于选取介于&#x2F;不介于两个值之间的数据范围内的值。</li><li><code>WHERE</code> 关键字无法与聚合函数一起使用。HAVING 子句可以让我们筛选分组后的各组数据。</li><li><code>WHERE column IS NULL</code> 在 column 值为空时使用。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br><br><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-keyword">pattern</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Websites<br><span class="hljs-keyword">WHERE</span> url <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;https%&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">IN</span> (value1, value2, ...);<br><br><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">BETWEEN</span> value1 <span class="hljs-keyword">AND</span> value2;<br><br><span class="hljs-keyword">SELECT</span> column_name, aggregate_function(column_name)<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> column_name operator <span class="hljs-keyword">value</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column_name<br><span class="hljs-keyword">HAVING</span> aggregate_function(column_name) operator <span class="hljs-keyword">value</span>;<br></code></pre></td></tr></table></figure><ul><li><code>AND</code> &amp; <code>OR</code> 运算符用于基于一个以上的条件对记录进行过滤。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Websites<br><span class="hljs-keyword">WHERE</span> alexa <span class="hljs-operator">&gt;</span> <span class="hljs-number">15</span><br><span class="hljs-keyword">AND</span> (country<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CN&#x27;</span> <span class="hljs-keyword">OR</span> country<span class="hljs-operator">=</span><span class="hljs-string">&#x27;USA&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li><code>ORDER BY</code> 关键字用于对结果集进行排序。</li><li><code>ASC</code> 表示按升序排序；<code>DESC</code> 表示按降序排序。</li><li><code>GROUP BY</code> 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-keyword">SELECT</span> column_name, aggregate_function(column_name)<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> column_name operator <span class="hljs-keyword">value</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column_name;<br></code></pre></td></tr></table></figure><ul><li><code>INSERT INTO</code> 语句用于向表中插入新记录，column 可省略。</li><li><code>SELECT INTO</code> 语句从一个表复制数据，然后把数据插入到另一个新表中。</li><li>MySQL 数据库不支持 <code>SELECT INTO</code> 语句，但支持 <code>INSERT INTO ... SELECT</code>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1,column2,column3,...)<br><span class="hljs-keyword">VALUES</span> (value1,value2,value3,...);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table2<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1;<br></code></pre></td></tr></table></figure><ul><li><code>UPDATE</code> 语句用于更新表中已存在的记录。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2, ...<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>DROP</code> 语句可以删除索引、表和数据库。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><ul><li>SQL <code>JOIN</code> 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</li><li><code>INNER JOIN</code>：如果表中有至少一个匹配，则返回行</li><li><code>LEFT JOIN</code>：即使右表中没有匹配，也从左表返回所有的行</li><li><code>RIGHT JOIN</code>：即使左表中没有匹配，也从右表返回所有的行</li><li><code>FULL JOIN</code>：只要其中一个表中存在匹配，则返回行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">JOIN</span> table2<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><code>AVG()</code> - 返回平均值</li><li><code>COUNT()</code> - 返回行数</li><li><code>FIRST()</code> - 返回第一个记录的值</li><li><code>LAST()</code> - 返回最后一个记录的值</li><li><code>MAX()</code> - 返回最大值</li><li><code>MIN()</code> - 返回最小值</li><li><code>SUM()</code> - 返回总和</li><li><code>LEN()</code> - 返回文本字段中值的长度（MySQL 中使用 <code>LENGTH</code>）</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 13. 动态规划</title>
    <link href="/Algorithm-dp/"/>
    <url>/Algorithm-dp/</url>
    
    <content type="html"><![CDATA[<p>Dynamic Programming，简称 DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><span id="more"></span><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h2><p>动态规划中每一个状态是由上一个状态推导出来的，贪心没有状态推导，是从局部直接选最优的。</p><h3 id="1-1-五步曲"><a href="#1-1-五步曲" class="headerlink" title="1.1 五步曲"></a>1.1 五步曲</h3><ol><li>确定 dp 数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp 数组如何初始化</li><li>确定遍历顺序</li><li>举例推导 dp 数组</li></ol><h3 id="1-2-背包问题"><a href="#1-2-背包问题" class="headerlink" title="1.2 背包问题"></a>1.2 背包问题</h3><p><img src="/Algorithm-dp/1.png"></p><h4 id="1-2-1-0-1-背包"><a href="#1-2-1-0-1-背包" class="headerlink" title="1.2.1 0-1 背包"></a>1.2.1 0-1 背包</h4><p>有 n 件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i]。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p>对于背包问题，有一种写法是使用二维数组，即 dp[i][j] 表示从下标为 [0-i] 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。</p><p><img src="/Algorithm-dp/2.png"></p><p>那么可以有两个方向推出来 dp[i][j]：</p><ol><li>不放物品 i：由 dp[i-1][j] 推出，即背包容量为 j，里面不放物品 i 的最大价值，此时 dp[i][j] 就是 dp[i-1][j]。</li><li>放物品 i：由 dp[i-1][j - weight[i]] 推出，dp[i-1][j-weight[i]] 为背包容量为 j - weight[i] 的时候不放物品 i 的最大价值，那么 dp[i-1][j-weight[i]] + value[i] 就是背包放物品i得到的最大价值。</li></ol><p>递推公式：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])</code></p><p>初始化：</p><p><img src="/Algorithm-dp/3.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bag_problem1</span><span class="hljs-params">(weight, value []<span class="hljs-type">int</span>, bagweight <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 定义 dp 数组</span><br>dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(weight))<br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, bagweight+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> j := bagweight; j &gt;= weight[<span class="hljs-number">0</span>]; j-- &#123;<br>dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>]<br>&#125;<br><span class="hljs-comment">// 递推公式</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(weight); i++ &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= bagweight; j++ &#123;<br>        <span class="hljs-keyword">if</span> j &lt; weight[i] &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-weight[i]]+value[i])<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(weight)<span class="hljs-number">-1</span>][bagweight]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-滚动数组"><a href="#1-2-2-滚动数组" class="headerlink" title="1.2.2 滚动数组"></a>1.2.2 滚动数组</h4><p>滚动数组可以把二维 dp 降为一维 dp。</p><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])</code></p><p>其实可以发现如果把 dp[i-1] 那一层拷贝到 dp[i] 上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</code></p><p>与其把 dp[i-1] 这一层拷贝到 dp[i] 上，不如只用一个一维数组了，只用 dp[j]。</p><p>在一维dp数组中，dp[j] 表示：<strong>容量为 j 的背包，所背的物品价值可以最大为 dp[j]。</strong></p><p>递推公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code></p><p>初始化：都初始化为 0 </p><p>二维 dp 遍历的时候，背包容量是从小到大，而一维 dp 遍历的时候，背包是从大到小。倒序遍历是为了保证物品 i 只被放入一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bag_problem2</span><span class="hljs-params">(weight, value []<span class="hljs-type">int</span>, bagWeight <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, bagWeight+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(weight); i++ &#123;<br><span class="hljs-comment">// 这里必须倒序，区别二维，因为二维 dp 保存了 i 的状态</span><br><span class="hljs-keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123;<br>dp[j] = max(dp[j], dp[j-weight[i]] + value[i])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[bagWeight]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-完全背包"><a href="#1-2-3-完全背包" class="headerlink" title="1.2.3 完全背包"></a>1.2.3 完全背包</h4><p>0-1 背包和完全背包唯一不同就是体现在遍历顺序上，0-1 背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历。</p><p>物品和背包先遍历哪个都可以。</p><ul><li><p>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包。</p></li><li><p>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品。</p></li></ul><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2 题目"></a>2 题目</h2><h3 id="2-1-leetcode-509-题"><a href="#2-1-leetcode-509-题" class="headerlink" title="2.1 leetcode 509 题"></a>2.1 <a href="https://leetcode.cn/problems/fibonacci-number/">leetcode 509 题</a></h3><p>斐波那契数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib1</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib2</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>) <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-leetcode-70-题"><a href="#2-2-leetcode-70-题" class="headerlink" title="2.2 leetcode 70 题"></a>2.2 <a href="https://leetcode.cn/problems/climbing-stairs/">leetcode 70 题</a></h3><p>爬楼梯。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-leetcode-63-题"><a href="#2-3-leetcode-63-题" class="headerlink" title="2.3 leetcode 63 题"></a>2.3 <a href="https://leetcode.cn/problems/unique-paths-ii/">leetcode 63 题</a></h3><p>一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(obstacleGrid))<br>    way := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>]))<br>        <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br>            way = <span class="hljs-number">0</span><br>        &#125;<br>        dp[i][<span class="hljs-number">0</span>] = way<br>    &#125;<br>    way = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp[<span class="hljs-number">0</span>] &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span> &#123;<br>            way = <span class="hljs-number">0</span><br>        &#125;<br>        dp[<span class="hljs-number">0</span>][i] = way<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(obstacleGrid); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>]); j++ &#123;<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span> &#123;<br>                dp[i][j] = <span class="hljs-number">0</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(obstacleGrid)<span class="hljs-number">-1</span>][<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-leetcode-343-题"><a href="#2-4-leetcode-343-题" class="headerlink" title="2.4 leetcode 343 题"></a>2.4 <a href="https://leetcode.cn/problems/integer-break/">leetcode 343 题</a></h3><p>给定一个正整数 n，将其拆分为 k 个正整数的和（k &gt;&#x3D; 2），并使这些整数的乘积最大化。</p><ol><li><p>dp[i]：分拆数字 i，可以得到的最大乘积为 dp[i]。</p></li><li><p>从 1 遍历 j，有两种渠道得到 dp[i]：</p><ul><li>一个是 j * (i - j) 直接相乘</li><li>一个是 j * dp[i - j]，相当于是拆分 (i - j)</li><li>j 是从 1 开始遍历，拆分 j 的情况，在遍历 j 的过程中其实都计算过了。</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;<br>            dp[i] = max(dp[i], max(dp[i-j]*j, (i-j)*j))<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-leetcode-96-题"><a href="#2-5-leetcode-96-题" class="headerlink" title="2.5 leetcode 96 题"></a>2.5 <a href="https://leetcode.cn/problems/unique-binary-search-trees/submissions/">leetcode 96 题</a></h3><p>不同的二叉搜索树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= i<span class="hljs-number">-1</span>; j++ &#123;<br>            dp[i] += dp[j] * dp[i-j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-leetcode-416-题"><a href="#2-6-leetcode-416-题" class="headerlink" title="2.6 leetcode 416 题"></a>2.6 <a href="https://leetcode.cn/problems/partition-equal-subset-sum/">leetcode 416 题</a></h3><p>给你一个只包含正整数的非空数组 nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">var</span> sum, target <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125; <br>    target = sum / <span class="hljs-number">2</span><br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, target + <span class="hljs-number">1</span>) <span class="hljs-comment">// dp[j]: 容量为 j 的背包最多装多少</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := target; j &gt;= nums[i]; j-- &#123;<br>            dp[j] = max(dp[j], dp[j-nums[i]] + nums[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target] == target<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition2</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">var</span> sum, target <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125; <br>    target = sum / <span class="hljs-number">2</span><br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, target + <span class="hljs-number">1</span>) <span class="hljs-comment">// dp[j]: 能否找到和为 j 的数</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := target; j &gt;= nums[i]; j-- &#123;<br>            dp[j] = dp[j] || dp[j-nums[i]]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-leetcode-494-题"><a href="#2-7-leetcode-494-题" class="headerlink" title="2.7 leetcode 494 题"></a>2.7 <a href="https://leetcode.cn/problems/target-sum/">leetcode 494 题</a></h3><p>目标和。</p><p>left 组合 - right 组合 &#x3D; target。</p><p>left + right &#x3D; sum，而 sum 是固定的。right &#x3D; sum - left</p><p>left - (sum - left) &#x3D; target 推导出 left &#x3D; (target + sum) &#x2F; 2 。</p><p>之前都是求容量为j的背包，最多能装多少。本题则是装满有几种方法。其实这就是一个组合问题了。</p><p>dp[j] 表示：填满 j（包括 j）这么大容积的包，有 dp[j] 种方法。</p><p>递推公式：<code>dp[j] += dp[j - nums[i]]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        target = -target<br>    &#125;<br>    <span class="hljs-keyword">if</span> (target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> || target &gt; sum &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    bag := (target + sum) / <span class="hljs-number">2</span> <br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, bag+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := bag; j &gt;= nums[i]; j-- &#123;<br>            dp[j] += dp[j-nums[i]]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[bag]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-leetcode-518-题"><a href="#2-8-leetcode-518-题" class="headerlink" title="2.8 leetcode 518 题"></a>2.8 <a href="https://leetcode.cn/problems/coin-change-ii/">leetcode 518 题</a></h3><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。</p><p>完全背包 + 组合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-type">int</span>, coins []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;<br>            dp[j] += dp[j-coins[i]]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-9-leetcode-377-题"><a href="#2-9-leetcode-377-题" class="headerlink" title="2.9 leetcode 377 题"></a>2.9 <a href="https://leetcode.cn/problems/combination-sum-iv/">leetcode 377 题</a></h3><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>完全背包 + 排列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, target+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= target; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &lt;= i &#123;<br>                dp[i] += dp[i-nums[j]]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-10-leetcode-139-题"><a href="#2-10-leetcode-139-题" class="headerlink" title="2.10 leetcode 139 题"></a>2.10 <a href="https://leetcode.cn/problems/word-break/">leetcode 139 题</a></h3><p>单词拆分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s <span class="hljs-type">string</span>,wordDict []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span>  &#123;<br>wordDictSet := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> wordDict &#123;<br>wordDictSet[w] = <span class="hljs-literal">true</span><br>&#125;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br><span class="hljs-keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]] &#123; <br>dp[i] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-11-leetcode-337-题"><a href="#2-11-leetcode-337-题" class="headerlink" title="2.11 leetcode 337 题"></a>2.11 <a href="https://leetcode.cn/problems/house-robber-iii/">leetcode 337 题</a></h3><p>打劫二叉树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> []<span class="hljs-type">int</span> <br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>        &#125;<br>        dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>        left := dfs(node.Left)<br>        right := dfs(node.Right)<br>        dp[<span class="hljs-number">0</span>] = max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>])<br>        dp[<span class="hljs-number">1</span>] = left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>] + node.Val<br>        <span class="hljs-keyword">return</span> dp<br>    &#125;<br>    res := dfs(root)<br>    <span class="hljs-keyword">return</span> max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>])<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="2-12-leetcode-121-题"><a href="#2-12-leetcode-121-题" class="headerlink" title="2.12 leetcode 121 题"></a>2.12 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">leetcode 121 题</a></h3><p>买卖股票的最佳时机。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DP</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(prices))<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i])<br>        dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -prices[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-comment">// 贪心</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    min := prices[<span class="hljs-number">0</span>]<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-keyword">if</span> prices[i] - min &gt; res &#123;<br>            res = prices[i]-min<br>        &#125;<br>        <span class="hljs-keyword">if</span> min &gt; prices[i] &#123;<br>            min = prices[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-13-leetcode-718-题"><a href="#2-13-leetcode-718-题" class="headerlink" title="2.13 leetcode 718 题"></a>2.13 <a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">leetcode 718 题</a></h3><p>给两个整数数组 nums1 和 nums2，返回两个数组中公共的、长度最长的子数组的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(nums1); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(nums2); j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <br>            res = max(res, dp[i][j])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-14-leetcode-1143-题"><a href="#2-14-leetcode-1143-题" class="headerlink" title="2.14 leetcode 1143 题"></a>2.14 <a href="https://leetcode.cn/problems/longest-common-subsequence/">leetcode 1143 题</a></h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>)<br>    &#125; <br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(text1); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(text2); j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(text1)][<span class="hljs-built_in">len</span>(text2)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-15-leetcode-1035-题"><a href="#2-15-leetcode-1035-题" class="headerlink" title="2.15 leetcode 1035 题"></a>2.15 <a href="https://leetcode.cn/problems/uncrossed-lines/">leetcode 1035 题</a></h3><p>不相交的线。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(nums1); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(nums2); j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums1)][<span class="hljs-built_in">len</span>(nums2)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-16-leetcode-53-题"><a href="#2-16-leetcode-53-题" class="headerlink" title="2.16 leetcode 53 题"></a>2.16 <a href="https://leetcode.cn/problems/maximum-subarray/">leetcode 53 题</a></h3><p>最大子数组和。</p><p>最大连续子数组的和要用一个变量记录下来比较，不连续的子序列则不需要，直接输出 dp 的最后一个值即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    res := nums[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        dp[i] = max(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">if</span> dp[i] &gt; res &#123;<br>            res = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-17-leetcode-72-题"><a href="#2-17-leetcode-72-题" class="headerlink" title="2.17 leetcode 72 题"></a>2.17 <a href="https://leetcode.cn/problems/edit-distance/">leetcode 72 题</a></h3><p>编辑距离。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp[i][j] 表示以下标 i-1 为结尾的字符串 word1，和以下标 j-1 为结尾的字符串 word2，最近编辑距离为 dp[i][j]</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">len</span>(word1); i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125; <br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= <span class="hljs-built_in">len</span>(word2); j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(word1); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(word2); j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(min(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j])+<span class="hljs-number">1</span>, dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(word1)][<span class="hljs-built_in">len</span>(word2)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-18-leetcode-132-题"><a href="#2-18-leetcode-132-题" class="headerlink" title="2.18 leetcode 132 题"></a>2.18 <a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">leetcode 132 题</a></h3><p>分割回文串 II。</p><p>深信服笔试题，我当时用的 dfs 忘记通过多少了（反正力扣上是超时的），后来面试的时候又被拿出来手撕，记录一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCut</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        dp[i] = i<span class="hljs-number">-1</span><br>        j := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j &lt; i &#123;<br>            <span class="hljs-keyword">if</span> isHW(s[j:i]) &#123;<br>                dp[i] = min(dp[i], dp[j]+<span class="hljs-number">1</span>)<br>            &#125;<br>            j++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isHW</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &lt;= j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">if</span> s[i] != s[j] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 12. 贪心算法</title>
    <link href="/Algorithm-greedy/"/>
    <url>/Algorithm-greedy/</url>
    
    <content type="html"><![CDATA[<p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p><span id="more"></span><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h2><p>贪心算法并没有固定的套路。唯一的难点就是如何<strong>通过局部最优，推出整体最优</strong>。</p><p>贪心算法一般分为如下四步：</p><ol><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ol><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2 题目"></a>2 题目</h2><h3 id="2-1-leetcode-376-题"><a href="#2-1-leetcode-376-题" class="headerlink" title="2.1 leetcode 376 题"></a>2.1 <a href="https://leetcode.cn/problems/wiggle-subsequence/">leetcode 376 题</a></h3><p>给你一个整数数组 nums，返回 nums 中作为摆动序列的最长子序列的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>    &#125;<br>    res := <span class="hljs-number">1</span><br>    pre := nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> pre != <span class="hljs-number">0</span> &#123;<br>        res++<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        cur := nums[i] - nums[i<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> pre &gt;= <span class="hljs-number">0</span> &amp;&amp;  cur &lt; <span class="hljs-number">0</span> || pre &lt;= <span class="hljs-number">0</span> &amp;&amp;  cur &gt; <span class="hljs-number">0</span> &#123;<br>            res++<br>            pre = cur<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-leetcode-55-题"><a href="#2-2-leetcode-55-题" class="headerlink" title="2.2 leetcode 55 题"></a>2.2 <a href="https://leetcode.cn/problems/jump-game/">leetcode 55 题</a></h3><p>跳跃游戏。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    cover := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= cover; i++ &#123;<br>        cover = max(cover, nums[i] + i)<br>        <span class="hljs-keyword">if</span> cover &gt;= <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-leetcode-134-题"><a href="#2-3-leetcode-134-题" class="headerlink" title="2.3 leetcode 134 题"></a>2.3 <a href="https://leetcode.cn/problems/gas-station/">leetcode 134 题</a></h3><p>加油站。</p><p>每个加油站的剩余量 rest[i] 为 gas[i] - cost[i]。如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明各个站点的加油站剩油量 rest[i] 相加一定是大于等于零的。</p><p>i 从 0 开始累加 rest[i]，和记为 curSum，一旦 curSum 小于零，说明 [0, i] 区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从 i+1 算起，再从 0 计算 curSum。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas []<span class="hljs-type">int</span>, cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>curSum := <span class="hljs-number">0</span><br>totalSum := <span class="hljs-number">0</span><br>start := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(gas); i++ &#123;<br>curSum += gas[i] - cost[i]<br>totalSum += gas[i] - cost[i]<br><span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span> &#123;<br>start = i+<span class="hljs-number">1</span><br>curSum = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> totalSum &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> start<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-leetcode-135-题"><a href="#2-4-leetcode-135-题" class="headerlink" title="2.4 leetcode 135 题"></a>2.4 <a href="https://leetcode.cn/problems/candy/">leetcode 135 题</a></h3><p>分发糖果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">candy</span><span class="hljs-params">(ratings []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    need := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ratings))<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        need[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// 1. 先从左到右，当右边的大于左边的就加 1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ratings)<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &lt; ratings[i+<span class="hljs-number">1</span>] &#123;<br>            need[i+<span class="hljs-number">1</span>] = need[i] + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 2. 再从右到左，当左边的大于右边的就加 1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(ratings)<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ratings[i<span class="hljs-number">-1</span>] &gt; ratings[i] &#123;<br>            need[i<span class="hljs-number">-1</span>] = max(need[i<span class="hljs-number">-1</span>], need[i]+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 3. 计算总共糖果</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        sum += need[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-leetcode-452-题"><a href="#2-5-leetcode-452-题" class="headerlink" title="2.5 leetcode 452 题"></a>2.5 <a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">leetcode 452 题</a></h3><p>用最少数量的箭引爆气球。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sort.Slice(points, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> points[a][<span class="hljs-number">0</span>] &lt; points[b][<span class="hljs-number">0</span>]<br>    &#125;)<br>    res := <span class="hljs-number">1</span><br>    right := points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(points); i++ &#123;<br>        <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">0</span>] &lt;= right &#123;<br>            right = min(right, points[i][<span class="hljs-number">1</span>])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = points[i][<span class="hljs-number">1</span>]<br>            res++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-leetcode-435-题"><a href="#2-6-leetcode-435-题" class="headerlink" title="2.6 leetcode 435 题"></a>2.6 <a href="https://leetcode.cn/problems/non-overlapping-intervals/">leetcode 435 题</a></h3><p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi]。返回需要移除区间的最小数量，使剩余区间互不重叠。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> intervals[a][<span class="hljs-number">0</span>] &lt; intervals[b][<span class="hljs-number">0</span>]<br>    &#125;)<br>    res := <span class="hljs-number">0</span><br>    right := intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &lt; right &#123;<br>            right = min(right, intervals[i][<span class="hljs-number">1</span>])<br>            res++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = intervals[i][<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-leetcode-763-题"><a href="#2-7-leetcode-763-题" class="headerlink" title="2.7 leetcode 763 题"></a>2.7 <a href="https://leetcode.cn/problems/partition-labels/">leetcode 763 题</a></h3><p>给你一个字符串 s。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partitionLabels</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>    bMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>    b := []<span class="hljs-type">byte</span>(s)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(b); i++ &#123;<br>        bMap[b[i]] = i<br>    &#125;<br>    <span class="hljs-keyword">var</span> maxPos, lenth <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> b &#123;<br>        lenth++<br>        <span class="hljs-keyword">if</span> bMap[v] &gt; maxPos &#123;<br>            maxPos = bMap[v]<br>        &#125;<br>        <span class="hljs-keyword">if</span> i == maxPos &#123;<br>            res = <span class="hljs-built_in">append</span>(res, lenth)<br>            lenth = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-leetcode-968-题"><a href="#2-8-leetcode-968-题" class="headerlink" title="2.8 leetcode 968 题"></a>2.8 <a href="https://leetcode.cn/problems/binary-tree-cameras/">leetcode 968 题</a></h3><p>监控二叉树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(root *TreeNode)</span></span> (res <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 节点状态：0 表示未覆盖，1 表示有监控，2 表示被覆盖</span><br>    <span class="hljs-keyword">var</span> DFS <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span><br>    DFS = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        &#125;<br><br>        left := DFS(node.Left)<br>        right := DFS(node.Right)<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span> &#123;<br>            res++<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> DFS(root) == <span class="hljs-number">0</span> &#123;<br>        res++<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 11. 回溯算法</title>
    <link href="/Algorithm-backtrack/"/>
    <url>/Algorithm-backtrack/</url>
    
    <content type="html"><![CDATA[<p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</p><span id="more"></span><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h2><p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。</p><h3 id="1-1-解决的问题"><a href="#1-1-解决的问题" class="headerlink" title="1.1 解决的问题"></a>1.1 解决的问题</h3><ul><li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li><li>排列问题：N 个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N 皇后，解数独等等</li></ul><h3 id="1-2-回溯法模板"><a href="#1-2-回溯法模板" class="headerlink" title="1.2 回溯法模板"></a>1.2 回溯法模板</h3><ol><li>回溯函数模板返回值以及参数</li><li>回溯函数终止条件</li><li>回溯搜索的遍历过程</li></ol><p><img src="/Algorithm-backtrack/4.png"></p><p>for 循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点<br>        backtracking(路径，选择列表) <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2 题目"></a>2 题目</h2><h3 id="2-1-leetcode-77-题"><a href="#2-1-leetcode-77-题" class="headerlink" title="2.1 leetcode 77 题"></a>2.1 <a href="https://leetcode.cn/problems/combinations/">leetcode 77 题</a></h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按任何顺序返回答案。</p><p>最直接的解法是使用 k 个 for 循环，但是当 k 过大时这个方法显然不适用。所以回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像 for 循环嵌套 k 层让人绝望。</p><p>用树形结构来理解回溯：</p><p><img src="/Algorithm-backtrack/1.png" alt="n = 4, k = 2"></p><p>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。</p><p>图中可以发现n相当于树的宽度，k相当于树的深度。每次搜索到了叶子节点，我们就找到了一个结果。</p><ol><li><strong>递归函数的返回值以及参数</strong></li></ol><p>在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> res  [][]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>函数里一定有两个参数，既然是集合 n 里面取 k 个数，那么 n 和 k 是两个 int 型的参数。</p><p>然后还需要一个参数，为 int 型变量 start，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n]）。start 用于防止出现重复的组合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> backTrace <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k, start <span class="hljs-type">int</span>)</span></span> <br></code></pre></td></tr></table></figure><ol start="2"><li><strong>回溯函数终止条件</strong></li></ol><p>path 这个数组的大小如果达到 k，说明我们找到了一个子集大小为 k 的组合了，在图中 path 存的就是根节点到叶子节点的路径。</p><p><img src="/Algorithm-backtrack/2.png" alt="path"></p><p>此时用 res 二维数组，把 path 保存起来，并终止本层递归。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123; <br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-built_in">copy</span>(tmp, path)<br>    res = <span class="hljs-built_in">append</span>(res, tmp)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意不能直接 <code>append(res, path)</code>，后续修改 path 时会影响到 res。</strong></p><ol start="3"><li><strong>单层搜索的过程</strong></li></ol><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出 for 循环用来横向遍历，递归的过程是纵向遍历。</p><p><img src="/Algorithm-backtrack/3.png" alt="遍历"></p><p>for 循环每次从 start 开始遍历，然后用 path 保存取到的节点 i。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> start &lt;= n &#123;                <span class="hljs-comment">// 控制树的横向遍历</span><br>    path = <span class="hljs-built_in">append</span>(path, start)  <span class="hljs-comment">// 处理节点</span><br>    backTrace(n, k, start + <span class="hljs-number">1</span>)  <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从 i+1 开始</span><br>    path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]   <span class="hljs-comment">// 回溯：撤销处理的节点</span><br>    start++<br>&#125;<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">var</span> backTrace <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b, start <span class="hljs-type">int</span>)</span></span> <br>    backTrace = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b, start <span class="hljs-type">int</span>)</span></span> &#123;       <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == b &#123; <br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, b)<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-comment">// 从 start 开始，不往回走，避免出现重复组合</span><br>        <span class="hljs-keyword">for</span> start &lt;= a &#123;<br>            <span class="hljs-keyword">if</span> a - start + <span class="hljs-number">1</span> &lt; b - <span class="hljs-built_in">len</span>(path) &#123; <span class="hljs-comment">// 剪枝</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            path = <span class="hljs-built_in">append</span>(path, start)<br>            backTrace(a, b, start + <span class="hljs-number">1</span>)<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>            start++<br>        &#125;<br>    &#125;<br><br>    backTrace(n, k, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-leetcode-40-题"><a href="#2-2-leetcode-40-题" class="headerlink" title="2.2 leetcode 40 题"></a>2.2 <a href="https://leetcode.cn/problems/combination-sum-ii/">leetcode 40 题</a></h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。解集不能包含重复的组合。</p><p>这道题的难点在于去重。要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。</p><p><img src="/Algorithm-backtrack/5.png"></p><ul><li><code>used[i - 1] == true</code>，说明同一树枝 candidates[i - 1] 使用过，是进入下一层递归</li><li><code>used[i - 1] == false</code>，说明同一树层 candidates[i - 1] 使用过，是回溯而来的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum2</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sort.Ints(candidates)<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>    used := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(candidates))<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>)</span></span><br>    backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> sum &gt; target &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum == target &#123;<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(candidates); i++ &#123;<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i<span class="hljs-number">-1</span>] &amp;&amp; !used[i<span class="hljs-number">-1</span>] &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            sum += candidates[i]<br>            path = <span class="hljs-built_in">append</span>(path, candidates[i])<br>            used[i] = <span class="hljs-literal">true</span><br>            backtracking(i+<span class="hljs-number">1</span>)<br>            sum -= candidates[i]<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>            used[i] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    backtracking(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-leetcode-131-题"><a href="#2-3-leetcode-131-题" class="headerlink" title="2.3 leetcode 131 题"></a>2.3 <a href="https://leetcode.cn/problems/palindrome-partitioning/">leetcode 131 题</a></h3><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>切割问题本质上和组合问题是一样的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sub <span class="hljs-type">string</span>)</span></span> <br>    backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sub <span class="hljs-type">string</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sub) == <span class="hljs-number">0</span> &#123;<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(path))<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(sub); i++ &#123;<br>            <span class="hljs-keyword">if</span> ifStr(sub[<span class="hljs-number">0</span>:i]) &#123;<br>                path = <span class="hljs-built_in">append</span>(path, sub[<span class="hljs-number">0</span>:i])<br>                backtracking(sub[i:])<br>                path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    backtracking(s)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ifStr</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    b := []<span class="hljs-type">byte</span>(s)<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(b)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">if</span> b[i] != b[j] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-leetcode-90-题"><a href="#2-4-leetcode-90-题" class="headerlink" title="2.4 leetcode 90 题"></a>2.4 <a href="https://leetcode.cn/problems/subsets-ii/">leetcode 90 题</a></h3><p>给你一个整数数组 nums，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sort.Ints(nums)<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>    used := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>)</span></span> <br>    backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>)</span></span> &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>        <span class="hljs-built_in">copy</span>(tmp, path)<br>        res = <span class="hljs-built_in">append</span>(res, tmp)<br><br>        <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &amp;&amp; !used[i<span class="hljs-number">-1</span>] &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            path = <span class="hljs-built_in">append</span>(path, nums[i])<br>            used[i] = <span class="hljs-literal">true</span><br>            backtracking(i+<span class="hljs-number">1</span>)<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>            used[i] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    backtracking(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-leetcode-491-题"><a href="#2-5-leetcode-491-题" class="headerlink" title="2.5 leetcode 491 题"></a>2.5 <a href="https://leetcode.cn/problems/non-decreasing-subsequences/submissions/">leetcode 491 题</a></h3><p>给你一个整数数组 nums，找出并返回所有该数组中不同的递增子序列，数组中可能含有重复元素。</p><p>不能对数组进行排序，在每一层新建一个 map 进行去重。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findSubsequences</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>)</span></span> <br>    backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) &gt;= <span class="hljs-number">2</span> &#123;<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>        &#125;<br><br>        usedmap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>        <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(path) != <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; path[<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]) || usedmap[nums[i]] &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            path = <span class="hljs-built_in">append</span>(path, nums[i])<br>            usedmap[nums[i]] = <span class="hljs-literal">true</span><br>            backtracking(i+<span class="hljs-number">1</span>)<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    backtracking(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-leetcode-47-题"><a href="#2-6-leetcode-47-题" class="headerlink" title="2.6 leetcode 47 题"></a>2.6 <a href="https://leetcode.cn/problems/permutations-ii/submissions/">leetcode 47 题</a></h3><p>给定一个可包含重复数字的序列 nums，按任意顺序返回所有不重复的全排列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permuteUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sort.Ints(nums)<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span> <br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <br>    used := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))<br>    backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums) &#123;<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>            <span class="hljs-comment">// used[i] 表示在上一层用过，!used[i-1] 表示在同一层用过</span><br>            <span class="hljs-keyword">if</span> used[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &amp;&amp; !used[i<span class="hljs-number">-1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            path = <span class="hljs-built_in">append</span>(path, nums[i])<br>            used[i] = <span class="hljs-literal">true</span><br>            backtracking()<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>            used[i] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    backtracking()<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-leetcode-698-题"><a href="#2-7-leetcode-698-题" class="headerlink" title="2.7 leetcode 698 题"></a>2.7 <a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">leetcode 698 题</a></h3><p>给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartitionKSubsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <span class="hljs-keyword">if</span> sum % k != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    target := sum / k<br>    sort.Ints(nums)<br>    used := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start, sum, count <span class="hljs-type">int</span>, used []<span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">bool</span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(start, sum, count <span class="hljs-type">int</span>, used []<span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">if</span> count == k &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum == target &#123;<br>            <span class="hljs-keyword">return</span> dfs(<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, count+<span class="hljs-number">1</span>, used)<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> i := start; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>            <span class="hljs-keyword">if</span> used[i] || sum + nums[i] &gt; target &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125; <br>            used[i] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">if</span> dfs(i<span class="hljs-number">-1</span>, sum+nums[i], count, used) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            used[i] = <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-leetcode-51-题"><a href="#2-8-leetcode-51-题" class="headerlink" title="2.8 leetcode 51 题"></a>2.8 <a href="https://leetcode.cn/problems/n-queens/">leetcode 51 题</a></h3><p>N 皇后。</p><h3 id="2-9-leetcode-37-题"><a href="#2-9-leetcode-37-题" class="headerlink" title="2.9 leetcode 37 题"></a>2.9 <a href="https://leetcode.cn/problems/sudoku-solver/">leetcode 37 题</a></h3><p>解数独。</p><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3 递归"></a>3 递归</h2><p>在这里整理几道不是二叉树的递归题目。</p><h3 id="3-1-合并两个有序链表"><a href="#3-1-合并两个有序链表" class="headerlink" title="3.1 合并两个有序链表"></a>3.1 <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h3><p>合并两个排序的链表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> l1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> l2<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> l1<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> l *ListNode<br>    <span class="hljs-keyword">if</span> l1.Val &lt;= l2.Val &#123;<br>        l = l1<br>        l1 = l1.Next<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        l = l2<br>        l2 = l2.Next<br>    &#125;<br>    l.Next = mergeTwoLists(l1, l2)<br>    <span class="hljs-keyword">return</span> l<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-字节面试题"><a href="#3-2-字节面试题" class="headerlink" title="3.2 字节面试题"></a>3.2 字节面试题</h3><p>计算字符串表达式，字符串包含数字、括号、加法、乘法，例如：”2+3*(4+5)”。</p><p>递归 + 栈：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateExpression</span><span class="hljs-params">(expr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>stack := []<span class="hljs-type">int</span>&#123;&#125;<br>op := <span class="hljs-string">&#x27;.&#x27;</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(expr); i++ &#123;<br><span class="hljs-keyword">if</span> expr[i] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; expr[i] != <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>num := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> expr[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; expr[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(expr) &amp;&amp; expr[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; expr[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(expr[i]-<span class="hljs-string">&#x27;0&#x27;</span>)<br>i++<br>&#125;<br>i--<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> expr[i] == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br>cnt := <span class="hljs-number">1</span><br>j := i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> cnt &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> expr[j] == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br>cnt++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> expr[j] == <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>cnt--<br>&#125;<br>j++<br>&#125;<br>num = calculateExpression(expr[i+<span class="hljs-number">1</span> : j<span class="hljs-number">-1</span>])<br>i = j - <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>num *= stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] = num<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, num)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> expr[i] == <span class="hljs-string">&#x27;*&#x27;</span> || expr[i] == <span class="hljs-string">&#x27;+&#x27;</span> &#123;<br>op = <span class="hljs-type">rune</span>(expr[i])<br>&#125;<br>&#125;<br><br>result := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> stack &#123;<br>result += val<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-图论"><a href="#4-图论" class="headerlink" title="4 图论"></a>4 图论</h2><p>直接看题吧，参考<a href="https://programmercarl.com/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">卡哥教程</a></p><h3 id="4-1-leetcode-797-题"><a href="#4-1-leetcode-797-题" class="headerlink" title="4.1 leetcode 797 题"></a>4.1 <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">leetcode 797 题</a></h3><p>所有可能的路径。</p><p>使用深度优先搜索遍历图即可，由于题目限制不用考虑环的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allPathsSourceTarget</span><span class="hljs-params">(graph [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br>    dst := <span class="hljs-built_in">len</span>(graph) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node <span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == dst &#123;<br>            path = <span class="hljs-built_in">append</span>(path, dst)<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        path = <span class="hljs-built_in">append</span>(path, node)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(graph[node]); i++ &#123;<br>            nxt := graph[node][i]<br>            dfs(nxt)<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-leetcode-200-题"><a href="#4-2-leetcode-200-题" class="headerlink" title="4.2 leetcode 200 题"></a>4.2 <a href="https://leetcode.cn/problems/number-of-islands/">leetcode 200 题</a></h3><p>岛屿数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 遍历 grid 遇到 &#x27;1&#x27; 就开始递归染色，相连的 &#x27;1&#x27; 都染成 &#x27;0&#x27;</span><br><span class="hljs-comment">// 属于深度优先 dfs</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> mark <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <br>    mark = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>        mark(i<span class="hljs-number">-1</span>, j)<br>        mark(i+<span class="hljs-number">1</span>, j)<br>        mark(i, j<span class="hljs-number">-1</span>)<br>        mark(i, j+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                res++<br>                mark(i, j)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-leetcode-207-题"><a href="#4-3-leetcode-207-题" class="headerlink" title="4.3 leetcode 207 题"></a>4.3 <a href="https://leetcode.cn/problems/course-schedule/">leetcode 207 题</a></h3><p>课程表。</p><p>一道拓扑排序的题，由两种解法：</p><ul><li>BFS，维护一个入度表以及边的信息，每次将入度为 0 的边进行排序，并根据边的信息消除它们对其他顶点入度的影响。</li><li>DFS，维护一个 visited 数组用于标记节点状态：0：未访问；1：搜索中；2：已搜索，若 dfs 中再次搜索到 1 的节点，则判断成环。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// BFS</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    tomap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br>    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        tomap[v[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(tomap[v[<span class="hljs-number">1</span>]], v[<span class="hljs-number">0</span>])<br>        indeg[v[<span class="hljs-number">0</span>]]++<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> numCourses &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">var</span> queue []<span class="hljs-type">int</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(indeg); i++ &#123;<br>            <span class="hljs-keyword">if</span> indeg[i] == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-comment">// 将入度为 0 的顶点加入队列排序</span><br>                queue = <span class="hljs-built_in">append</span>(queue, i)<br>                indeg[i]--<br>            &#125;<br>        &#125;<br>        l := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">if</span> l == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(tomap[queue[i]]); j++ &#123;<br>                <span class="hljs-comment">// 消除入度为 0 的顶点的影响</span><br>                indeg[tomap[queue[i]][j]]--<br>            &#125;<br>        &#125;<br>        numCourses -= l<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// DFS</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    res := <span class="hljs-literal">true</span><br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> visited[n] == <span class="hljs-number">2</span> || !res &#123;<br>            <span class="hljs-keyword">return</span> <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> visited[n] == <span class="hljs-number">1</span> &#123;<br>            res = <span class="hljs-literal">false</span><br>        &#125;<br>        visited[n] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> prerequisites &#123;<br>            <span class="hljs-keyword">if</span> v[<span class="hljs-number">1</span>] == n &#123;<br>                dfs(v[<span class="hljs-number">0</span>])<br>            &#125;<br>        &#125;<br>        visited[n] = <span class="hljs-number">2</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>        <span class="hljs-keyword">if</span> visited[i] == <span class="hljs-number">0</span> &amp;&amp; res &#123;<br>            dfs(i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5 并查集"></a>5 并查集</h2><p>并查集常用来解决连通性问题。当我们需要判断两个元素是否在同一个集合里的时候，就要想到用并查集。</p><p>并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中</li><li>判断两个元素在不在同一个集合</li></ul><h3 id="5-1-leetcode-200-题"><a href="#5-1-leetcode-200-题" class="headerlink" title="5.1 leetcode 200 题"></a>5.1 <a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/">leetcode 200 题</a></h3><p>寻找图中是否存在路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validPath</span><span class="hljs-params">(n <span class="hljs-type">int</span>, edges [][]<span class="hljs-type">int</span>, source <span class="hljs-type">int</span>, destination <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    father := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><br>    <span class="hljs-comment">// 寻根</span><br>    <span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> <br>    find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> father[n] == n &#123; <span class="hljs-keyword">return</span> n &#125;<br>        father[n] = find(father[n]) <span class="hljs-comment">// 路径压缩</span><br>        <span class="hljs-keyword">return</span> father[n]<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 u 和 v 是否找到同一个根</span><br>    <span class="hljs-keyword">var</span> isSame <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> <br>    isSame = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> find(u) == find(v)<br>    &#125;<br><br>    <span class="hljs-comment">// 加入并查集</span><br>    <span class="hljs-keyword">var</span> join <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> <br>    join = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> &#123;<br>        u = find(u)<br>        v = find(v)<br>        <span class="hljs-comment">// 一定要先通过 find 函数寻根再进行关联，不可以写 if find(u) == find(v) &#123; return &#125;</span><br>        <span class="hljs-keyword">if</span> u == v &#123; <span class="hljs-keyword">return</span> &#125;<br>        father[v] = u<br>    &#125;<br><br>    <span class="hljs-comment">// 并查集初始化</span><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> father &#123;<br>        father[i] = i<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> edges &#123;<br>        join(v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> isSame(source, destination)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 10. 排序算法</title>
    <link href="/Algorithm-sort/"/>
    <url>/Algorithm-sort/</url>
    
    <content type="html"><![CDATA[<p>对于常见排序算法的实现。</p><span id="more"></span><p>若经过排序，多个具有相同的关键字的记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><p>堆排序、快速排序、希尔排序、选择排序是不稳定的排序算法，而冒泡排序、插入排序、归并排序是稳定的排序算法。</p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h2><p>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>] &#123;<br>                arr[j], arr[j+<span class="hljs-number">1</span>] = arr[j+<span class="hljs-number">1</span>], arr[j]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：最好情况下为 O(n)，最坏和平均情况下为 O(n^2)。</p><h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2 快速排序"></a>2 快速排序</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，分别对这两部分记录继续进行排序，以达到整个序列有序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    pivot := arr[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">var</span> left, right []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> arr[<span class="hljs-number">1</span>:] &#123;<br>        <span class="hljs-keyword">if</span> num &lt;= pivot &#123;<br>            left = <span class="hljs-built_in">append</span>(left, num)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = <span class="hljs-built_in">append</span>(right, num)<br>        &#125;<br>    &#125;<br>    QuickSort(left)<br>    QuickSort(right)<br>    <span class="hljs-built_in">copy</span>(arr, <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>(left, pivot), right...))<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：最好和平均情况下为 O(nlogn)，最坏情况下为 O(n^2)。</p><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h2><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertionSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        key := arr[i]<br>        j := i - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key &#123;<br>            arr[j+<span class="hljs-number">1</span>] = arr[j]<br>            j--<br>        &#125;<br>        arr[j+<span class="hljs-number">1</span>] = key<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：最好情况下为 O(n)，最坏和平均情况下为 O(n^2)。</p><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h2><p>将待排序的数组分成多个子序列进行排序，逐步减小子序列的间隔，最终将整个数组变为有序。希尔排序的核心思想是利用插入排序在部分有序数组上的高效性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    gap := n / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> gap &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">for</span> i := gap; i &lt; n; i++ &#123;<br>            temp := arr[i]<br>            j := i<br>            <span class="hljs-keyword">for</span> j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp &#123;<br>                arr[j] = arr[j-gap]<br>                j -= gap<br>            &#125;<br>            arr[j] = temp<br>        &#125;<br>        gap /= <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：最好情况下为 O(nlogn)，最坏情况下为 O(n^2)。</p><h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5 选择排序"></a>5 选择排序</h2><p>对数据操作 n-1 轮，每轮找出一个最小（大）值。以此类推，直到所有元素均排序完毕。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SelectionSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++ &#123;<br>        minIdx := i<br>        <span class="hljs-keyword">for</span> j := i+<span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> arr[j] &lt; arr[minIdx] &#123;<br>                minIdx = j<br>            &#125;<br>        &#125;<br>        arr[i], arr[minIdx] = arr[minIdx], arr[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：最好、最坏和平均情况下为 O(n^2)。</p><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6 堆排序"></a>6 堆排序</h2><p>堆排序使用二叉堆数据结构构建最大堆，并逐步将最大值移动到数组的末尾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(arr)<br><br>    <span class="hljs-comment">// 构建最大堆</span><br>    <span class="hljs-keyword">for</span> i := n/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        heapify(arr, n, i)<br>    &#125;<br><br>    <span class="hljs-comment">// 逐个将最大值移到数组末尾</span><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        arr[<span class="hljs-number">0</span>], arr[i] = arr[i], arr[<span class="hljs-number">0</span>]<br>        heapify(arr, i, <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapify</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, n, i <span class="hljs-type">int</span>)</span></span> &#123;<br>    largest := i<br>    left := <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span><br>    right := <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;<br>        largest = left<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;<br>        largest = right<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> largest != i &#123;<br>        arr[i], arr[largest] = arr[largest], arr[i]<br>        heapify(arr, n, largest)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：最好、最坏和平均情况下均为 O(nlogn)。</p><h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h2><p>归并排序的原理其实就是分治法。它首先将数组不断地二分，直到最后每个部分只包含一个数据。然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了。</p><p><img src="/Algorithm-sort/1.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> arr<br>    &#125;<br>    mid := <span class="hljs-built_in">len</span>(arr) / <span class="hljs-number">2</span><br>    left := MergeSort(arr[:mid])<br>    right := MergeSort(arr[mid:])<br>    <span class="hljs-keyword">return</span> merge(left, right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(left, right []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(left)+<span class="hljs-built_in">len</span>(right))<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(left) &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(right) &#123;<br>        <span class="hljs-keyword">if</span> left[i] &lt;= right[j] &#123;<br>            result = <span class="hljs-built_in">append</span>(result, left[i])<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-built_in">append</span>(result, right[j])<br>            j++<br>        &#125;<br>    &#125;<br>    result = <span class="hljs-built_in">append</span>(result, left[i:]...)<br>    result = <span class="hljs-built_in">append</span>(result, right[j:]...)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：最好、最坏和平均情况下均为 O(nlogn)。</p>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 09. 堆结构</title>
    <link href="/Algorithm-heap/"/>
    <url>/Algorithm-heap/</url>
    
    <content type="html"><![CDATA[<p>本文以 <a href="https://leetcode.cn/problems/top-k-frequent-elements/">leetcode 347 题</a>为例，介绍一下堆结构，参考 <a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html">Carl 的教程</a>。</p><span id="more"></span><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p><code>给你一个整数数组 nums 和一个整数 k，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。你所设计算法的时间复杂度必须优于 O(n*logn)，其中 n 是数组大小。</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前 K 个高频元素</li></ol><p>首先统计元素出现的频率，这一类的问题可以使用 map 来进行统计。</p><p>然后是对频率进行排序，这里我们可以使用<strong>优先级队列</strong>。</p><p><strong>堆</strong>就是优先级队列的一种实现。</p><h2 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h2><p>堆是一棵<strong>完全二叉树</strong>，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是<strong>大顶堆</strong>（根节点最大），小于等于左右孩子就是<strong>小顶堆</strong>（根节点最小）。</p><p><img src="/Algorithm-heap/3.png" alt="heap"></p><p>堆本身就是一个数组，因此创建一个数组来创建堆。</p><p><img src="/Algorithm-heap/4.png" alt="存储"></p><p>假设当前元素的索引位置为 i，可以得到规律：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs heap">parent(i) = i/2（取整）<br>left child(i) = 2*i<br>right child(i) = 2*i + 1<br></code></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p><img src="/Algorithm-heap/1.png" alt="插入"></p><p>在完全二叉树中，插入的节点与它的父节点相比，如果比父节点小，就交换它们的位置，再往上和父节点相比，如果比父节点小，再交换位置，直到比父节点大为止。</p><p>在数组中，插入的节点与 n&#x2F;2 位置的节点相比，如果比 n&#x2F;2 位置的节点小，就交换它们的位置，再往前与 n&#x2F;4 位置的节点相比，如果比 n&#x2F;4 位置的节点小，再交换位置，直到比 n&#x2F;(2^x) 位置的节点大为止。</p><p>这就是插入元素时进行的堆化，也叫<strong>自下而上的堆化</strong>。</p><p>插入元素的时间复杂度为 O(log n)。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="/Algorithm-heap/2.png" alt="删除"></p><p>在完全二叉树中，移除根节点首先把最后一个节点放到堆顶，然后与左右子节点中<strong>小</strong>的交换位置（因为是小顶堆），依次往下，直到其比左右子节点都小为止。</p><p>在数组中，把最后一个元素移到下标为 1 的位置，然后与下标为 2 和 3 的位置对比，发现 8 比 2 大，且 2 是 2 和 3 中间最小的，所以与 2 交换位置；然后再下标为 4 和 5 的位置对比，发现 8 比 5 大，且 5 是 5 和 7 中最小的，所以与 5 交换位置，没有左右子节点了，堆化结束。即 <code>parent = child; child = parent*2;</code>。</p><p>这就是删除元素时进行的堆化，也叫<strong>自上而下的堆化</strong>。</p><p>删除元素的时间复杂度为 O(log n)。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此题使用小顶堆，因为要统计最大前 k 个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前 k 个最大元素。</p><p><img src="/Algorithm-heap/5.png" alt="过程"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用 go 标准库给我们提供的 heap，需要实现这些接口定义的方法：</p><ul><li>Len() int</li><li>Less(i, j int) bool</li><li>Swap(i, j int)</li><li>Push(x interface{})</li><li>Pop() interface{}</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法一：小顶堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    map_num := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> nums&#123;<br>        map_num[item]++<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 heap</span><br>    h := &amp;IHeap&#123;&#125;<br>    heap.Init(h)<br>    <span class="hljs-comment">// 所有元素入堆，堆的长度为 k</span><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map_num &#123;<br>        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key, value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            <span class="hljs-comment">// heap.Pop 并非下方定义的 h.Pop</span><br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-comment">// 按顺序返回堆中的元素</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        res[k-i<span class="hljs-number">-1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// 构建小顶堆</span><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len()<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 如果 h[i][1] &lt; h[j][1] 生成的就是小根堆，h[i][1] &gt; h[j][1] 生成的就是大根堆</span><br>    <span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>] &lt; h[j][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    h[i], h[j] = h[j], h[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个解法是先使用 map 存储元素与出现次数，然后将元素放入切片，再按照频率对切片排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法二：利用 O(nlogn) 排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    map_num := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> nums &#123;<br>        map_num[item]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> map_num &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 切片排序</span><br>    sort.Slice(ans, <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-comment">// 第一个参数是：待排序数据</span><br>        <span class="hljs-comment">// 第二个参数是：排序判断方法</span><br>        <span class="hljs-comment">// 返回值：代表 a, b 是否交换，true：交换，false：不交换</span><br>        <span class="hljs-keyword">return</span> map_num[ans[a]] &gt; map_num[ans[b]]<br>        <span class="hljs-comment">// &lt; 是升序；&gt; 是降序</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> ans[:k]<br>&#125;<br></code></pre></td></tr></table></figure><p>当匿名函数返回值为 true 时，表示 a 索引处的元素应该在 b 索引处的元素之前。相反，当返回值为 false 时，表示 a 索引处的元素应该在 b 索引处的元素之后。</p>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(13)：Q &amp; A</title>
    <link href="/ByteDance-13/"/>
    <url>/ByteDance-13/</url>
    
    <content type="html"><![CDATA[<p>思考和总结的一些问题。</p><span id="more"></span><h2 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h2><h4 id="Q：Go-当中同步锁有什么特点，作用是什么"><a href="#Q：Go-当中同步锁有什么特点，作用是什么" class="headerlink" title="Q：Go 当中同步锁有什么特点，作用是什么"></a>Q：Go 当中同步锁有什么特点，作用是什么</h4><p>Go 语言中的同步锁是一种机制，用于控制对共享资源的访问，以确保在同一时间只有一个协程（goroutine）可以访问该资源，从而避免数据竞争和不一致的结果。</p><h4 id="Q：Map-是线程安全（并发安全）的吗"><a href="#Q：Map-是线程安全（并发安全）的吗" class="headerlink" title="Q：Map 是线程安全（并发安全）的吗"></a>Q：Map 是线程安全（并发安全）的吗</h4><p>不是，多个 goroutine 在并发读写同一个 Map 可能会导致数据竞争和不确定的结果。</p><ul><li>读写锁：使用 sync.RWMutex 来保护对 Map 的读写操作。</li><li>分片锁：定义一个长度为 N 的 map 数组和一个长度为 N 的锁数组。使用 hash 函数来计算 key 应该存储在哪个 map 中。然后再对这个 map 进行读写操作。</li><li>sync.Map：Go 语言第三方库实现了并发安全的 Map，可以在多个 goroutine 中并发读写，无需额外的锁保护。</li></ul><h4 id="Q：使用-channel-时需要注意什么"><a href="#Q：使用-channel-时需要注意什么" class="headerlink" title="Q：使用 channel 时需要注意什么"></a>Q：使用 channel 时需要注意什么</h4><ul><li>当尝试从一个 nil 的通道接收数据时，会导致程序的阻塞。</li><li>如果向 nil 的通道发送数据，会导致程序运行时恐慌（panic）。</li><li>当从一个已关闭的通道接收数据时，会获得通道中的零值，如果 buffer 内还有元素未读，则会读到通道内的值。</li><li>如果向已经关闭的通道发送数据，会导致程序运行时恐慌（panic）。</li></ul><h4 id="Q：Go-语言当中-channel-缓冲有什么特点"><a href="#Q：Go-语言当中-channel-缓冲有什么特点" class="headerlink" title="Q：Go 语言当中 channel 缓冲有什么特点"></a>Q：Go 语言当中 channel 缓冲有什么特点</h4><p>无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的。</p><h4 id="Q：goroutine-在什么情况下会被挂起"><a href="#Q：goroutine-在什么情况下会被挂起" class="headerlink" title="Q：goroutine 在什么情况下会被挂起"></a>Q：goroutine 在什么情况下会被挂起</h4><p>channel 堵塞、垃圾回收、sleep 休眠、锁等待、抢占、IO 阻塞。</p><h4 id="Q：goroutine-的通信方式"><a href="#Q：goroutine-的通信方式" class="headerlink" title="Q：goroutine 的通信方式"></a>Q：goroutine 的通信方式</h4><p>可以通过共享内存（变量）加锁的方式来进行通信，但是维护成本较⾼。官方推荐通过 channel 进行通信：</p><ul><li>作为队列存储数据</li><li>阻塞和唤醒 goroutine</li></ul><p>select 搭配 channel 使用，其机制是监听多个 channel，每⼀个 case 都是⼀个事件，⼀旦某个事件就绪（chan 没有堵塞），就会从这些就绪事件中随机选择⼀个去执行，default 用于所有 chan 都堵塞的情况执行。</p><h4 id="Q：Printf-，Sprintf-，和-Fprintf-有什么不同"><a href="#Q：Printf-，Sprintf-，和-Fprintf-有什么不同" class="headerlink" title="Q：Printf()，Sprintf()，和 Fprintf() 有什么不同"></a>Q：Printf()，Sprintf()，和 Fprintf() 有什么不同</h4><ul><li>Printf() 函数用于将格式化的字符串输出到标准输出（控制台）。</li><li>Sprintf() 函数将格式化的字符串保存到一个字符串变量中，而不是输出到标准输出。</li><li>Fprintf() 函数用于将格式化的字符串输出到指定的 io.Writer 接口（文件）。</li></ul><h4 id="Q：数组和切片的区别"><a href="#Q：数组和切片的区别" class="headerlink" title="Q：数组和切片的区别"></a>Q：数组和切片的区别</h4><ul><li><p>固定长度 vs 可变长度：数组具有固定长度，定义时需要指定其长度，而且长度在数组的整个生命周期中保持不变。切片则是对数组的一个动态窗口或视图，长度可以动态改变。</p></li><li><p>值类型 vs 引用类型：数组是值类型，直接存储数据本身。对数组进行赋值或传递给函数时，会进行值的拷贝。切片是引用类型，实际上是对底层数组的引用。对切片进行赋值或传递给函数时，会共享底层数组，而不进行拷贝。</p><ul><li>值传递只会把参数的值复制一份放进对应的函数，两个变量的地址不同，不可相互修改。</li><li>地址传递（引用传递）会将变量本身传入对应的函数，在函数中可以对该变量进行值内容的修改。</li></ul></li><li><p>内存管理：数组在内存中是连续存储的，大小固定，不会随着元素的增加而改变。切片通过指针引用底层数组，可以动态增长和缩减，当切片的长度超过底层数组的容量时，会重新分配更大的底层数组。</p></li></ul><h4 id="Q：Golang-引用类型有哪些"><a href="#Q：Golang-引用类型有哪些" class="headerlink" title="Q：Golang 引用类型有哪些"></a>Q：Golang 引用类型有哪些</h4><p>引用类型是指那些存储了底层数据结构的地址的数据类型。这些类型在赋值或传递参数时不会进行数据复制，而是共享底层数据，因此被称为引用类型。</p><p>包含以下几种：切片、映射（map）、通道。</p><h4 id="Q：slice-深拷贝和浅拷贝"><a href="#Q：slice-深拷贝和浅拷贝" class="headerlink" title="Q：slice 深拷贝和浅拷贝"></a>Q：slice 深拷贝和浅拷贝</h4><ul><li><p>浅拷贝只复制了 slice 结构的部分，而没有复制底层数组。当对原始 slice 或拷贝后的 slice 进行修改时，会影响到所有相关的 slice。这是因为它们共享同一个底层数组。</p></li><li><p>深拷贝会创建一个新的 slice 和一个新的底层数组，将原始数据的所有元素复制到新的底层数组中。原始 slice 和拷贝后的 slice 将不再共享底层数组，它们是完全独立的。</p></li></ul><h4 id="Q：拷贝大切片一定比小切片代价大吗"><a href="#Q：拷贝大切片一定比小切片代价大吗" class="headerlink" title="Q：拷贝大切片一定比小切片代价大吗"></a>Q：拷贝大切片一定比小切片代价大吗</h4><p>并不是，所有切片的大小相同：三个字段（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以拷贝大切片跟小切片的代价应该是一样的。</p><h4 id="Q：defer-的作用和特点是什么"><a href="#Q：defer-的作用和特点是什么" class="headerlink" title="Q：defer 的作用和特点是什么"></a>Q：defer 的作用和特点是什么</h4><p>defer 是一个用于延迟执行函数调用的关键字。它可以将一个函数或方法的执行推迟到当前函数返回之前或所在的代码块执行结束之前。</p><p>defer 常用于资源的释放和清理操作，如关闭文件、释放锁、释放数据库连接等。通过将资源释放操作延迟执行，可以确保在函数退出之前进行必要的清理，无论函数是正常返回还是异常退出。</p><p>当有多个 defer 语句出现时，它们的执行顺序类似于栈（先进后出）的方式。也就是说，最后一个推迟的函数调用将最先执行，而第一个推迟的函数调用将最后执行。</p><h4 id="Q：为什么-defer-要按照定义的顺序逆序执行"><a href="#Q：为什么-defer-要按照定义的顺序逆序执行" class="headerlink" title="Q：为什么 defer 要按照定义的顺序逆序执行"></a>Q：为什么 defer 要按照定义的顺序逆序执行</h4><p>后⾯定义的函数可能会依赖前⾯的资源，所以要先执行。如果前⾯先执行，释放掉这个依赖，那后⾯的函数就找不到它的依赖了。</p><h4 id="Q：扩容前后的切片是否相同"><a href="#Q：扩容前后的切片是否相同" class="headerlink" title="Q：扩容前后的切片是否相同"></a>Q：扩容前后的切片是否相同</h4><p>切片的容量足够则相同。</p><p>当切片的容量不足以容纳新增的元素时，Go 语言会自动扩容切片。扩容的过程中，Go 语言会重新分配一个更大的底层数组，并将原始切片中的元素复制到新的底层数组中。由于底层数组的改变，扩容前后的切片实际引用了不同的底层数组，因此它们是不相同的。</p><h4 id="Q：GC-的触发机制"><a href="#Q：GC-的触发机制" class="headerlink" title="Q：GC 的触发机制"></a>Q：GC 的触发机制</h4><ol><li>内存分配量达到阈值：每次内存分配前都会检查当前内存分配量是否达到阈值，如果达到则触发GC，阈值 &#x3D; 上次 GC 时的内存分配量 * 内存增长率</li><li>定时触发 GC：默认情况下两分钟触发⼀次 GC，可由 runtime 中的参数声明</li><li>⼿动触发 GC：可以在代码中通过使用 runtime.GC() 来⼿动触发</li></ol><h4 id="Q：什么是-M-N-模型"><a href="#Q：什么是-M-N-模型" class="headerlink" title="Q：什么是 M:N 模型"></a>Q：什么是 M:N 模型</h4><p>Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行，这就是 M:N 模型。在同一时刻，一个线程上只能跑一个 goroutine。当 goroutine 发生阻塞时，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="Q：HTTP-协议"><a href="#Q：HTTP-协议" class="headerlink" title="Q：HTTP 协议"></a>Q：HTTP 协议</h4><p>HTTP 协议工作于客户端-服务端架构之上。浏览器作为 HTTP 客户端通过 URL，向 HTTP 服务端，即 web 服务器发送所有请求。web 服务器根据接收到的请求，向客户端发送响应信息。</p><p>是一个基于请求与响应模式的、无状态的、应用层的协议。</p><p>是一个基于 TCP&#x2F;IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）的协议。</p><h4 id="Q：HTTP-协议特点"><a href="#Q：HTTP-协议特点" class="headerlink" title="Q：HTTP 协议特点"></a>Q：HTTP 协议特点</h4><ol><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。</li><li>灵活：HTTP 允许传输任意类型的数据对象。</li><li>无状态：协议对于事务处理没有记忆能力，如果后续处理需要前面的信息，则它必须重传。</li><li>无连接的：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。</li><li>支持 B&#x2F;S 及 C&#x2F;S 模式。</li><li>默认端口 80。</li><li>基于 TCP&#x2F;IP 通信协议。</li></ol><h4 id="Q：Cookie-和-Session-的区别"><a href="#Q：Cookie-和-Session-的区别" class="headerlink" title="Q：Cookie 和 Session 的区别"></a>Q：Cookie 和 Session 的区别</h4><ul><li><p>Cookie 是浏览器支持的一种本地存储机制。一般由服务端设置生成，在响应请求时被自动存储在浏览器中，用于辨别用户身份。</p></li><li><p>创建 Session 的时候， 服务端会在 http 协议中告诉客户端，需要在 Cookie 里记录一个 sessionid，以后每次请求把这个 id 发送到服务器，就知道用户身份了。</p></li><li><p>Token 是一种基于令牌的认证机制，常见于无状态（Stateless）的 Web 应用中（移动端也推荐用 Token）。在使用 Token 认证时，当用户登录成功后，服务器会生成一个加密的 Token，并将其返回给客户端。客户端在后续的请求中需要携带这个 Token 作为身份凭证，通常通过请求头（如 Authorization 头）或查询参数来传递。</p><p><strong>区别</strong>： </p></li><li><p>存储位置：Cookie 是存储在客户端（浏览器）中的小型文本文件，而 Session 是存储在服务器上的数据结构。</p></li><li><p>数据存储：Cookie 通常包含少量的用户数据，以键值对的形式存储在客户端。Session 可以存储更多的用户数据，可以包含复杂的对象和数据结构。</p></li><li><p>安全性：Cookie 存储在客户端，可以被客户端修改或者删除。Session 数据存储在服务器端，相对来说更安全，但是会占用服务器资源。</p></li><li><p>生命周期：Cookie 可以设置过期时间，可以在客户端存储一段时间，并在之后仍然有效。Session 通常在用户关闭浏览器或一段时间不活动后过期，或者通过在服务器上设置超时时间来控制。</p></li><li><p>存储方式：Cookie 通过在 HTTP 响应头中的 Set-Cookie 字段发送给客户端，客户端将其存储在本地。之后，每次请求中都会通过 Cookie 头字段将 Cookie 发送回服务器。Session 通过在服务器上创建唯一的标识符（通常是会话 ID）来跟踪用户会话，并将该标识符存储在 Cookie 中或通过 URL 重写传递给客户端。</p></li></ul><h4 id="Q：什么是跨站脚本攻击-XSS-和-HttpOnly"><a href="#Q：什么是跨站脚本攻击-XSS-和-HttpOnly" class="headerlink" title="Q：什么是跨站脚本攻击 XSS 和 HttpOnly"></a>Q：什么是跨站脚本攻击 XSS 和 HttpOnly</h4><p>XSS 是跨站脚本攻击（Cross Site Scripting）。恶意攻击者往 Web 页面里插入 Script 代码，当用户浏览时，Script 代码会被执行从而达到攻击用户的目的。如盗取用户 Cookie、破坏页面结构、重定向到其它网站（流量劫持）等。</p><p>HttpOnly 是一个标记，用于设置 HTTP Cookie 的属性。当设置了 HttpOnly 属性后，浏览器将限制该 Cookie 只能通过 HTTP 或 HTTPS 协议进行传输，禁止通过脚本（如 JavaScript）访问该 Cookie。</p><p>HttpOnly 属性的作用是增加 web 应用程序的安全性，是防止跨站脚本攻击（XSS）的一种方式。</p><h4 id="Q：GET-和-POST-的区别"><a href="#Q：GET-和-POST-的区别" class="headerlink" title="Q：GET 和 POST 的区别"></a>Q：GET 和 POST 的区别</h4><ul><li>GET 重点在从服务器上获取资源，一般用于获取&#x2F;查询资源信息。是无副作用的，是幂等的，且可缓存。</li><li>POST 重点在向服务器发送数据，一般用于更新资源信息。有副作用，非幂等，不可缓存。</li><li>POST 比 GET 安全性更高。Get 通过 URL 来传输数据，因为 URL 是可见的，可能会泄露私密信息，如密码等。POST 通过 URL 和请求体（requrest body）传输数据，将字段与对应值封存在请求体中发送给服务器。在请求体中的数据，我们是无法直接观测到的。</li></ul><h4 id="Q：浏览器输入一个-URL-之后，网络各层发生了什么"><a href="#Q：浏览器输入一个-URL-之后，网络各层发生了什么" class="headerlink" title="Q：浏览器输入一个 URL 之后，网络各层发生了什么"></a>Q：浏览器输入一个 URL 之后，网络各层发生了什么</h4><ol><li>浏览器输入 URL，若协议为 HTTP：</li><li>应用层 DNS 解析，返回对应的 ip 地址（DNS 协议，DNS 服务器是基于 UDP 的）</li><li>应用层客户端发送 HTTP 请求（HTTP 协议）</li><li>传输层传输报文建立 TCP 连接三次握手（TCP 协议）</li><li>网络层 IP 查询 MAC 地址（IP 协议，ARP 协议）<ol><li>源 IP 地址和⽬标 IP 地址在传输过程中是不会变的，而源 MAC 地址和⽬标 MAC ⼀直在变化</li><li>MAC 只负责某一个区间之间的通信传输</li></ol></li><li>服务器发送 HTTP 响应报文</li><li>关闭连接，TCP 四次挥手</li><li>客户端解析 HTTP 响应报文，浏览器开始显示 HTML</li></ol><h4 id="Q：HTTP-和-HTTPS-的区别"><a href="#Q：HTTP-和-HTTPS-的区别" class="headerlink" title="Q：HTTP 和 HTTPS 的区别"></a>Q：HTTP 和 HTTPS 的区别</h4><ul><li>HTTP 协议是以明文的方式在网络中传输数据，而 HTTPS 协议传输的数据则是使用密钥进行加密（经过 SSL&#x2F;TLS 加密）的，所以 HTTPS 具有更高的安全性。</li><li>HTTPS 部署成本高，HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买 CA 证书。</li><li>HTTPS 握手阶段延时较高：HTTPS 在 TCP 三次握手阶段之后，还需要进行 SSL&#x2F;TLS 的握手。</li><li>由于采用 HTTPS 协议需要进行加解密的计算，占用 CPU 资源较多。</li></ul><h4 id="Q：长连接与短连接的区别"><a href="#Q：长连接与短连接的区别" class="headerlink" title="Q：长连接与短连接的区别"></a>Q：长连接与短连接的区别</h4><p>长连接，也叫持久连接，在 TCP 层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息交互，直至连接的任意一方（客户端 OR 服务端）主动断开连接，此过程称为一次完整的长连接。在 HTTP 请求和响应中，通过设置 Connection 头字段来指示是否使用长连接 <code>Connection: keep-alive</code>。</p><p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，增加了通信开销。HTTP&#x2F;1.1 最重要的新特性就是引入了长连接。</p><p>短连接，客户端收到服务端的响应后，立刻发送 FIN 消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互之后立刻断开连接的情况都称为短连接。</p><h4 id="Q：Socket-套接字"><a href="#Q：Socket-套接字" class="headerlink" title="Q：Socket 套接字"></a>Q：Socket 套接字</h4><p>Socket 套接字是在应用层和传输层之间的一个抽象层，用于实现应用程序之间的网络通信。它提供了一种编程接口，允许应用程序通过网络进行数据传输。</p><p>在网络通信中，Socket 套接字通过使用网络协议栈中的传输层协议（如 TCP 或 UDP）来实现数据的可靠传输或不可靠传输。只需要指定主机的 IP 地址，和一个端口号。</p><p>Socket 套接字是在操作系统内核中实现的，它负责处理网络通信的细节，如建立连接、数据的发送和接收、错误处理等。应用程序可以使用 Socket API（如套接字函数）来创建、配置和控制 Socket 套接字，从而实现网络通信。</p><h4 id="Q：IPv4-和-IPv6"><a href="#Q：IPv4-和-IPv6" class="headerlink" title="Q：IPv4 和 IPv6"></a>Q：IPv4 和 IPv6</h4><ul><li><p>IPv4 是目前广泛使用的 IP 协议版本。它使用 32 位地址，通常表示为<strong>点分十进制</strong>格式（例如，192.168.0.1）。</p></li><li><p>IPv6 是为了解决 IPv4 地址空间不足的问题而设计的下一代 IP 协议。IPv6 使用 128 位地址，通常表示为<strong>冒号分隔的十六进制</strong>格式（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。</p></li></ul><h4 id="Q：负载均衡"><a href="#Q：负载均衡" class="headerlink" title="Q：负载均衡"></a>Q：负载均衡</h4><p>负载均衡是一种在计算机网络中分配工作负载（请求或流量）到多个服务器的技术。它旨在提高系统的性能、可扩展性和可靠性，通过均衡分配负载来避免单个服务器过载或故障引起的性能下降。</p><p>实现负载均衡的一种常见方法是通过负载均衡器（Load Balancer）。负载均衡器是位于客户端和服务器之间的网络设备或软件，它接收来自客户端的请求，并将这些请求分发到一组后端服务器上，以实现负载的均衡。</p><ul><li><p>Nginx 是七层（即应用层）负载均衡器 ，这意味着如果它要转发流量首先得和 client 建立一个 TCP 连接，并且转发的时候也要与转发到的上游 server 建立一个 TCP 连接，而我们知道建立 TCP 连接其实是需要耗费内存（TCP Socket，接收&#x2F;发送缓存区等需要占用内存）的。所以 Nginx 的负载能力受限于机器 I&#x2F;O，CPU 内存等一系列配置，一旦连接很多（比如达到百万）的话，Nginx 抗负载能力就会急剧下降。</p></li><li><p>LVS 是四层（传输层）负载均衡器，LVS 只是单纯地转发包，不需要和上下游建立连接，相比于 Nginx 它的抗负载能力强、性能高，对内存和 cpu 资源消耗比较低。负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过负载均衡算法选择一个最佳的服务器，并对报文中目标 IP 地址进行修改（改为后端服务器 IP），直接转发给该服务器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。</p></li></ul><h4 id="Q：负载均衡算法"><a href="#Q：负载均衡算法" class="headerlink" title="Q：负载均衡算法"></a>Q：负载均衡算法</h4><ul><li><p>轮询（Round Robin）：每个请求按照轮询的顺序依次分发给服务器。</p></li><li><p>权重轮询（Weighted Round Robin）：给每个服务器分配一个权重值，根据权重值的比例来分配请求。</p></li><li><p>随机（Random）：随机选择一台服务器来处理每个请求。</p></li><li><p>最少连接（Least Connections）：选择当前连接数最少的服务器来处理请求。</p></li><li><p>IP 哈希（IP Hash）：根据请求的源 IP 地址来进行哈希计算，并将请求分配给对应的服务器。同一 IP 地址的请求总是被分配到相同的服务器，适用于保持会话的应用。</p></li><li><p>哈希（Hash）：根据请求的特定信息（如 URL、Cookie 等）进行哈希计算，并将请求分配给对应的服务器。</p></li><li><p>最少响应时间（Least Response Time）：根据服务器的响应时间来进行分配。将请求发送到响应时间最短的服务器，以提供更快的响应。</p></li><li><p>最少资源（Least Resources）：根据服务器的资源使用情况（如 CPU、内存等）进行分配。将请求发送到资源使用最少的服务器，以提供更好的性能。</p></li></ul><h4 id="Q：什么是-SYN-攻击"><a href="#Q：什么是-SYN-攻击" class="headerlink" title="Q：什么是 SYN 攻击"></a>Q：什么是 SYN 攻击</h4><p>在 TCP 协议中，建立连接的过程涉及三次握手：客户端发送一个 SYN 包（同步请求）给服务器，服务器回复一个 SYN-ACK 包（同步应答），最后客户端发送一个 ACK 包（确认）。这个过程用于确保客户端和服务器之间的连接正常建立。</p><p>SYN 攻击利用了这个连接建立的过程中的漏洞。攻击者发送大量的伪造的 SYN 包给目标服务器，但是攻击者并不回复服务器的 SYN-ACK 包。服务器在等待超时后会关闭这个半连接状态，释放资源。攻击者不断发送大量的伪造 SYN 包，占用服务器的连接资源，导致服务器无法处理正常的连接请求。</p><h4 id="Q：常见的网络劫持"><a href="#Q：常见的网络劫持" class="headerlink" title="Q：常见的网络劫持"></a>Q：常见的网络劫持</h4><ul><li><p>DNS 劫持：攻击者篡改 DNS 的解析过程，使得用户在输入网址时被重定向到恶意网站，从而窃取用户的信息或进行其他恶意活动。</p></li><li><p>ARP 劫持：攻击者在本地网络中伪造或篡改 ARP 响应，将目标主机的 IP 地址映射到攻击者的 MAC 地址，从而导致网络通信被重定向到攻击者控制的主机。</p></li><li><p>BGP 劫持：攻击者通过篡改 BGP 路由表信息，使得网络流量被重定向到攻击者控制的路径，从而可以窃取、拦截或篡改网络通信。</p></li><li><p>HTTP 劫持：攻击者劫持 HTTP 通信过程，例如通过中间人攻击（Man-in-the-Middle Attack）获取或篡改 HTTP 请求和响应，从而窃取用户的敏感信息或操纵通信内容。</p></li><li><p>WiFi 劫持：攻击者在公共 WiFi 网络中进行劫持，例如通过伪造热点或中间人攻击来窃取用户的网络流量和敏感信息。</p></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="Q：操作系统的功能"><a href="#Q：操作系统的功能" class="headerlink" title="Q：操作系统的功能"></a>Q：操作系统的功能</h4><p>操作系统位于硬件资源之上，管理硬件资源；应用程序之下，为应用程序提供服务，同时管理应用程序。</p><ul><li>资源分配，资源回收</li><li>为应用程序提供服务</li><li>管理应用程序，控制进程的生命周期</li><li>操作系统内核的功能：进程调度、内存管理、硬件通信、系统调用</li></ul><h4 id="Q：用户程序与操作系统的关系"><a href="#Q：用户程序与操作系统的关系" class="headerlink" title="Q：用户程序与操作系统的关系"></a>Q：用户程序与操作系统的关系</h4><p>相互调用。</p><p>计算机启动后启动的第⼀个软件就是操作系统，随后启动的所有进程都运行在操作系统之上，使用操作系统提供的服务，同时被操作系统监控，进程结束后也由操作系统回收。</p><p>编译的代码可执行文件只是储存在硬盘的静态文件，运行时被加载到内存，CPU 执行内存中指令，这个运行的程序被称为进程。用户进程调用操作系统提供的服务，实现自己的功能。</p><h4 id="Q：进程、线程和协程"><a href="#Q：进程、线程和协程" class="headerlink" title="Q：进程、线程和协程"></a>Q：进程、线程和协程</h4><ul><li><p>进程（Process）：进程是<strong>操作系统分配资源的最小单位</strong>，是一个正在执行中的程序的实例。每个进程都有独立的内存空间和执行环境，它们之间相互隔离。进程之间通常通过进程间通信（IPC）机制进行通信，如管道、共享内存、消息队列等。多进程可以同时执行不同的任务，实现并发处理。</p></li><li><p>线程（Thread）：线程是<strong>进程内的执行单元</strong>，是 <strong>CPU 调度的最小单位</strong>。一个进程可以包含多个线程，共享相同的内存空间和上下文环境。不同线程之间可以并发执行，通过共享内存来进行数据通信，但也需要注意同步和互斥问题。每个线程都有自己独立的堆栈空间，线程之间的切换开销相对较小，适合执行密集的计算和并发任务。</p></li><li><p>协程（Coroutine）：协程是一种<strong>用户态的轻量级线程</strong>，一个线程中可以包含多个协程，在同一时刻只有一个协程运行，通过协程的切换来实现并发任务的处理。协程在执行过程中可以主动挂起和恢复，控制权的切换由程序自身控制，通常不涉及内核态的切换，因此协程的创建和切换开销较小。协程通常使用更少的内存，因为多个协程可以共享同一个线程的堆栈空间。</p></li></ul><p>系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等。在进行进程切换时，涉及到整个 CPU 环境的保存以及新 CPU 环境的设置。而线程切换只须保存和设置少量寄存器的内容，所以进程切换的开销也远大于线程切换的开销。</p><p>通信开销：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现变得比较容易，可以直接读写进程数据段（如全局变量）来进行通信，也需要进行同步和互斥来保证数据的一致性。</p><p>进程间相互独立，不会相互影响；而一个线程挂掉可能会导致整个进程挂掉。</p><h4 id="Q：进程间通信的方式"><a href="#Q：进程间通信的方式" class="headerlink" title="Q：进程间通信的方式"></a>Q：进程间通信的方式</h4><ul><li><p>管道（Pipe）：管道是一种半双工的通信方式，分为匿名管道和命名管道。匿名管道用于父子进程之间的通信，而命名管道则可以用于无关进程之间的通信。</p></li><li><p>命名管道（Named Pipe）：命名管道是一种具有名称的管道，可以用于不相关的进程之间进行通信。命名管道可以在文件系统中创建，并且可以由多个进程共享。</p></li><li><p>共享内存（Shared Memory）：共享内存是一种进程间共享内存空间的方式。多个进程可以访问同一块内存区域，从而实现高效的数据交换。需要进行同步和互斥来保证数据的一致性。</p></li><li><p>消息队列（Message Queue）：消息队列是一种进程间传递消息的方式。进程可以将消息发送到消息队列，其他进程可以从队列中接收消息。消息队列提供了一种异步的通信方式。</p></li><li><p>信号量（Semaphore）：信号量是一种用于进程同步和互斥的机制。多个进程可以通过信号量来进行临界区的互斥访问，以及进程之间的同步操作。</p></li><li><p>套接字（Socket）：套接字是一种网络通信的方式，用于在不同的主机之间进行进程间通信。套接字提供了一种通用的、可移植的通信机制，可以在不同计算机之间进行通信。</p></li></ul><h4 id="Q：进程间同步的方式"><a href="#Q：进程间同步的方式" class="headerlink" title="Q：进程间同步的方式"></a>Q：进程间同步的方式</h4><ul><li><p>临界区（Critical Section）：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。每个进程中访问临界资源的那段程序称为临界区，一次仅允许一个进程使用的资源称为临界资源。</p></li><li><p>互斥量（Mutex）：在某个进程需要访问共享资源时，它必须先获得互斥锁，其他进程在同一时间内无法获得该锁，从而保证了共享资源在同一时刻只被一个进程访问。在完成操作后，进程释放互斥锁，其他进程才能继续竞争获取该锁。</p></li><li><p>信号量（Semaphore）：信号量是一种计数器，用于管理对共享资源的访问。它允许多个进程同时访问共享资源，但通过控制信号量的计数值，限制能够同时访问共享资源的进程数量。</p></li><li><p>事件（Event）：事件用于实现进程间的通信和同步。进程可以等待一个事件的发生，在事件发生时，其他进程可以通过触发事件来通知等待的进程。</p></li></ul><h4 id="Q：线程-x2F-进程的五种状态"><a href="#Q：线程-x2F-进程的五种状态" class="headerlink" title="Q：线程&#x2F;进程的五种状态"></a>Q：线程&#x2F;进程的五种状态</h4><ol><li><p>新建：当创建线程对象时，线程处于新建状态。此时线程还没有开始执行，尚未分配系统资源。</p></li><li><p>就绪：线程已经分配了系统资源，但尚未获得 CPU 的执行时间片。</p></li><li><p>运行：获得 CPU 的执行时间片后，进入运行状态，开始执行线程的任务代码。</p></li><li><p>阻塞：线程可能由于某些原因而暂时停止执行，进入阻塞状态。例如等待某个资源。</p></li><li><p>终止：线程的执行任务结束后，或者由于异常等原因导致线程终止，线程进入终止状态。终止状态的线程不再执行，且无法转换到其他状态。</p></li></ol><p><img src="/ByteDance-13/2.png"></p><h4 id="Q：中断的处理过程"><a href="#Q：中断的处理过程" class="headerlink" title="Q：中断的处理过程"></a>Q：中断的处理过程</h4><ul><li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li><li>开中断：以便执行中断时能响应较高级别的中断请求。</li><li>中断处理</li><li>关中断：保证恢复现场时不被新中断打扰</li><li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。</li></ul><h4 id="Q：进程调度策略"><a href="#Q：进程调度策略" class="headerlink" title="Q：进程调度策略"></a>Q：进程调度策略</h4><ul><li>先来先服务</li><li>短作业优先</li><li>最短剩余时间优先</li><li>优先级调度</li><li>时间片轮转</li><li>高响应比优先</li><li>多级反馈队列：每个队列的时间片不同，优先级也不同</li></ul><p><img src="/ByteDance-13/3.png"></p><h4 id="Q：消息队列的作用"><a href="#Q：消息队列的作用" class="headerlink" title="Q：消息队列的作用"></a>Q：消息队列的作用</h4><ul><li><p>异步通信：消息队列允许发送者发送消息后立即返回，而无需等待接收者的响应。这样可以实现异步通信，提高系统的响应性能和并发性。</p></li><li><p>解耦应用组件：通过消息队列，不同的应用组件可以解耦并独立演化。发送者和接收者之间不需要直接的依赖关系，它们只需要通过共享的消息队列来进行通信。这样，应用组件可以独立开发、部署和升级，而不会对其他组件产生影响。</p></li><li><p>缓冲和削峰填谷：消息队列可以作为缓冲区，当消息发送的速度超过接收的速度时，消息可以暂时存储在队列中，避免消息丢失或系统过载。同时，在高负载时，消息队列可以平滑处理峰值流量，保护系统免受过高的请求压力。</p></li><li><p>可靠性和持久化：许多消息队列提供持久化机制，确保即使在消息传递过程中出现故障或重启，消息也不会丢失。消息队列还可以提供消息的投递确认和重试机制，确保消息的可靠传递。</p></li><li><p>扩展性和可伸缩性：消息队列可以用于构建分布式系统，并支持水平扩展。通过增加消息队列的实例或增加消费者的数量，可以提高系统的处理能力和可伸缩性。</p></li></ul><h4 id="Q：什么是交换空间"><a href="#Q：什么是交换空间" class="headerlink" title="Q：什么是交换空间"></a>Q：什么是交换空间</h4><p>交换空间通常是在硬盘上预留出来的一块空间，操作系统在需要时将内存中暂时不用的数据写入到交换空间，这样可以释放物理内存用于其他需要更紧急的任务。当需要读取这些数据时，操作系统再将它们从交换空间读取回物理内存中。</p><h4 id="Q：分页和分段"><a href="#Q：分页和分段" class="headerlink" title="Q：分页和分段"></a>Q：分页和分段</h4><p>分页和分段是计算机内存管理中的两种重要技术，解决了以前操作系统连续分配内存管理方案带来的碎片问题。</p><ul><li><p>分段是将进程的逻辑地址空间划分成多个逻辑段（Segment），不同段可以放入内存的不同位置。每个段表示一个独立的逻辑单元，如代码段、数据段、栈段等。每个段的大小可以不同，并且段的长度可以根据进程的需求动态增长或缩小，减少外部碎片。</p></li><li><p>分页是将进程的逻辑地址空间划分成大小固定的页（Page），同时将内存划分成与页大小相同的块，称为页框，每个进程的页表记录了页到页框的映射关系。分页消除了外部碎片，但会出现内部碎片。</p></li></ul><h4 id="Q：死锁产生的条件"><a href="#Q：死锁产生的条件" class="headerlink" title="Q：死锁产生的条件"></a>Q：死锁产生的条件</h4><ol><li><p>互斥条件：一个资源在任意时刻只能被一个进程持有。</p></li><li><p>请求与保持条件：当进程在等待其他资源时，它可以继续持有自己已经获得的资源。</p></li><li><p>不可剥夺条件：资源只能由占有它的进程主动释放，而不能被其他进程抢占。</p></li><li><p>环路等待条件：每个进程都在等待下一个进程所占有的资源，形成一个循环等待的环路。</p></li></ol><h4 id="Q：如何处理死锁问题"><a href="#Q：如何处理死锁问题" class="headerlink" title="Q：如何处理死锁问题"></a>Q：如何处理死锁问题</h4><ul><li><p>预防死锁：消除死锁产生的四个必要条件之一，如对资源进行排序，让进程按照相同的顺序请求资源。</p></li><li><p>避免死锁：在资源分配过程中，通过检查系统状态来判断是否会产生死锁，并采取相应的措施来避免死锁的发生。</p></li><li><p>检测与恢复：一旦检测到死锁，可以通过抢占资源或回滚进程状态来恢复系统到一个安全的状态，解除死锁。</p></li><li><p>忽略死锁：如果死锁发生的概率非常低，并且解决死锁问题的代价很高，可以选择忽略死锁并在发生死锁时进行系统重启或人工介入来解决问题。</p></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h4 id="Q：Linux-常用命令"><a href="#Q：Linux-常用命令" class="headerlink" title="Q：Linux 常用命令"></a>Q：Linux 常用命令</h4><ol><li>文件和目录管理命令：</li></ol><ul><li>ls: 列出目录中的文件和子目录。</li><li>pwd: 显示当前工作目录的路径。</li><li>cd: 切换工作目录。</li><li>mkdir: 创建新目录。</li><li>rm: 删除文件或目录。</li><li>cp: 复制文件或目录。</li><li>mv: 移动文件或目录，也可用于重命名文件。</li><li>cat: 显示文件内容。</li><li>more 或 less: 分页查看文件内容。</li><li>touch: 创建空文件或更新文件的访问和修改时间。</li></ul><ol start="2"><li>系统管理命令：</li></ol><ul><li>ps: 显示当前运行进程的状态。</li><li>top: 实时显示系统的进程状态和资源使用情况。</li><li>kill: 终止进程。</li><li>ifconfig 或 ip: 显示网络接口信息。</li><li>ping: 测试网络连接。</li><li>netstat: 显示网络连接、路由表和网络接口信息。</li><li>df: 显示磁盘空间使用情况。</li><li>du: 显示目录或文件的磁盘使用情况。</li></ul><ol start="3"><li>用户管理命令：</li></ol><ul><li>who: 显示当前登录的用户。</li><li>whoami: 显示当前用户名。</li><li>useradd: 创建新用户。</li><li>userdel: 删除用户。</li><li>passwd: 设置用户密码。</li></ul><ol start="4"><li>权限管理命令：</li></ol><ul><li>chmod: 修改文件或目录的权限。</li><li>chown: 修改文件或目录的所有者。</li><li>chgrp: 修改文件或目录的所属组。</li></ul><ol start="5"><li>压缩和解压命令：</li></ol><ul><li>tar: 打包和解包文件。</li><li>gzip 或 gunzip: 压缩和解压文件。</li></ul><ol start="6"><li>搜索命令：</li></ol><ul><li>grep: 在文件中搜索指定的文本模式。</li><li>find: 在文件系统中搜索文件或目录。</li></ul><ol start="7"><li>管道和重定向：</li></ol><ul><li><code>|</code> : 管道操作符，用于将一个命令的输出作为另一个命令的输入。</li><li><code>&gt;</code> : 重定向操作符，将命令的输出保存到文件中。</li><li><code>&gt;&gt;</code> : 追加重定向操作符，将命令的输出追加到文件末尾。</li></ul><h4 id="Q：Linux-如何查看系统日志"><a href="#Q：Linux-如何查看系统日志" class="headerlink" title="Q：Linux 如何查看系统日志"></a>Q：Linux 如何查看系统日志</h4><ul><li>使用 journalctl 命令</li><li>查看特定日志文件：<code>/var/log</code> 目录下的不同文件中</li></ul><h4 id="Q：用户态和内核态有什么区别"><a href="#Q：用户态和内核态有什么区别" class="headerlink" title="Q：用户态和内核态有什么区别"></a>Q：用户态和内核态有什么区别</h4><p>通过系统调用将 Linux 整个体系分为用户态和内核态（或者说内核空间和用户空间）。</p><ul><li>内核态是操作系统内核运行的一种模式，其中操作系统内核具有最高的特权级别和完全访问系统资源的权限。例如协调 CPU 资源，分配内存资源，并且提供稳定的环境供应用程序运行。</li><li>用户态是应用程序运行的一种模式，其中应用程序以及用户编写的代码在用户空间运行，无法直接访问或操作底层硬件设备和操作系统内核。</li></ul><p>用户态的应用程序运行在操作系统提供的虚拟地址空间中，通过系统调用向内核请求服务和资源。</p><p>从用户态到内核态切换可以通过三种方式：</p><ol><li>系统调用：其实系统调用本身就是中断，但是软件中断，跟硬中断不同。</li><li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。</li><li>外设中断：当外设完成用户的请求时，会向 CPU 发送中断信号。</li></ol><h4 id="Q：kill-15-和-kill-9-的区别"><a href="#Q：kill-15-和-kill-9-的区别" class="headerlink" title="Q：kill -15 和 kill -9 的区别"></a>Q：kill -15 和 kill -9 的区别</h4><ul><li>kill -9 PID 是操作系统从内核级别强制杀死一个进程。</li><li>kill -15 PID 可以理解为操作系统发送一个通知告诉应用主动关闭。</li></ul><p>因为 kill -15 信号只是通知对应的进程要进行”安全、干净的退出”，程序接到信号之后，退出前一般会进行一些”准备工作”，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。但是，如果在”准备工作”进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。</p><h4 id="Q：前台进程和后台进程区别"><a href="#Q：前台进程和后台进程区别" class="headerlink" title="Q：前台进程和后台进程区别"></a>Q：前台进程和后台进程区别</h4><ul><li>前台进程：是在终端中运行的命令，那么该终端就为进程的控制终端，一旦这个终端关闭，这个进程也随之消失。</li><li>后台进程：也叫守护进程（Daemon），是运行在后台的一种特殊进程，不受终端控制，它不需要终端的交互；Linux 的大多数服务器就是使用守护进程实现的。</li></ul><h4 id="Q：scp-命令"><a href="#Q：scp-命令" class="headerlink" title="Q：scp 命令"></a>Q：scp 命令</h4><p>在 linux 下 scp 命令主要用来在不同主机之间做数据的安全拷贝的。scp 命令使用安全加密的协议，所以在远程拷贝数据的时候会比较安全，不会被黑客截取。</p><h4 id="Q：shell-脚本"><a href="#Q：shell-脚本" class="headerlink" title="Q：shell 脚本"></a>Q：shell 脚本</h4><p>第一行一定是 <code>#!/bin/bash</code>，它代表该文件使用的是 bash 语法。如果不设置该行，那么你的 shell 脚本就不能被执行。</p><p>数学计算要用 ‘[]’ 括起来并且外头要带一个 <code>$</code>。</p><ul><li>$v：用于获取变量的值。例如 name&#x3D;”John”，那么 $name 将会返回 “John”</li><li>$0：表示当前脚本的名称</li><li>$1：表示脚本的参数。$1 表示第一个参数，$2 表示第二个参数，以此类推</li><li>$#：表示传递给脚本的参数个数</li><li>$@：表示所有的命令行参数列表</li><li>$?：表示上一个命令的退出状态。通常如果上一个命令执行成功，则其值为 0，否则为非零值</li><li>$$：表示当前脚本的进程 ID</li><li>$!：表示最后一个在后台运行的进程的 ID</li><li>$RANDOM：表示一个随机数</li><li>$() 或者 &#96;&#96;：用于命令替换，可以将命令的输出作为一个值赋给变量。例如：result&#x3D;$(ls) 将 ls 命令的输出赋给 result</li></ul><h4 id="Q：grep、sed、awk-的用法"><a href="#Q：grep、sed、awk-的用法" class="headerlink" title="Q：grep、sed、awk 的用法"></a>Q：grep、sed、awk 的用法</h4><ul><li><p>grep 是一种用于在文本中查找匹配模式的工具。它根据给定的模式搜索文本行，并输出包含匹配项的行。<br>基本语法：<code>grep &#39;pattern&#39; filename</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在文件 file.txt 中查找包含 &quot;pattern&quot; 的行并输出到标准输出</span><br>grep <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br><br><span class="hljs-comment"># 在文件 file.txt 中查找包含 &quot;pattern&quot; 的行，忽略大小写，并显示行号</span><br>grep -i -n <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br><br><span class="hljs-comment"># 在文件夹 dir 中递归查找所有文件中匹配正则表达式 &quot;pattern&quot; 的行，并打印匹配行所在的文件名和行号</span><br>grep -r -n pattern <span class="hljs-built_in">dir</span>/<br></code></pre></td></tr></table></figure></li><li><p>sed 是一种流编辑器，它逐行处理文本并根据指定的命令进行操作。常用于查找和替换文本。<br>基本语法：<code>sed &#39;s/pattern/replacement/&#39; filename</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将 testfile 文件中每行第一次出现的 oo 用字符串 kk 替换，然后将该文件内容输出到标准输出</span><br>sed -e <span class="hljs-string">&#x27;s/oo/kk/&#x27;</span> testfile<br><br><span class="hljs-comment"># g 标识符表示全局查找替换，使 sed 对文件中所有符合的字符串都被替换，修改后内容会到标准输出，不会修改原文件</span><br>sed -e <span class="hljs-string">&#x27;s/oo/kk/g&#x27;</span> testfile<br><br><span class="hljs-comment"># 选项 i 使 sed 修改文件</span><br>sed -i <span class="hljs-string">&#x27;s/oo/kk/g&#x27;</span> testfile<br><br><span class="hljs-comment"># 在 testfile 文件的第四行后添加一行，并将结果输出到标准输出</span><br>sed -e 4a\newLine testfile <br><br><span class="hljs-comment"># 将 testfile 的内容列出并且列印行号，同时将第 2~5 行删除</span><br><span class="hljs-built_in">nl</span> testfile | sed <span class="hljs-string">&#x27;2,5d&#x27;</span><br><br><span class="hljs-comment"># 删除第 3 到最后一行</span><br>sed <span class="hljs-string">&#x27;3,$d&#x27;</span> testfile<br><br><span class="hljs-comment"># 在第 2 行后新增上 drink tea</span><br>sed <span class="hljs-string">&#x27;2a drink tea&#x27;</span> testfile<br><br><span class="hljs-comment"># 在第 2 行前插入上 drink tea</span><br>sed <span class="hljs-string">&#x27;2i drink tea&#x27;</span> testfile<br><br><span class="hljs-comment"># 搜索 testfile 有 oo 关键字的行</span><br>sed -n <span class="hljs-string">&#x27;/oo/p&#x27;</span> testfile<br><br><span class="hljs-comment"># 删除 testfile 所有包含 oo 的行</span><br>sed <span class="hljs-string">&#x27;/oo/d&#x27;</span> testfile<br></code></pre></td></tr></table></figure></li><li><p>awk 是一种强大的文本处理工具，用于从输入文件逐行读取文本，并根据指定的规则进行处理和格式化。<br>基本语法：<code>awk &#39;pattern &#123;action&#125;&#39; filename</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印文件 file.txt 的第 2 列</span><br>awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> file.txt<br><br><span class="hljs-comment"># 根据分隔符 &quot;:&quot; 打印文件 file.txt 的第 1 列和第 3 列</span><br>awk -F<span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print $1,$3&#125;&#x27;</span> file.txt<br><br><span class="hljs-comment"># 过滤第一列大于 2 的行</span><br>awk <span class="hljs-string">&#x27;$1&gt;2 &#123;print $1,$3&#125;&#x27;</span> file.txt<br><br><span class="hljs-comment"># 计算文件 file.txt 的第 2 列的总和</span><br>awk <span class="hljs-string">&#x27;&#123;sum += $2&#125; END &#123;print sum&#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="Q：Linux-如何查看某个文件中某个关键字的后-5-行"><a href="#Q：Linux-如何查看某个文件中某个关键字的后-5-行" class="headerlink" title="Q：Linux 如何查看某个文件中某个关键字的后 5 行"></a>Q：Linux 如何查看某个文件中某个关键字的后 5 行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&quot;keyword&quot;</span> example.txt | <span class="hljs-built_in">tail</span> -n 5<br></code></pre></td></tr></table></figure><ul><li>grep -n “keyword” example.txt: 使用 grep 命令查找文件中包含关键字 keyword 的所有行，并显示它们的行号。选项 -n 表示显示行号。</li><li>tail -n 5: 使用 tail 命令显示最后 5 行。因为前面已经使用 grep 命令找到了匹配的行并显示了行号，这里只需要用 tail 命令显示最后 5 行即可。</li></ul><h4 id="Q：Docker-常用命令"><a href="#Q：Docker-常用命令" class="headerlink" title="Q：Docker 常用命令"></a>Q：Docker 常用命令</h4><ol><li>容器管理命令：</li></ol><ul><li>docker run: 创建并运行一个新的容器。</li><li>docker start: 启动一个已经被停止的容器。</li><li>docker stop: 停止一个正在运行的容器。</li><li>docker restart: 重启一个容器。</li><li>docker pause: 暂停一个容器中的所有进程。</li><li>docker unpause: 恢复一个容器中的所有进程。</li><li>docker kill: 强制停止一个容器。</li><li>docker rm: 删除一个或多个容器。</li><li>docker ps: 列出正在运行的容器。</li><li>docker ps -a: 列出所有容器，包括正在运行和已停止的。</li><li>docker exec: 在运行中的容器内执行命令。</li><li>docker logs: 查看容器的日志。</li><li>docker inspect: 显示容器的详细信息。</li></ul><ol start="2"><li>镜像管理命令：</li></ol><ul><li>docker images: 列出本地的镜像。</li><li>docker pull: 从 Docker 仓库拉取镜像。</li><li>docker build: 使用 Dockerfile 构建镜像。</li><li>docker push: 将镜像推送到 Docker 仓库。</li><li>docker rmi: 删除一个或多个镜像。</li></ul><ol start="3"><li>Docker网络命令：</li></ol><ul><li>docker network ls: 列出所有 Docker 网络。</li><li>docker network create: 创建一个新的 Docker 网络。</li><li>docker network connect: 将容器连接到一个 Docker 网络。</li><li>docker network disconnect: 将容器从一个 Docker 网络断开连接。</li></ul><ol start="4"><li>数据管理命令：</li></ol><ul><li>docker volume ls: 列出所有 Docker 数据卷。</li><li>docker volume create: 创建一个新的 Docker 数据卷。</li><li>docker volume rm: 删除一个或多个 Docker 数据卷。</li></ul><ol start="5"><li>其他常用命令：</li></ol><ul><li>docker version: 显示 Docker 客户端和服务端的版本信息。</li><li>docker info: 显示 Docker 系统信息。</li><li>docker-compose: 使用 Docker Compose 来管理多个容器的应用。</li></ul><h4 id="Q：Dockerfile-中-COPY-和-ADD-有什么区别"><a href="#Q：Dockerfile-中-COPY-和-ADD-有什么区别" class="headerlink" title="Q：Dockerfile 中 COPY 和 ADD 有什么区别"></a>Q：Dockerfile 中 COPY 和 ADD 有什么区别</h4><ul><li>COPY 只能复制本地主机的文件或目录，不能复制网络资源或从 URL 下载文件。</li><li>COPY 在复制文件时，不会自动解压缩压缩文件，即使文件是归档文件（例如 .tar, .gz 等），也会按照原样复制到镜像中。</li><li>除了复制本地文件外，ADD 还支持复制网络资源和从 URL 下载文件。如果 &lt;源路径&gt; 是一个 URL，ADD 命令会自动下载文件并复制到镜像中。</li><li>ADD 在复制文件时，如果文件是归档文件（例如 .tar, .gz 等），会自动解压缩压缩文件并复制到镜像中。</li></ul><h4 id="Q：Docker-容器如何实现隔离的"><a href="#Q：Docker-容器如何实现隔离的" class="headerlink" title="Q：Docker 容器如何实现隔离的"></a>Q：Docker 容器如何实现隔离的</h4><p>Docker 容器实现隔离是通过一系列 Linux 内核特性和技术实现的。这些特性允许每个 Docker 容器拥有独立的文件系统、进程空间、网络和用户空间，从而使它们相互隔离。</p><p>每个容器运行在它自己的命名空间（Namespaces）中，但是，确实与其它运行中的容器共用相同的系统内核。隔离的产生是由于系统内核清楚地知道命名空间及其中的进程，且这些进程调用系统 API 时，内核保证进程只能访问属于其命名空间中的资源。</p><h4 id="Q：什么是-Docker-compose"><a href="#Q：什么是-Docker-compose" class="headerlink" title="Q：什么是 Docker compose"></a>Q：什么是 Docker compose</h4><p>用于定义和管理多个 Docker 容器的应用程序。它允许你使用简单的 YAML 文件来描述多个容器之间的关系和配置，从而实现快速、方便地部署和管理复杂的多容器应用。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="Q：为什么说-B-树更适合数据库索引"><a href="#Q：为什么说-B-树更适合数据库索引" class="headerlink" title="Q：为什么说 B+ 树更适合数据库索引"></a>Q：为什么说 B+ 树更适合数据库索引</h4><ul><li><p>B+ 树的磁盘读写代价更低：B+ 树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对 B 树更小，盘块所能容纳的关键字数量也越多，一次性读入内存的查找的关键字也就越多，相对 IO 读写次数就降低了。</p></li><li><p>B 树中每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B 树的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率。</p></li><li><p>B+ 树的查询效率更加稳定：由于中间结点并不指向文件内容，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，每一个数据的查询效率相当。</p></li><li><p>B+ 树的数据都存储在叶子结点中方便扫库，只需要扫一遍叶子结点即可，但是 B 树因为其分支结点同样存储着数据，需要进行一次中序遍历按序来扫，而且由于叶子节点之间有双向链表 B+ 树更加适合用于区间查询。</p></li></ul><h4 id="Q：最左前缀原则和最左匹配原则"><a href="#Q：最左前缀原则和最左匹配原则" class="headerlink" title="Q：最左前缀原则和最左匹配原则"></a>Q：最左前缀原则和最左匹配原则</h4><ul><li><p>最左前缀原则是指当数据库使用复合索引进行查询时，查询条件必须是复合索引的最左边的一个或多个字段，才能充分利用索引加速查询。</p></li><li><p>最左匹配原则是最左前缀原则的一个扩展，它指的是数据库可以利用复合索引中的最左边的连续一段字段来加速查询。这意味着在满足最左前缀原则的前提下，数据库可以只使用复合索引中的前几个字段来匹配查询条件。</p></li></ul><h4 id="Q：数据库三大范式是什么"><a href="#Q：数据库三大范式是什么" class="headerlink" title="Q：数据库三大范式是什么"></a>Q：数据库三大范式是什么</h4><ul><li>第一范式：每个列都不可以再拆分。</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li><li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><p>通过遵循数据库三大范式，可以有效地规范数据库的设计，消除数据冗余和不一致性，减少数据更新异常，使得数据库的结构更加清晰、高效，并提高数据库的性能和可维护性。</p><h4 id="Q：MySQL-和-Redis-两种数据库有什么区别"><a href="#Q：MySQL-和-Redis-两种数据库有什么区别" class="headerlink" title="Q：MySQL 和 Redis 两种数据库有什么区别"></a>Q：MySQL 和 Redis 两种数据库有什么区别</h4><ul><li><p>MySQL 是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。但是不受空间容量限制，性价比高。</p></li><li><p>Redis 是内存数据库，将数据存储在缓存中，用于存储使用频繁的数据，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。</p></li><li><p>Redis 中没有索引，所有的数据都存储在内存中，不需要像传统数据库一样通过索引来查找。</p></li></ul><h4 id="Q：主从全量同步使用-RDB-而不使用-AOF-的原因"><a href="#Q：主从全量同步使用-RDB-而不使用-AOF-的原因" class="headerlink" title="Q：主从全量同步使用 RDB 而不使用 AOF 的原因"></a>Q：主从全量同步使用 RDB 而不使用 AOF 的原因</h4><ul><li><p>RDB 文件内容是经过压缩的⼆进制数据（不同数据类型数据做了针对性优化），文件很小。而 AOF 文件记录的是每⼀次写操作的命令，写操作多文件会变得很⼤，其中还包括对同⼀个 key 的多次冗余操作。</p></li><li><p>打开 AOF 就要选择文件刷盘的策略，选择不当会严重影响 Redis 性能。而 RDB 只有在需要定时备份和主从全量同步数据时才会触发生成⼀次快照。</p></li></ul><h4 id="Q：跳跃表在-Redis-中主要用在哪些地方"><a href="#Q：跳跃表在-Redis-中主要用在哪些地方" class="headerlink" title="Q：跳跃表在 Redis 中主要用在哪些地方"></a>Q：跳跃表在 Redis 中主要用在哪些地方</h4><p>zset 有序集合就是用跳表来实现的。可以实现范围查找，排行榜功能或者 topN 功能。</p><p>跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。以空间换时间的方式提升了查找速度。</p><h4 id="Q：在-Redis-中找出已知的前缀开头的所有-key"><a href="#Q：在-Redis-中找出已知的前缀开头的所有-key" class="headerlink" title="Q：在 Redis 中找出已知的前缀开头的所有 key"></a>Q：在 Redis 中找出已知的前缀开头的所有 key</h4><p>使用 keys 指令可以扫出指定模式的 key 列表。但 Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，整体所花费的时间会比直接用 keys 指令长。</p><h4 id="Q：常见的缓存更新策略"><a href="#Q：常见的缓存更新策略" class="headerlink" title="Q：常见的缓存更新策略"></a>Q：常见的缓存更新策略</h4><ul><li><p>Cache Aside（旁路缓存）策略</p><p>  Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护</p><ul><li>写策略的步骤：先更新数据库中的数据，再删除缓存中的数据。</li><li>读策略的步骤：如果读取的数据命中了缓存，则直接返回数据；如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul></li><li><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</p><p>  应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p></li><li><p>Write Back（写回）策略</p><p>  更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h4 id="Q：软件生命周期的六个阶段"><a href="#Q：软件生命周期的六个阶段" class="headerlink" title="Q：软件生命周期的六个阶段"></a>Q：软件生命周期的六个阶段</h4><p>计划、需求、设计、编码、测试、运行与维护。</p><ol><li>问题定义及规划阶段：主要确定软件的开发目的及其可行性，制定开发计划。</li><li>需求分析&#x2F;评审阶段：在确定软件开发可行的情况下，将对软件需要实现的每个功能进行详细分析。</li><li>软件设计阶段：在此阶段，将根据需求分析的结果来设计整个软件系统，例如系统框架设计，数据库设计等。软件设计一般分为总体设计和详细设计。</li><li>软件编码阶段：开发人员任务、程序员编码。</li><li>软件测试阶段：测试工程师的任务或开发的任务。</li><li>软件运行维护阶段：版本、产品上线（版本的升级改进）BUG 的修复。</li></ol><h4 id="Q：介绍一下单元测试、集成测试、系统测试、验收测试、回归测试"><a href="#Q：介绍一下单元测试、集成测试、系统测试、验收测试、回归测试" class="headerlink" title="Q：介绍一下单元测试、集成测试、系统测试、验收测试、回归测试"></a>Q：介绍一下单元测试、集成测试、系统测试、验收测试、回归测试</h4><ul><li>单元测试：测试编码是否符合设计要求。软件中最小的测试单元，比如 go 中的一个函数。相关单元测试放在一起就是一个模块。</li><li>集成测试：就是接口测试，对接口是否能够实现进行测试，对接口实现后的结果进行测试。在单元测试的基础上将所有模块按照要求设计组装。测试不同模块之间是否按照预期工作，比如不同模块之间的数据传输。</li><li>系统测试：系统测试就是对可视化图形界面测试，对整个系统功能进行测。是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。</li><li>验收测试：验收测试就是模拟客户进行测试，确保软件各部分功能正常运行。确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括 Alpha 测试和 Beta 测试。</li><li>回归测试：在缺陷修复之后的检验测试，指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</li></ul><h4 id="Q：黑盒测试和白盒测试"><a href="#Q：黑盒测试和白盒测试" class="headerlink" title="Q：黑盒测试和白盒测试"></a>Q：黑盒测试和白盒测试</h4><ul><li><p>白盒测试又称为结构测试、逻辑驱动测试或基于程序本身的测试，着重于程序的内部结构及算法，通常不关心功能与性能指标。</p><ul><li>逻辑覆盖测试：语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖、路径覆盖</li><li>基本路径覆盖测试：选择足够的测试用例，使得运行这些测试用例时，被测程序的每条可能执行的路径都至少经过一次。</li></ul></li><li><p>黑盒测试又称为功能测试、数据驱动测试或基于规格说明的测试，实际上是站在最终用户的立场上，检验输入输出信息及系统性能指标是否符合规格说明书中有关功能需求及性能需求的规定。</p><ul><li>等价类划分法：主要解决穷举的问题</li><li>边界值分析法：选取正好等于、刚好大于、刚好小于边界的值作为测试数据</li></ul></li><li><p>灰盒测试是综合运用黑盒测试和白盒测试技术的一种混合测试方法。</p></li></ul><h4 id="Q：冒烟测试"><a href="#Q：冒烟测试" class="headerlink" title="Q：冒烟测试"></a>Q：冒烟测试</h4><p>冒烟测试是一种快速的功能测试，验证核心功能是否正常，目的是确认软件是否值得进行更详细的测试。</p><h4 id="Q：接口测试"><a href="#Q：接口测试" class="headerlink" title="Q：接口测试"></a>Q：接口测试</h4><p>接口测试其实最主要的验证接口逻辑，可用性，边界值，异常检查。</p><p>主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。</p><h4 id="Q：为什么要做接口测试"><a href="#Q：为什么要做接口测试" class="headerlink" title="Q：为什么要做接口测试"></a>Q：为什么要做接口测试</h4><ul><li>现在很多系统前后端架构是分离的，因为不同端的工作进度不一样，所以我们要针对最开始出来的接口，以及需要调用其他公司的一些接口进行接口测试及验证数据。</li><li>如今系统越来越复杂，传统的靠前端测试已经大大降低了效率，而且现在都推崇测试前移也叫测试左移，希望测试能更早的介入，那接口测试就是一种及早介入的方式。</li></ul><h4 id="Q：接口的组成"><a href="#Q：接口的组成" class="headerlink" title="Q：接口的组成"></a>Q：接口的组成</h4><p>接口说明、调用 url（请求的地址）、请求方法（get&#x2F;post）、请求参数、参数类型、参数说明。</p><h4 id="Q：性能测试"><a href="#Q：性能测试" class="headerlink" title="Q：性能测试"></a>Q：性能测试</h4><p>在整个测试中，应用程序的性能在预期的或更高的负载下进行评估。评估系统的不同性能属性，如响应时间（速度）、吞吐量、可靠性、资源使用率、可扩展性等。监控系统的各项指标，是否符合需求，如果不符合，就发现了系统的性能瓶颈。</p><ul><li>负载测试：通过在被测系统上不断加压（如逐渐增加模拟用户的数量），直到性能指标达到极限，来观察不同负载下系统的响应时间和数据吞吐量、系统占用的资源（如 CPU、内存）等。</li><li>压力测试：系统在强负载下的测试，例如 CPU、内存在饱和使用情况下，看系统在峰值使用情况下是否稳定，看系统处理会话的能力以及哪里会出问题。</li><li>容量测试：通过测试预先分析出系统某项指标的极限值（如最大并发用户数、数据库记录数等）。</li><li>并发测试：模拟多用户并发访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题。</li><li>配置测试：通过对被测系统软硬件环境的调整，了解各种不同环境对系统性能影响的程度，从而找到系统各项资源的最优分配原则。</li><li>可靠性测试（持久性测试）：给系统施加一定的业务压力，让其持续运行一段时间，测试在这种条件下能否稳定运行。</li></ul><h4 id="Q：性能测试常用指标"><a href="#Q：性能测试常用指标" class="headerlink" title="Q：性能测试常用指标"></a>Q：性能测试常用指标</h4><p>吞吐量、资源利用率（CPU、内存、带宽）、响应时间、响应时间分布、并发数、错误率、瓶颈分析、平台和网络性能。</p><h4 id="Q：测试用例八大要素"><a href="#Q：测试用例八大要素" class="headerlink" title="Q：测试用例八大要素"></a>Q：测试用例八大要素</h4><p>编号、标题、模块、前置条件、优先级、测试步骤、测试数据、预期结果。</p><h4 id="Q：驱动模块和桩模块"><a href="#Q：驱动模块和桩模块" class="headerlink" title="Q：驱动模块和桩模块"></a>Q：驱动模块和桩模块</h4><p>驱动模块和桩模块的设计模式有助于实现模块间的解耦、模块的独立开发和测试，以及提高系统的可维护性和可测试性。</p><ul><li><p>驱动模块（Driver）：<br>  驱动模块是指在软件系统中用于驱动或控制其他模块或组件的模块。它通常作为系统的入口点，负责协调和调用其他模块的功能。驱动模块可以是一个主程序、主服务或主类，它负责初始化系统，处理用户输入，协调各个模块之间的交互等。可以通过模拟一系列用户操作行为，比如选择用户界面上的某一个选项或者按下某个按钮等，自动调用被测试模块中的函数。</p></li><li><p>桩模块（Stub）：<br>  桩模块是指在软件开发中用于模拟或代替其他模块或组件的模块。它通常用于测试、仿真或替代系统中的某个模块，以便进行单元测试、集成测试或模块开发的并行工作。桩模块的设计目标是提供与实际模块相同的接口，但实现逻辑通常是简化的或者是空实现的。桩模块可以模拟其他模块的行为，返回预定义的数据或固定的结果，以便进行测试和验证。</p></li></ul><h4 id="Q：软件测试的关键点"><a href="#Q：软件测试的关键点" class="headerlink" title="Q：软件测试的关键点"></a>Q：软件测试的关键点</h4><ul><li>尽早发现缺陷，避免最后问题堆积导致无法解决或解决工程量巨大。</li><li>用尽量少的测试用例发现尽可能多的缺陷。</li><li>提升发现缺陷的效率。</li></ul><h4 id="Q：自动化测试的流程"><a href="#Q：自动化测试的流程" class="headerlink" title="Q：自动化测试的流程"></a>Q：自动化测试的流程</h4><ol><li>分析自动化测试需求，一般在手工测试之后开始</li><li>根据项目的特点、选择合适的自动化测试工具，并搭建测试环境</li><li>测试用例设计和开发：设计测试用例；或提取手工测试的测试用例，转化为自动化测试用例</li><li>开发自动化软件测试框架和测试脚本</li><li>执行：通过工具、代码实现自动化的构造输入、自动检测输出结果是否满足预期</li><li>生成自动测试报告</li><li>持续改进、脚本优化</li></ol><h4 id="Q：登陆界面测试"><a href="#Q：登陆界面测试" class="headerlink" title="Q：登陆界面测试"></a>Q：登陆界面测试</h4><ul><li><p>功能测试</p><ol><li>输入正确的用户名和密码，点击提交按钮，验证是否能正确登录</li><li>输入错误的用户名或者密码，验证登录会失败，并且提示相应的错误信息</li><li>登录成功后能否能否跳转到正确的页面</li><li>用户名和密码，如果太短或者太长，应该怎么处理</li><li>用户名和密码，中有特殊字符（比如空格），和其他非英文的情况</li><li>记住用户名的功能</li><li>登陆失败后，不能记录密码的功能</li><li>用户名和密码前后有空格的处理</li><li>密码是否非明文显示显示，使用星号圆点等符号代替</li><li>登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确</li><li>输入密码的时候，大写键盘开启的时候要有提示信息</li><li>什么都不输入，点击提交按钮，检查提示信息</li></ol></li><li><p>性能测试</p><ol><li>打开登录页面，需要的时间是否在需求要求的时间内</li><li>输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内</li><li>模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转</li></ol></li><li><p>兼容性测试</p><ol><li>不同浏览器下能否显示正常且功能正常</li><li>同种浏览器不同版本下能否显示正常且功能正常</li><li>不同的平台是否能正常工作，比如 Windows，Mac</li><li>移动设备上是否正常工作，比如 Iphone，Andriod</li><li>不同的分辨率下显示是否正常</li></ol></li><li><p>界面测试</p><ol><li>布局是否合理，testbox 和按钮是否整齐</li><li>testbox 和按钮的长度，高度是否复合要求</li><li>界面的设计风格是否与 UI 的设计风格统一</li><li>界面中的文字简洁易懂，没有错别字</li></ol></li><li><p>可用性测试</p><ol><li>是否可以全用键盘操作，是否有快捷键</li><li>输入用户名，密码后按回车，是否可以登陆</li><li>输入框能否可以以 Tab 键切换</li></ol></li><li><p>安全性测试</p><ol><li>登录成功后生成的 Cookie，是否是 HttpOnly</li><li>用户名和密码是否通过加密的方式，发送给 web 服务器</li><li>用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用 javascript 验证</li><li>用户名和密码的输入框，应该屏蔽 SQL 注入攻击</li><li>用户名和密码的的输入框，应该禁止输入脚本</li><li>防止暴力破解，检测是否有错误登陆的次数限制</li><li>是否支持多用户在同一机器上登录</li><li>同一用户能否在多台机器上登录</li></ol></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="Q：为什么需要-DevOps"><a href="#Q：为什么需要-DevOps" class="headerlink" title="Q：为什么需要 DevOps"></a>Q：为什么需要 DevOps</h4><p>软件开发公司在软件新版本发布方面，多尝试通过发布一系列以小的特性改变集为目标的新软件版本，代替发布一个大特性改变集的新软件版本的方式。</p><ul><li>增加软件布署的频率</li><li>降低新发布版本的失败率</li><li>缩短修复缺陷的交付时间</li><li>加快解决版本冲突的问题</li><li>自动化运维流程</li></ul><h4 id="Q：Redis-如何实现分布式锁"><a href="#Q：Redis-如何实现分布式锁" class="headerlink" title="Q：Redis 如何实现分布式锁"></a>Q：Redis 如何实现分布式锁</h4><h4 id="Q：Channel-是如何实现的"><a href="#Q：Channel-是如何实现的" class="headerlink" title="Q：Channel 是如何实现的"></a>Q：Channel 是如何实现的</h4><h4 id="Q：MySQL-慢查询可能的原因"><a href="#Q：MySQL-慢查询可能的原因" class="headerlink" title="Q：MySQL 慢查询可能的原因"></a>Q：MySQL 慢查询可能的原因</h4><h4 id="Q：进程、线程和协程在切换时分别需要重新分配什么资源"><a href="#Q：进程、线程和协程在切换时分别需要重新分配什么资源" class="headerlink" title="Q：进程、线程和协程在切换时分别需要重新分配什么资源"></a>Q：进程、线程和协程在切换时分别需要重新分配什么资源</h4><h4 id="Q：寻找两个正序数组的中位数"><a href="#Q：寻找两个正序数组的中位数" class="headerlink" title="Q：寻找两个正序数组的中位数"></a>Q：寻找两个正序数组的中位数</h4>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 08. 二叉树</title>
    <link href="/Algorithm-binaryTree/"/>
    <url>/Algorithm-binaryTree/</url>
    
    <content type="html"><![CDATA[<p>二叉树相关题目。</p><span id="more"></span><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h2><h3 id="1-1-二叉树的种类"><a href="#1-1-二叉树的种类" class="headerlink" title="1.1 二叉树的种类"></a>1.1 二叉树的种类</h3><ol><li><p><strong>满二叉树</strong></p><p> 如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上。</p><p> <img src="/Algorithm-binaryTree/1.png"></p></li><li><p><strong>完全二叉树</strong></p><p> 除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边。</p><p> <img src="/Algorithm-binaryTree/2.png"></p></li><li><p><strong>二叉搜索树</strong></p><p> 二叉搜索树（BST）是一个有序树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li><li>它的左、右子树也分别为二搜索树</li></ul><p> <img src="/Algorithm-binaryTree/3.png"></p></li><li><p><strong>平衡二叉搜索树</strong></p><p> AVL（Adelson-Velsky and Landis）树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p><p> <img src="/Algorithm-binaryTree/4.png"></p><p> <strong>左旋与右旋</strong>：右旋——自己变为左孩子的右孩子；左旋——自己变为右孩子的左孩子。</p><p> <img src="/Algorithm-binaryTree/10.png"></p></li><li><p><strong>红黑树</strong></p><p> 是一个接近平衡的二叉搜索树，每一个节点增加一个存储位表示其颜色。</p><p> <img src="/Algorithm-binaryTree/8.png"></p><p> <strong>性质</strong>：</p><ul><li>每个结点不是红色就是黑色</li><li>根节点是黑色的</li><li>如果一个节点是红色的，则它的两个孩子结点是黑色的</li><li>对于每个结点，从该结点到其所有后代叶子结点的路径上，均包含相同数目的黑色结点</li><li>每个叶子结点都是黑色的（此处的叶子结点指的是空结点）</li></ul><p> 其最长路径中节点个数不会超过最短路径节点个数的两倍，因为最短路径为全黑，最长路径就是红黑节点交替（因为红色节点不能连续），每条路径的黑色节点相同，则最长路径刚好是最短路径的两倍。</p></li><li><p><strong>哈夫曼树</strong></p><p> 给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree），哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p> 所有<strong>叶结点</strong>的带权路径长度之和：WPL &#x3D; ∑(叶子节点权值 * 节点深度)</p><p> <strong>构造哈夫曼树</strong>：</p><ol><li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li><li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n-2 个权值的行列中，以此类推；</li><li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li></ol><p> <img src="/Algorithm-binaryTree/9.png"></p><p> 哈夫曼编码算法是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法根据文本字符出现的频率，重新对字符进行编码。为了缩短编码的长度，自然希望频率越高的词编码越短，这样最终才能最大化压缩存储文本数据的空间。</p></li></ol><h3 id="1-2-二叉树的存储方式"><a href="#1-2-二叉树的存储方式" class="headerlink" title="1.2 二叉树的存储方式"></a>1.2 二叉树的存储方式</h3><p>二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。</p><ul><li>链式存储</li></ul><p><img src="/Algorithm-binaryTree/5.png"></p><ul><li>顺序存储</li></ul><p><img src="/Algorithm-binaryTree/6.png"></p><p>如果父节点的数组下标是 <code>i</code>，那么它的左孩子就是 <code>i * 2 + 1</code>，右孩子就是 <code>i * 2 + 2</code>。</p><h3 id="1-3-二叉树的定义"><a href="#1-3-二叉树的定义" class="headerlink" title="1.3 二叉树的定义"></a>1.3 二叉树的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;<br>    Val   <span class="hljs-type">int</span><br>    Left  *TreeNode<br>    Right *TreeNode<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2 遍历"></a>2 遍历</h2><ul><li><p>深度优先遍历：先往深走，遇到叶子节点再往回走。</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li><li><p>广度优先遍历：一层一层的去遍历。</p><ul><li>层次遍历</li></ul></li></ul><p>做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h3 id="2-1-前序遍历：leetcode-144-题"><a href="#2-1-前序遍历：leetcode-144-题" class="headerlink" title="2.1 前序遍历：leetcode 144 题"></a>2.1 <strong>前序遍历</strong>：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">leetcode 144 题</a></h3><p>递归：</p><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> <br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, node.Val)<br>        dfs(node.Left)<br>        dfs(node.Right)<br>    &#125;<br><br>    dfs(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> stack []*TreeNode<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    stack = <span class="hljs-built_in">append</span>(stack, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        res = <span class="hljs-built_in">append</span>(res, node.Val)<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-层序遍历：leetcode-102-题"><a href="#2-2-层序遍历：leetcode-102-题" class="headerlink" title="2.2 层序遍历：leetcode 102 题"></a>2.2 <strong>层序遍历</strong>：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">leetcode 102 题</a></h3><p>二叉树层序遍历递归法并非一层一层生成结果，而是创建好二维切片，遍历树根据 depth 填入对应切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>arr := [][]<span class="hljs-type">int</span>&#123;&#125;<br>depth := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> order <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode, depth <span class="hljs-type">int</span>)</span></span><br>order = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode, depth <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == depth &#123;<br>arr = <span class="hljs-built_in">append</span>(arr, []<span class="hljs-type">int</span>&#123;&#125;)<br>&#125;<br>arr[depth] = <span class="hljs-built_in">append</span>(arr[depth], root.Val)<br><br>order(root.Left, depth+<span class="hljs-number">1</span>)<br>order(root.Right, depth+<span class="hljs-number">1</span>)<br>&#125;<br><br>order(root, depth)<br><span class="hljs-keyword">return</span> arr<br>&#125;<br><br><span class="hljs-comment">// 切片模拟队列</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-keyword">var</span> queue []*TreeNode<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        l := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">var</span> temp []<span class="hljs-type">int</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<br>            node := queue[i]<br>            temp = <span class="hljs-built_in">append</span>(temp, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        queue = queue[l:]<br>        res = <span class="hljs-built_in">append</span>(res, temp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-题目"><a href="#3-题目" class="headerlink" title="3 题目"></a>3 题目</h2><h3 id="3-1-leetcode-101-题"><a href="#3-1-leetcode-101-题" class="headerlink" title="3.1 leetcode 101 题"></a>3.1 <a href="https://leetcode.cn/problems/symmetric-tree/">leetcode 101 题</a></h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node1, node2 *TreeNode)</span></span> <span class="hljs-type">bool</span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node1, node2 *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">if</span> node1 == <span class="hljs-literal">nil</span> &amp;&amp; node2 == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node1 == <span class="hljs-literal">nil</span> &amp;&amp; node2 != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node1 != <span class="hljs-literal">nil</span> &amp;&amp; node2 == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node1.Val != node2.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dfs(node1.Left, node2.Right) &amp;&amp; dfs(node1.Right, node2.Left)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dfs(root.Left, root.Right)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-leetcode-104-题"><a href="#3-2-leetcode-104-题" class="headerlink" title="3.2 leetcode 104 题"></a>3.2 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/">leetcode 104 题</a></h3><p>给定一个二叉树，找出其最大深度。</p><p>根节点的高度就是二叉树的最大深度，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(root *Treenode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxdepth(root.Left), maxdepth(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-leetcode-404-题"><a href="#3-3-leetcode-404-题" class="headerlink" title="3.3 leetcode 404 题"></a>3.3 <a href="https://leetcode.cn/problems/sum-of-left-leaves/">leetcode 404 题</a></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, isLeft <span class="hljs-type">bool</span>)</span></span> <br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, isLeft <span class="hljs-type">bool</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &amp;&amp; isLeft &#123;<br>            sum += node.Val<br>        &#125;<br>        dfs(node.Left, <span class="hljs-literal">true</span>)<br>        dfs(node.Right, <span class="hljs-literal">false</span>)<br>    &#125;<br><br>    dfs(root, <span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-leetcode-112-题"><a href="#3-4-leetcode-112-题" class="headerlink" title="3.4 leetcode 112 题"></a>3.4 <a href="https://leetcode.cn/problems/path-sum/">leetcode 112 题</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum。判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 targetSum。如果存在，返回 true；否则，返回 false。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum1</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">bool</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, sum <span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, sum <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        sum += node.Val<br>        <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &amp;&amp; sum == targetSum &#123;<br>            res = <span class="hljs-literal">true</span><br>        &#125;<br>        dfs(node.Left, sum)<br>        dfs(node.Right, sum)<br>    &#125;<br>    dfs(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum2</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    targetSum -= root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; targetSum == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.Left, targetSum) || hasPathSum(root.Right, targetSum)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-leetcode-106-题"><a href="#3-5-leetcode-106-题" class="headerlink" title="3.5 leetcode 106 题"></a>3.5 <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">leetcode 106 题</a></h3><p>从中序与后序遍历序列构造二叉树。</p><p><img src="/Algorithm-binaryTree/7.png"></p><ol><li>如果数组大小为零的话，说明是空节点了</li><li>如果不为空，那么取后序数组最后一个元素作为节点元素</li><li>找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>切割中序数组，切成中序左数组和中序右数组</li><li>切割后序数组，切成后序左数组和后序右数组</li><li>递归处理左区间和右区间</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    root := &amp;TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    v := postorder[<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">var</span> cut <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[i] == v &#123;<br>            cut = i<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    root.Val = v<br>    root.Left = buildTree(inorder[:cut], postorder[:cut])<br>    root.Right = buildTree(inorder[cut+<span class="hljs-number">1</span>:], postorder[cut:<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>])<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-leetcode-503-题"><a href="#3-6-leetcode-503-题" class="headerlink" title="3.6 leetcode 503 题"></a>3.6 <a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/submissions/">leetcode 503 题</a></h3><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p><strong>二叉搜索树采用中序遍历，其实就是一个有序数组。</strong>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><p>其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。需要用一个 pre 节点记录一下 cur 节点的前一个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> prev *TreeNode<br>    min := math.MaxInt64<br>    <span class="hljs-keyword">var</span> travel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    travel = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <br>        &#125;<br>        travel(node.Left)<br>        <span class="hljs-keyword">if</span> prev != <span class="hljs-literal">nil</span> &amp;&amp; node.Val - prev.Val &lt; min &#123;<br>            min = node.Val - prev.Val<br>        &#125;<br>        prev = node<br>        travel(node.Right)<br>    &#125;<br>    travel(root)<br>    <span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7-leetcode-236-题"><a href="#3-7-leetcode-236-题" class="headerlink" title="3.7 leetcode 236 题"></a>3.7 <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode 236 题</a></h3><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p><p>求最小公共祖先，需要从底向上遍历，那么二叉树只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root == p || root == q &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <span class="hljs-keyword">if</span> right != <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-keyword">return</span> right<br>&#125;<br></code></pre></td></tr></table></figure><p>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的 left 和 right）做逻辑判断。</p><h3 id="3-8-leetcode-701-题"><a href="#3-8-leetcode-701-题" class="headerlink" title="3.8 leetcode 701 题"></a>3.8 <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">leetcode 701 题</a></h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        root = &amp;TreeNode&#123;Val: val&#125;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-9-leetcode-450-题"><a href="#3-9-leetcode-450-题" class="headerlink" title="3.9 leetcode 450 题"></a>3.9 <a href="https://leetcode.cn/problems/delete-node-in-a-bst/">leetcode 450 题</a></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。</p><p>单层递归的逻辑有以下五种情况：</p><ol><li>没找到删除的节点，遍历到空节点直接返回了</li><li>删除节点的左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>删除节点的左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ol><p><img src="/Algorithm-binaryTree/1.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> key &lt; root.Val &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> key &gt; root.Val &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &amp;&amp; root.Left == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Right<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp := root.Left <br>            cur := root.Right<br>            <span class="hljs-keyword">for</span> cur.Left != <span class="hljs-literal">nil</span> &#123;<br>                cur = cur.Left<br>            &#125;<br>            cur.Left = temp<br>            <span class="hljs-keyword">return</span> root.Right<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-10-LCR-143-题"><a href="#3-10-LCR-143-题" class="headerlink" title="3.10 LCR 143 题"></a>3.10 <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">LCR 143 题</a></h3><p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(A *TreeNode, B *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> B == <span class="hljs-literal">nil</span> || A == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> isSub(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSub</span><span class="hljs-params">(A, B *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> B == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> A == <span class="hljs-literal">nil</span> || A.Val != B.Val &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> isSub(A.Left, B.Left) &amp;&amp; isSub(A.Right, B.Right)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-11-leetcode-662-题"><a href="#3-11-leetcode-662-题" class="headerlink" title="3.11 leetcode 662 题"></a>3.11 <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">leetcode 662 题</a></h3><p>二叉树最大宽度。</p><p>使用父节点与子节点在数组中的编号关系来做。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    levelmin := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, level, idx <span class="hljs-type">int</span>)</span></span> <br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, level, idx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        dfs(node.Left, level+<span class="hljs-number">1</span>, idx*<span class="hljs-number">2</span>)<br>        m, exist := levelmin[level]<br>        <span class="hljs-keyword">if</span> !exist &#123;<br>            levelmin[level] = idx<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res = max(res, idx - m)<br>        &#125;<br>        dfs(node.Right, level+<span class="hljs-number">1</span>, idx*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<br>    &#125;<br>    dfs(root, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 HTTP 和 QUIC</title>
    <link href="/Research-QUIC/"/>
    <url>/Research-QUIC/</url>
    
    <content type="html"><![CDATA[<p>QUIC（Quick UDP Internet Connections）是一种基于 UDP 的传输协议，旨在加速 HTTP 通信，同时使其变得更加安全，其最终目的是在 web 上代替 TCP 和 TLS 协议。</p><span id="more"></span><h2 id="HTTP-发展史"><a href="#HTTP-发展史" class="headerlink" title="HTTP 发展史"></a>HTTP 发展史</h2><p>Hyper Text Transfer Protocol（超文本传输协议），是用于从万维网（WWW：World Wide Web）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。</p><p><img src="/Research-QUIC/3.png" alt="HTTP protocol"></p><h3 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h3><p>HTTP 是基于 TCP&#x2F;IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。 最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令：GET。</p><p>TCP 连接建立后，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。服务器发送完毕，就关闭 TCP 连接。</p><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>1996 年 5 月，HTTP&#x2F;1.0 版本发布，内容大大增加：</p><ul><li>任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。</li><li>除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。</li><li>HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</li><li>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</li></ul><p>HTTP&#x2F;1.0 的主要缺点：</p><ul><li>每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li><li>TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（Slow start）。</li></ul><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>1997 年 1 月，HTTP&#x2F;1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议：</p><ul><li><strong>长连接</strong>：HTTP&#x2F;1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</li><li><strong>缓存处理</strong>：HTTP&#x2F;1.1 引入了更多的缓存控制策略。</li><li><strong>带宽优化及网络连接的使用</strong>：HTTP&#x2F;1.0 中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能；HTTP&#x2F;1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>：新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host 头处理</strong>：在 HTTP&#x2F;1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。HTTP&#x2F;1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li></ul><p>HTTP&#x2F;1.1 的主要缺点：</p><ul><li>同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<strong>队头堵塞</strong>（Head-of-line blocking）。</li><li>HTTP&#x2F;1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li><li>HTTP&#x2F;1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</li><li>虽然 HTTP&#x2F;1.x 支持了 keep-alive，来弥补多次创建连接产生的延迟，但是 keep-alive 使用多了同样会给服务端带来大量的性能压力，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ul><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>2009 年，Google 公开了自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。 这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP&#x2F;2 的基础，主要特性都在 HTTP&#x2F;2 之中得到继承：</p><ul><li><strong>降低延迟</strong>：针对 HTTP 高延迟的问题，SPDY 采取了<strong>多路复用</strong>（multiplexing），通过多个请求 stream 共享一个 tcp 连接的方式，降低延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。</li><li><strong>header 压缩</strong>：前面提到 HTTP&#x2F;1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>加密传输</strong>：基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>：采用了 SPDY 的网页，例如网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。</li></ul><p><img src="/Research-QUIC/1.png" alt="SPDY"></p><h3 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2 是基于 HTTPS 的，可以说是 SPDY 的升级版（其实原本也是基于 SPDY 设计的），但是 HTTP&#x2F;2 跟 SPDY 仍有不同的地方：</p><ul><li>HTTP&#x2F;2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。</li><li>HTTP&#x2F;2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE。</li></ul><p><img src="/Research-QUIC/2.png" alt="multiplexing"></p><p>在 Internet 和 HTTP 的发展过程中，HTTP 的底层传输机制基本没有变化。然而，随着移动设备技术的大规模普及，实时应用需求的增加，互联网流量不断增长，HTTP&#x2F;2 的缺点也越来越明显。</p><h3 id="HTTP-x2F-3-0"><a href="#HTTP-x2F-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h3><p>HTTP&#x2F;2 的最大特性就是多路复用，但是每个 HTTP 连接都是由 TCP 进行连接建立和传输的，TCP 协议在处理包时有严格的顺序要求。这也就是说，当某个包切分的 stream 由于某些原因丢失后，服务器不会处理其他 stream，而会优先等待客户端发送丢失的 stream。</p><p>HTTP&#x2F;3 使用了一种名为 QUIC 的协议，该协议运行在 UDP 协议之上，而不是 TCP。UDP 允许消息的多向广播，这一特性有助于解决数据包级别的<strong>队头阻塞</strong>问题。</p><p>此外，QUIC 重新设计了客户端和服务器之间握手的方式，减少了与建立重复连接相关的延迟。</p><p><img src="/Research-QUIC/5.png" alt="重复连接时的 handshake"></p><p>HTTP&#x2F;3 在语法和语义上与 HTTP&#x2F;2 相似，遵循着相同的请求和响应消息交换顺序，其数据格式包含方法、报头、状态码和正文。HTTP&#x2F;3 的显着差异在于 UDP 之上协议层的堆叠顺序，如下图所示。</p><p><img src="/Research-QUIC/6.png" alt="比较"></p><h2 id="TCP-的局限性"><a href="#TCP-的局限性" class="headerlink" title="TCP 的局限性"></a>TCP 的局限性</h2><ul><li><p><strong>TCP 的队头阻塞</strong></p><p>  如果序列号较低的数据段尚未到达&#x2F;接收，即使序列号较高的段已经到达&#x2F;接收，TCP 的接收器滑动窗口也不会前进。这会导致 TCP 流暂时挂起甚至关闭，这个问题称为 TCP 流的<strong>队头阻塞</strong>。队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。</p></li></ul><p><img src="/Research-QUIC/7.png" alt="HoL"></p><ul><li><p><strong>TCP 不支持流级多路复用</strong></p><p>  虽然 TCP 允许与应用层之间的多个逻辑连接，但它不允许在单个 TCP 流中多路复用数据包。使用 HTTP&#x2F;2，浏览器只能打开一个与服务器的 TCP 连接。它使用同一个连接来请求多个对象，例如 CSS、JavaScript 和其他文件。在接收这些对象时，TCP将同一流中的所有对象序列化。因此，它不知道 TCP 段的对象级分区。</p></li><li><p><strong>TCP 握手导致连接成本</strong></p><p>  在进行连接握手时，TCP 交换一系列消息，如果与已知主机建立连接，会有冗余的消息交换序列。对于很多短连接场景，这样的握手延迟影响很大，且无法消除。</p></li></ul><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>在 TCP 中，TCP 为了保证数据的可靠性，使用了序号 + 确认号机制来实现，一旦带有 synchronize sequence number 的包发送到服务器，服务器都会在一定时间内进行响应，如果过了这段时间没有响应，客户端就会重传这个包，直到服务器收到数据包并作出响应为止。</p><p>虽然 QUIC 没有使用 TCP 协议，但是它也保证了可靠性，QUIC 实现可靠性的机制是使用了 Packet Number，这个序列号可以认为是 syn 的替代者，这个序列号也是递增的。与 syn 所不同的是，不管服务器有没有接收到数据包，这个 Packet Number 都会 +1，而 syn 是只有服务器发送 ack 响应之后，syn 才会 +1。</p><p><img src="/Research-QUIC/9.png" alt="序列号"></p><p>QUIC 引入了一个 stream offset 的概念，一个 stream 可以传输多个 stream offset，每个 stream offset 其实就是一个 PN 标识的数据，即使某个 PN 标识的数据丢失，PN+1 后，它重传的仍旧是 PN 所标识的数据，等到所有 PN 标识的数据发送到服务器，就会进行重组，以此来保证数据可靠性。到达服务器的 stream offset 会按照顺序进行组装，这同时也保证了数据的顺序性。</p><p><img src="/Research-QUIC/10.png" alt="stream offset"></p><p>QUIC 相比于 HTTP&#x2F;2 具有下面这些优势：</p><ul><li><p><strong>选择 UDP 作为底层传输层协议</strong></p><p>  如果还在TCP 之上的建立新的传输机制，将仍继承前面所说的TCP限制。QUIC 是在用户级别构建的，它不需要在每次协议升级时更改内核，从而更易采用。</p></li><li><p><strong>流复用和流量控制</strong></p><p>  QUIC 引入了在单个连接上多路复用流的概念。QUIC 实现了单独的、逐流的流量控制。UDP 本身没有建立连接这个概念，QUIC 使用的 stream 之间是相互隔离的，不会阻塞其他 stream 数据的处理，所以使用 UDP 并不会造成队头阻塞。</p></li></ul><p><img src="/Research-QUIC/8.png" alt="使用 UDP，没有包级的队头阻塞"></p><ul><li><p><strong>灵活的拥塞控制</strong></p><p>  TCP 有严格的拥塞控制机制。每次 TCP 协议检测到拥塞时，它都会将拥塞窗口的大小减半。QUIC 的拥塞控制更加灵活，从内核空间到用户空间，可以更有效地利用可用网络带宽，从而获得更好的流量吞吐量。</p></li><li><p><strong>更好的错误处理</strong></p><p>  QUIC 提议使用增强的丢失恢复机制和前向纠错来处理错误的数据包，尤其是对于在传输中容易出现高错误率的缓慢的无线网络。</p></li><li><p><strong>更快地握手</strong></p><p>  QUIC 使用与 HTTP&#x2F;2 相同的 TLS 模块来实现安全连接。然而，与 TCP 不同的是，QUIC 的握手机制经过优化，可以避免在两个已知对等点相互建立通信时进行冗余协议交换。使用 TCP 和 TLS 建立安全连接至少需要两次往返时间（RTT），增加了延迟开销。使用 QUIC，建立第一个加密连接是 1 个 RTT，当会话恢复时，有效负载数据与第一个数据包一起发送，RTT 最少为零。</p></li></ul><p><img src="/Research-QUIC/11.png" alt="QUIC"></p><ul><li><p><strong>语法和语义</strong></p><p>  通过在 QUIC 之上构建基于 HTTP&#x2F;3 的应用层，可以获得增强传输机制的所有优势，同时保留与 HTTP&#x2F;2 相同的语法和语义。但是 HTTP&#x2F;2 不能直接与 QUIC 集成，因为从应用到传输的底层帧映射是不兼容的。因此，IETF 的 HTTP 工作组建议将 HTTP&#x2F;3 作为新的 HTTP 版本，并根据 QUIC 协议的帧格式要求修改其帧映射。</p></li><li><p><strong>压缩</strong></p><p>  HTTP&#x2F;3 还使用了一种称为 QPACK 的新报头压缩机制，是对 HTTP&#x2F;2 中使用的 HPACK 的修改。在 QPACK 下，HTTP 报头可以在不同的 QUIC 流中乱序到达。QPACK 使用了一种查找表机制来对报头进行编码和解码。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> QUIC 作为一个新的传输层协议，它在设计上针对 TCP 的不足进行了很多优化。它提供的多路传输、快速握手等新特性使得它和 TCP 相比在理论上可以获得更低的数据传输延时。现有测量工作表明，QUIC 在大部分情况下的确能比 TCP 达到更低的传输延时，但是仍然有部分情况下 QUIC 的表现不如 TCP。这些 QUIC 性能表现较差的场景往往是拥塞算法的选择、服务器部署等外部因素造成的，而非 QUIC 本身的设计缺陷。因此，QUIC 的软件实现仍然有很大的进步空间。</p><p> 另外关于队头阻塞的问题，本文描述过于简略，有兴趣可以学习<a href="https://www.cnblogs.com/sexintercourse/p/16839900.html">这篇文章</a>。</p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 TCP 连接</title>
    <link href="/Research-Handshake/"/>
    <url>/Research-Handshake/</url>
    
    <content type="html"><![CDATA[<p>本文总结 TCP 的三次握手和四次挥手，以及 TLS&#x2F;SSL 的四次握手过程。</p><span id="more"></span><h2 id="1-TCP-连接的建立（三次握手）"><a href="#1-TCP-连接的建立（三次握手）" class="headerlink" title="1 TCP 连接的建立（三次握手）"></a>1 TCP 连接的建立（三次握手）</h2><p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><p><img src="/Research-Handshake/1.png" alt="三次握手"></p><ol><li><p>TCP 服务器进程先创建传输控制块 TCB，准备接受连接请求，此时服务器就进入了 LISTEN（监听）状态。</p></li><li><p>TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文。报文首部中的同部位 SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x。此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN&#x3D;1 的报文段）不能携带数据，但需要消耗掉一个序号。</p></li><li><p>TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中 ACK&#x3D;1，SYN&#x3D;1，确认号是 ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p></li><li><p>TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK&#x3D;1，ack&#x3D;y+1，自己的序列号 seq&#x3D;x+1，此时，TCP连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段<strong>可以</strong>携带数据，如果<strong>不携带数据则不消耗序号</strong>。</p></li><li><p>当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。</p></li></ol><blockquote><p><strong>为什么 TCP 客户端最后还要发送一次确认呢？</strong></p><p>主要防止已经失效的连接请求报文传送到服务器，重复历史连接的初始化。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时滞留的请求连接，网络通畅到达了服务器，这个报文本该是失效的，但是两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><h2 id="2-TCP-连接的释放（四次挥手）"><a href="#2-TCP-连接的释放（四次挥手）" class="headerlink" title="2 TCP 连接的释放（四次挥手）"></a>2 TCP 连接的释放（四次挥手）</h2><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p><p><img src="/Research-Handshake/2.png" alt="四次挥手"></p><ol><li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN&#x3D;1，其序列号为 seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</p></li><li><p>服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号 seq&#x3D;v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p></li><li><p>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p></li><li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq&#x3D;w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是 seq&#x3D;u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p></li><li><p>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p></li></ol><blockquote><p><strong>为什么客户端最后还要等待 2 MSL？</strong></p><p>MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。</p><p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2 MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2 MSL 计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2 MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><blockquote><p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p></blockquote><h2 id="3-TLS-x2F-SSL-握手"><a href="#3-TLS-x2F-SSL-握手" class="headerlink" title="3 TLS&#x2F;SSL 握手"></a>3 TLS&#x2F;SSL 握手</h2><p>SSL（Secure Socket Layer 安全套接层）是 TCP&#x2F;IP 协议中位于 HTTP 之下，TCP 之上的一个可选协议层。起初 HTTP 在传输数据时使用的是明文，是不安全的。为了解决这个隐患，网景（Netscap）公司推出了 SSL，使得报⽂能够加密传输。</p><p>HTTPS（HTTP+SSL）的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时， 互联网工程任务组（IETF）对 SSL 3.0 进行了标准化，并添加了少数机制，并将其更名为 TLS 1.0（Transport Layer Security 安全传输层协议）。</p><p><img src="/Research-Handshake/3.png" alt="HTTPS = HTTP + TLS/SSL"></p><p>在 HTTPS 协议中，当客户端与服务器通过三次握手建立 TCP 连接之后，并不会直接传输数据，而是会经过一个 SSL&#x2F;TLS 握手的过程，用于协商、以及验证证书等，之后就可以安全传输数据了。</p><p>通信建立前：采用非对称加密的方式交换会话密钥，后续不再使用非对称加密。<br>通信过程中：全部使用对称加密的会话密钥方式，加密明文数据。</p><p><img src="/Research-Handshake/4.png" alt="TLS/SSL 握手"></p><ol><li><p>Client Hello：由客户端发起，主要包含以下信息：</p><ul><li>客户端生成的随机数 x，用于之后的密钥生成</li><li>客户端支持的加密算法列表（Cipher Suites）</li><li>TLS 版本信息</li><li>客户端支持的压缩算法列表（Compression Methods）</li></ul></li><li><p>Server Hello：服务端接收到客户端的 Client Hello 之后，服务端需要将自己的 CA 证书发送给客户端，这个步骤叫 Server Certificate。证书是对服务端的一种认证，是由专门的数字证书认证机构（CA）审核之后颁发的，所以一般人无法伪造。在颁发证书的同时还会产生两把钥匙，一把私钥，一把公钥。私钥由服务端保管不可泄露，公钥则附带在证书中公开。证书本身还附带了一个证书电子签名，这个签名用来验证证书的完整性和真实性，防止证书被人窜改。跟客户端一样，服务端也需要生产一个随机数 y 发送给客户端，客户端和服务端都需要使用这俩随机数生成通信密钥，这个过程叫 Server Key Exchange。最后服务端会发送一个 Server Hello Done 给到客户端，表示 Server Hello 过程结束。综上，由服务端发起的消息内容，主要包含：</p><ul><li>确认使用的加密通信协议版本，比如 TLS 1.2 版本。如果客户端和服务端支持的版本不一致，服务端关闭加密通信</li><li>服务端生成的随机数 y，用于之后的密钥生成</li><li>在客户端发送的加密算法列表里选一个加密算法，比如 RSA 公钥加密</li><li>服务器 CA 证书</li></ul></li><li><p>Certificate Verify：如果服务端需要客户端进行验证，在客户端收到服务端的 Server Hello 消息之后，首先需要向服务端发送客户端的证书，让服务端验证客户端的合法性。这个过程叫 Client Certificate。接着，客户端需要对服务端的证书进行检查，如果证书不是可信机构颁布、或证书中的域名与实际域名不符、或者证书已过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没问题，客户端就会从服务器证书中取出服务端公钥。这个过程叫 Certificate Verify。客户端用这个服务端的公钥加密一个随机数 z，并把这个加密过的随机数发送给服务端，这个过程叫 Client Key Exchange。由客户端会告诉服务端已经切换到协商好的加密算法的状态了，这个过程叫 Change Cipher Spec。最后由已经协商好的加密算法和之前的随机数 x、y、z，产生的一个密钥就是整个消息加密解密过程的核心所在了。这个过程叫 Encrypted Handshake Message。综上，由客户端发送给服务端的信息如下：</p><ul><li>由服务器公钥加密过的随机数 z，用于生成服务器的密钥</li><li>编码改变通知，表示随后的信息都将由双方协商的加密方法和密钥发送</li><li>客户端 TLS 握手结束通知，这一项也是前面发送所有内容的哈希值，用来供服务器校验</li></ul></li><li><p>Server Finish：服务端在接收到客户端传来的加密过的随机数 z 之后，使用自己的私钥对其进行解密获取随机数 z，并对数据进行验证。验证无误，用协商好的加密算法和之前的随机数 x、y、z 产生服务器密钥，它和客户端生成的密钥是一致的，因为此后的加密都是对称加密了。这个过程叫 Encrypted Handshake Message。等一切完毕之后，会给客户端发送通知，告知客户端已经切换到协商过的加密算法，这个过程叫 Change Cipher Spec。</p></li></ol><h2 id="4-TCP-可靠性保证"><a href="#4-TCP-可靠性保证" class="headerlink" title="4 TCP 可靠性保证"></a>4 TCP 可靠性保证</h2><h3 id="4-1-校验和"><a href="#4-1-校验和" class="headerlink" title="4.1 校验和"></a>4.1 校验和</h3><p>在 TCP 通信中，发送方会对数据段（包含待传输的数据）计算校验和，并将其添加到数据段的头部。接收方在接收数据段后，同样计算数据的校验和，并与数据段头部中的校验和进行比较。如果两者不一致，就说明数据在传输过程中发生了错误，接收方会请求发送方重新传输数据。</p><h3 id="4-2-序列号"><a href="#4-2-序列号" class="headerlink" title="4.2 序列号"></a>4.2 序列号</h3><p>在 TCP 通信中，每个传输的数据包都会附带一个序列号，用于标识数据的顺序。接收方会发送确认（ACK）来告知发送方已经收到哪个序列号的数据。如果发送方未收到确认，它会重传相应的数据。</p><h3 id="4-3-超时重传"><a href="#4-3-超时重传" class="headerlink" title="4.3 超时重传"></a>4.3 超时重传</h3><p>发送方会设置一个定时器，以便在一定时间内等待接收方的确认。如果在该时间内未收到确认，发送方会认为数据包丢失，并重新发送。</p><h3 id="4-4-连接管理"><a href="#4-4-连接管理" class="headerlink" title="4.4 连接管理"></a>4.4 连接管理</h3><p>TCP 在通信开始时通过三次握手建立连接，并在通信结束时通过四次挥手正确地终止连接，以确保数据的完整传输。</p><h3 id="4-5-流量管理"><a href="#4-5-流量管理" class="headerlink" title="4.5 流量管理"></a>4.5 流量管理</h3><p>TCP 使用滑动窗口机制来控制发送方和接收方之间的数据流量。接收方通过发送窗口大小告知发送方自己的缓冲区还有多少可用空间，从而控制发送方的发送速率，避免数据的过度拥塞。</p><h3 id="4-6-拥塞控制"><a href="#4-6-拥塞控制" class="headerlink" title="4.6 拥塞控制"></a>4.6 拥塞控制</h3><p>拥塞控制是为了防止过多的数据注入到网络中，造成网络拥塞。发送端拥有一个拥塞窗口，在发送数据前会对比接收方的滑动窗口大小，取较小值。</p><p>拥塞控制有四种算法，慢启动、拥塞避免，快速重传和快速恢复：</p><ul><li><p><strong>慢启动</strong>：主机先以比较小的拥塞窗口进行数据发送，由小到大逐渐增加拥塞窗口的大小，这个大小最终是指数增长的。为了防止拥塞窗口 cwnd 增长过快，还要设置一个慢启动阈值，当拥塞窗口的大小超过慢启动阈值时（cwnd &gt; ssthresh），停止使用慢启动算法而改用拥塞避免算法。</p></li><li><p><strong>拥塞避免</strong>：算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。</p></li><li><p><strong>快速重传 + 快速恢复</strong>：当发送端连续收到三个重复的 ack 时，表示该数据段已经丢失，需要重发。进入快速恢复状态，此时 ssthresh 变为拥塞时 cwnd 的一半，拥塞窗口 cwnd &#x3D; ssthresh + 3。</p></li></ul><p><img src="/Research-Handshake/6.png"></p><ul><li><strong>普通的恢复方式</strong>：当超过设定的时间没有收到某个报文段的 ack 时，表示网络拥塞。此时慢启动阈值 ssthresh 变为 cwnd 的一半，拥塞窗口 cwnd &#x3D; 1，进入慢启动阶段。</li></ul><p><img src="/Research-Handshake/5.png"></p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 5. Fabric 的改进</title>
    <link href="/Project5-Thinking/"/>
    <url>/Project5-Thinking/</url>
    
    <content type="html"><![CDATA[<p>本文总结论文阅读中对于 Fabric 的改进方案，并梳理一下毕设的改进思路。</p><span id="more"></span><h2 id="1-Fabric-1"><a href="#1-Fabric-1" class="headerlink" title="1 Fabric [1]"></a>1 Fabric [1]</h2><h3 id="1-1-交易流程"><a href="#1-1-交易流程" class="headerlink" title="1.1 交易流程"></a>1.1 交易流程</h3><p><img src="/Project5-Thinking/1.png" alt="Fabric"></p><ol><li>客户将其交易发送给一定数量的背书节点。</li><li>每个背书节点在隔离环境中模拟执行交易，并计算相应的读写集以及访问的每个键的版本号。模拟成功后返回背书响应给客户端。</li><li>客户端收集足够数量的背书，然后将这些响应打包发送给排序节点。</li><li>排序节点首先对传入交易的顺序达成共识，然后将消息队列划分为块。</li><li>块被传递给对等节点，然后由对等节点验证并提交它们。</li></ol><h3 id="1-2-阶段展示"><a href="#1-2-阶段展示" class="headerlink" title="1.2 阶段展示"></a>1.2 阶段展示</h3><p><img src="/Project5-Thinking/2.png" alt="Phases"></p><h3 id="1-3-改进思路"><a href="#1-3-改进思路" class="headerlink" title="1.3 改进思路"></a>1.3 改进思路</h3><p>有实验使用 Fabric 网络发送大量的转账交易，结果如下：</p><p><img src="/Project5-Thinking/3.png" alt="TPS"></p><p>可以看出大量的交易因为读写冲突被中止了，而发送空白交易的对比试验总的 TPS 与发送转账交易的 TPS 相差不大，这说明系统的瓶颈并不在于智能合约的计算上。</p><p>由此可以得出两种改进思路：</p><ul><li><p>增加系统的整体吞吐量</p></li><li><p>将原本会被 Fabric 中止的交易变为成功的交易</p></li></ul><h2 id="2-增加吞吐量"><a href="#2-增加吞吐量" class="headerlink" title="2 增加吞吐量"></a>2 增加吞吐量</h2><h3 id="2-1-Optimizing-Fabric-2"><a href="#2-1-Optimizing-Fabric-2" class="headerlink" title="2.1 Optimizing Fabric [2]"></a>2.1 Optimizing Fabric [2]</h3><p>此文对 Fabric 1.0 做了大量测试，发现以下<strong>瓶颈</strong>：</p><ol><li>身份的加密操作</li><li>区块中的交易串行验证</li><li>对 CouchDB 的多个 REST API 调用</li></ol><p><strong>优化</strong>（单通道提升 16 倍）：</p><ol><li>MSP Cache</li><li>并行 VSCC 验证</li><li>区块 MVCC 验证时的批量读写</li></ol><h3 id="2-2-FastFabric-3"><a href="#2-2-FastFabric-3" class="headerlink" title="2.2 FastFabric [3]"></a>2.2 FastFabric [3]</h3><p><strong>优化</strong>：</p><ol><li>排序阶段仅使用交易 ID，并行处理多个交易，提高共识效率</li><li>使用内存中的哈希表代替 LevelDB&#x2F;CouchDB 来储存世界状态，提高访问速度</li><li>分离背书和验证的角色</li><li>缓存解析的区块数据</li><li>并行验证块和块中交易的有效性</li></ol><p><strong>结果</strong>：</p><ul><li>Opt O-I: 只使用交易 ID </li><li>Opt O-II: 并行处理传入交易</li></ul><p><img src="/Project5-Thinking/4.png" alt="Orderer"></p><ul><li>Opt P-I: 使用内存哈希表</li><li>Opt P-II: 验证与提交分离</li><li>Opt P-III: 缓存解析数据</li></ul><p><img src="/Project5-Thinking/5.png" alt="Peer"></p><h2 id="3-提高成功率"><a href="#3-提高成功率" class="headerlink" title="3 提高成功率"></a>3 提高成功率</h2><h3 id="3-1-Fabric-4"><a href="#3-1-Fabric-4" class="headerlink" title="3.1 Fabric++ [4]"></a>3.1 Fabric++ [4]</h3><p><strong>优化</strong>：</p><ol><li>事务重新排序机制（transaction reordering mechanism）</li><li>早期中止（early abort）</li></ol><p><strong>重排算法</strong>：</p><p><img src="/Project5-Thinking/6.png" alt="Reordering"></p><ol><li>建立所有交易的冲突图</li><li>识别冲突图中的所有环</li><li>识别每一笔交易出现在哪个环中</li><li>依次中止出现在最多环中的交易，直到图无环</li><li>使用剩余的交易建立一个可串行化调度</li></ol><p><strong>早期中止</strong>：</p><p><img src="/Project5-Thinking/7.png" alt="Early Abort"></p><p><strong>结果</strong>：</p><p><img src="/Project5-Thinking/8.png" alt="Result"></p><h3 id="3-2-FabricSharp-5"><a href="#3-2-FabricSharp-5" class="headerlink" title="3.2 FabricSharp [5]"></a>3.2 FabricSharp [5]</h3><p><strong>优化</strong>：</p><ol><li>Fabric++ 过度中止了跨块读取的交易</li><li>Fabric++ 没有考虑跨块并行交易之间的依赖，重排效果受限</li><li>更好的早期中止和交易重排算法</li></ol><p><img src="/Project5-Thinking/9.png"></p><p>六种基本依赖：</p><p><img src="/Project5-Thinking/10.png"></p><ul><li><p>Fabric&#x2F;Fabric++ 不允许在两个交易之间的 anti-rw，因为后一个交易将读取前一个更新的旧版本，因此必须中止。</p></li><li><p>如果两个交易 Txn1 和 Txn2 表现出 c-rw 或 anti-rw 依赖性，则改变顺序不会影响它们的依赖顺序。</p></li><li><p>如果两个交易 Txn1 和 Txn2 表现出 c-ww 依赖性，交换它们的顺序将翻转它们的依赖顺序。</p></li></ul><p><img src="/Project5-Thinking/11.png"></p><ul><li>由上可知：如果环没有 c-ww 依赖关系，则无法重新排序为可序列化。</li></ul><p><img src="/Project5-Thinking/12.png"></p><ul><li>所以对于一个新交易，所有待排序交易（包括新交易）中除了 c-ww 的所有依赖项中如果存在依赖环，直接中止新交易。</li></ul><p><strong>Overview</strong></p><p><img src="/Project5-Thinking/13.png"><br><img src="/Project5-Thinking/14.png"><br><img src="/Project5-Thinking/15.png"><br><img src="/Project5-Thinking/16.png"></p><h2 id="4-改进思路"><a href="#4-改进思路" class="headerlink" title="4 改进思路"></a>4 改进思路</h2><h3 id="4-1-交易合并"><a href="#4-1-交易合并" class="headerlink" title="4.1 交易合并"></a>4.1 交易合并</h3><p>在模拟执行阶段对交易类型进行判断，如果符合简单转账交易的类型，则添加一个可合并的标志，后续在排序节点中对该类交易进行合并，以减少验证阶段 MVCC 冲突。</p><h3 id="4-2-交易重排"><a href="#4-2-交易重排" class="headerlink" title="4.2 交易重排"></a>4.2 交易重排</h3><p>在 Fabric 2.4.0 排序节点中生成交易依赖图，复现并改进交易重排序的算法，降低交易的读写冲突率。</p><h3 id="4-3-并行验证"><a href="#4-3-并行验证" class="headerlink" title="4.3 并行验证"></a>4.3 并行验证</h3><p>根据排序阶段生成的交易依赖图，在验证阶段对相互独立的交易链进行并行验证，提高系统的吞吐量。</p><h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5 参考文献"></a>5 参考文献</h2><p>[1] Androulaki E , Barger A , Bortnikov V , et al. Hyperledger fabric: a distributed operating system for permissioned blockchains[C]&#x2F;&#x2F; European Conference on Computer Systems.ACM, 2018.</p><p>[2] Nathan S , Thakkar P , Vishwanathan B . Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform: IEEE, 10.1109&#x2F;MASCOTS.2018.00034[P]. 2018.</p><p>[3] Gorenflo C ,  Lee S ,  Golab L , et al. FastFabric: Scaling Hyperledger Fabric to 20,000 Transactions per Second[J]. IEEE, 2019.</p><p>[4] Sharma A ,  Schuhknecht F M ,  Agrawal D , et al. Blurring the Lines between Blockchains and Database Systems: the Case of Hyperledger Fabric[C]&#x2F;&#x2F; ACM SIGMOD 2019. ACM, 2019.</p><p>[5] Ruan P ,  Loghin D ,  Ta Q T , et al. A Transactional Perspective on Execute-order-validate Blockchains[J].  2020.</p>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 4. Fabric 源码解析</title>
    <link href="/Project4-Code/"/>
    <url>/Project4-Code/</url>
    
    <content type="html"><![CDATA[<p>学习一下 Fabric 2.4.0 的源代码，本文只关注较为<strong>核心</strong>的部分。</p><span id="more"></span><h2 id="交互流程"><a href="#交互流程" class="headerlink" title="交互流程"></a>交互流程</h2><p><img src="/Project4-Code/1.png" alt="流程"></p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul><li><p>build：编译相关</p></li><li><p>ci：持续集成（CI）相关配置和脚本 </p></li><li><p>cmd：命令行操作相关入口代码</p></li><li><p><strong>common</strong>：一些公共库（错误处理、日志处理、账本存储、策略以及各种工具等等）</p></li><li><p><strong>core</strong>：核心库，组件的核心逻辑，针对每一个组件都有一个子目录（chaincode：与智能合约相关，comm：与网络通信相关，endorser：与背书节点相关）</p></li><li><p><strong>discovery</strong>：服务发现模块相关代码</p></li><li><p>docs：文档相关</p></li><li><p><strong>gossip</strong>：组织内部节点数据同步的通信协议，最终一致性算法，用于组织内部数据同步</p></li><li><p><strong>images</strong>：Docker 镜像打包，Docker 镜像都是通过这个目录下的配置文件生成的</p></li><li><p>integration：待迁移代码</p></li><li><p><strong>internal</strong>：内部代码，被 cmd 包等调用</p></li><li><p><strong>msp</strong>：成员服务管理，Fabric 网络中会为每一个成员提供相应的证书，msp 模块就是读取这些证书并做一些相应的处理</p></li><li><p><strong>orderer</strong>：排序节点的入口，用于消息的订阅与分发处理</p></li><li><p><strong>pkg</strong>：重写或实现了一些 golang 原生接口</p></li><li><p><strong>protoutil</strong>：Proposal 提案相关的工具包</p></li><li><p>release_notes：发布笔记</p></li><li><p><strong>sampleconfig</strong>：配置示例</p></li><li><p><strong>scripts</strong>：脚本，包含启动脚本、检查脚本等</p></li><li><p>swagger：swagger 文档生成配置</p></li><li><p><strong>tools</strong>：工具包，目前还是空的（release-2.4 分支）</p></li><li><p>vagrant：包含了用 Vagrant 建立一个简单的开发环境所必需的脚本</p></li><li><p>vender：存放 Go 中使用的第三方包</p></li></ul><h2 id="1-背书"><a href="#1-背书" class="headerlink" title="1 背书"></a>1 背书</h2><h3 id="1-1-ProcessProposal-函数"><a href="#1-1-ProcessProposal-函数" class="headerlink" title="1.1 ProcessProposal 函数"></a>1.1 ProcessProposal 函数</h3><p><code>core/endorser/endorser.go</code></p><p>Client 与 Peer 交互的入口，用于处理提案并生成提案响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Endorser)</span></span> ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 对提案进行拆包</span><br>up, err := UnpackProposal(signedProp)<br><br><span class="hljs-comment">// 进行预处理，检查提案的头部、唯一性和访问控制列表（ACL）</span><br>err = e.preProcess(up, channel)<br><br><span class="hljs-comment">// 处理提案并生成提案响应</span><br>pResp, err := e.ProcessProposalSuccessfullyOrError(up)<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Endorser)</span></span> ProcessProposalSuccessfullyOrError(up *UnpackedProposal) (*pb.ProposalResponse, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 模拟执行</span><br>res, simulationResult, ccevent, ccInterest, err := e.simulateProposal(txParams, up.ChaincodeName, up.Input)<br><br><span class="hljs-comment">// 获取链码的背书策略插件</span><br>escc := cdLedger.EndorsementPlugin<br><br><span class="hljs-comment">// 使用背书策略插件进行背书</span><br>endorsement, mPrpBytes, err := e.Support.EndorseWithPlugin(escc, up.ChannelID(), prpBytes, up.SignedProposal)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-1-simulateProposal-函数"><a href="#1-1-1-simulateProposal-函数" class="headerlink" title="1.1.1 simulateProposal 函数"></a>1.1.1 simulateProposal 函数</h4><p>执行提案，调用链码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Endorser)</span></span> simulateProposal(txParams *ccprovider.TransactionParams, chaincodeName <span class="hljs-type">string</span>, chaincodeInput *pb.ChaincodeInput) (*pb.Response, []<span class="hljs-type">byte</span>, *pb.ChaincodeEvent, *pb.ChaincodeInterest, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 执行提案，并获得结果</span><br>res, ccevent, err := e.callChaincode(txParams, chaincodeInput, chaincodeName)<br><br><span class="hljs-comment">// 调用接口获取事务模拟的结果（读写集）</span><br>simResult, err := txParams.TXSimulator.GetTxSimulationResults()<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Endorser)</span></span> callChaincode(txParams *ccprovider.TransactionParams, input *pb.ChaincodeInput, chaincodeName <span class="hljs-type">string</span>) (*pb.Response, *pb.ChaincodeEvent, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 调用链码执行的接口</span><br>res, ccevent, err := e.Support.Execute(txParams, chaincodeName, input)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-2-EndorseWithPlugin-函数"><a href="#1-1-2-EndorseWithPlugin-函数" class="headerlink" title="1.1.2 EndorseWithPlugin 函数"></a>1.1.2 EndorseWithPlugin 函数</h4><p><code>core/endorser/plugin_endorser.go</code></p><p>给执行结果背书。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// EndorseWithPlugin endorses the response with a plugin</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pe *PluginEndorser)</span></span> EndorseWithPlugin(pluginName, channelID <span class="hljs-type">string</span>, prpBytes []<span class="hljs-type">byte</span>, signedProposal *pb.SignedProposal) (*pb.Endorsement, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>plugin, err := pe.getOrCreatePlugin(PluginName(pluginName), channelID)<br><br><span class="hljs-keyword">return</span> plugin.Endorse(prpBytes, signedProposal)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2 排序"></a>2 排序</h2><p>Orderer 在 Fabric 网络中的作用主要是原子广播（Atomic Broadcast）和全排序（Total Order）：</p><ul><li>通过 <code>broadcast</code> 接口，接受 client 发送的交易，然后将这些 Tx 进行排序；排序的的原则为 FIFS，但是区块内交易的顺序不一定与实际顺序一样，而是由到达 Orderer 的时间来决定的。</li><li>排序后的交易根据一定的规则打包成区块，通过 <code>deliver</code> 接口将区块发送给 Peer 或 client；保证所有 Orderer 节点分发出来的 block 是一致的。</li></ul><p>配置：</p><ul><li>常量配置：<code>internal/peer/common/ordererenv.go</code></li><li>变量配置：通过 configtx.yaml 保存在区块中，可以通过 Config 交易进行修改</li></ul><h3 id="2-1-Broadcast-函数"><a href="#2-1-Broadcast-函数" class="headerlink" title="2.1 Broadcast 函数"></a>2.1 Broadcast 函数</h3><p><code>orderer/common/server/server.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Broadcast receives a stream of messages from a client for ordering</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> Broadcast(srv ab.AtomicBroadcast_BroadcastServer) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">return</span> s.bh.Handle(&amp;broadcastMsgTracer&#123;<br>AtomicBroadcast_BroadcastServer: srv,<br>msgTracer: msgTracer&#123;<br>debug:    s.debug,<br>function: <span class="hljs-string">&quot;Broadcast&quot;</span>,<br>&#125;,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Handle-函数"><a href="#2-2-Handle-函数" class="headerlink" title="2.2 Handle 函数"></a>2.2 Handle 函数</h3><p><code>orderer/common/broadcast/broadcast.go</code></p><p>Handle 函数负责原子广播服务端的处理，Handle 从 Broadcast 流里面读取请求，然后调用 ProcessMessage 函数进行处理，最后还会将处理结果返回给数据流。</p><p>客户端调用 Broadcast 发起服务请求时，会调用 s.bh.Handle 方法处理请求，调用 Handle 方法，通过服务器端 srv 调用 srv.Recv()，监听并接收 Send 接口发送的交易消息请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Handle reads requests from a Broadcast stream, processes them, and returns the responses to the stream</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bh *Handler)</span></span> Handle(srv ab.AtomicBroadcast_BroadcastServer) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 从流中接收一个消息，如果接收到的消息是 io.EOF，表示流已结束</span><br>msg, err := srv.Recv()<br><br><span class="hljs-comment">// 处理收到的消息</span><br>resp := bh.ProcessMessage(msg, addr)<br><br><span class="hljs-comment">// 将响应发送回流中</span><br>err = srv.Send(resp)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-ProcessMessage-函数"><a href="#2-3-ProcessMessage-函数" class="headerlink" title="2.3 ProcessMessage 函数"></a>2.3 ProcessMessage 函数</h3><p>排序节点接收的交易类型分为 Normal 交易和 Config 交易：</p><ul><li>Normal 交易的内容包含 ProposalResponse 以及其他内容</li><li>Config 交易主要是 channel 的创建或配置修改</li></ul><p>因为需要让后面的 Normal 交易尽快在最新配置的 channel 上运行，Config 交易都是单独成块的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bh *Handler)</span></span> ProcessMessage(msg *cb.Envelope, addr <span class="hljs-type">string</span>) (resp *ab.BroadcastResponse) &#123;<br><br><span class="hljs-comment">// 解析出消息的通道头部 chdr，配置交易消息标志位 isConfig、链支持对象 processor</span><br>chdr, isConfig, processor, err := bh.SupportRegistrar.BroadcastChannelSupport(msg)<br><br><span class="hljs-keyword">if</span> !isConfig &#123;<br><br><span class="hljs-comment">// 处理普通交易消息</span><br>configSeq, err := processor.ProcessNormalMsg(msg)<br><br><span class="hljs-comment">// 检查当前通道共识组件链是否已经准备好接收新消息</span><br>err = processor.WaitReady()<br><br><span class="hljs-comment">// 重新配置普通交易消息，交给共识请求排序出块</span><br>err = processor.Order(msg, configSeq)<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 处理配置交易消息</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-1-ProcessNormalMsg-函数"><a href="#2-3-1-ProcessNormalMsg-函数" class="headerlink" title="2.3.1 ProcessNormalMsg 函数"></a>2.3.1 ProcessNormalMsg 函数</h4><p><code>orderer/common/msgprocessor/standardchannel.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StandardChannel)</span></span> ProcessNormalMsg(env *cb.Envelope) (configSeq <span class="hljs-type">uint64</span>, err <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 获取通道配置序号</span><br>configSeq = s.support.Sequence()<br><br><span class="hljs-comment">// 利用自带的通道信息过滤器过滤该消息，检查是否满足应用通道上的消息处理请求</span><br>err = s.filters.Apply(env)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-Order-函数"><a href="#2-3-2-Order-函数" class="headerlink" title="2.3.2 Order 函数"></a>2.3.2 Order 函数</h4><p><code>orderer/consensus/etcdraft/chain.go</code></p><p>提交 Normal 交易。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Order submits normal type transactions for ordering.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Chain)</span></span> Order(env *common.Envelope, configSeq <span class="hljs-type">uint64</span>) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">return</span> c.Submit(&amp;orderer.SubmitRequest&#123;LastValidationSeq: configSeq, Payload: env, Channel: c.channelID&#125;, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-Submit-函数"><a href="#2-3-3-Submit-函数" class="headerlink" title="2.3.3 Submit 函数"></a>2.3.3 Submit 函数</h4><p>Submit 首先将请求消息封装为 submit 结构，通过通道 c.submitC 传递给后端处理，同时获取当前时刻 raft 集群的 leader 信息。</p><p>若当前节点是 leader 则将待提交的请求发送到本地 goroutine 处理；如果不是 leader，需要将请求发送给 leader 节点进行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Chain)</span></span> Submit(req *orderer.SubmitRequest, sender <span class="hljs-type">uint64</span>) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// 将 req 和 leadC 封装为一个 submit 结构体，并将其发送到 c.submitC 通道中。</span><br><span class="hljs-keyword">case</span> c.submitC &lt;- &amp;submit&#123;req, leadC&#125;:<br><br><span class="hljs-comment">// 从 leadC 通道中接收 leader 节点的标识</span><br>lead := &lt;-leadC<br><br><span class="hljs-comment">// 若当前集群中还没有选出一个 leader，共识功能暂时不可用</span><br><span class="hljs-keyword">if</span> lead == raft.None &#123;...&#125;<br><br><span class="hljs-comment">// 若当前节点不是 leader，将消息转发给 leader</span><br><span class="hljs-keyword">if</span> lead != c.raftID &#123;<br><span class="hljs-keyword">if</span> err := c.forwardToLeader(lead, req); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-run-函数"><a href="#2-4-run-函数" class="headerlink" title="2.4 run 函数"></a>2.4 run 函数</h3><p><code>orderer/consensus/etcdraft/chain.go</code></p><p>Order 节点启动的时候会执行 <code>go c.run()</code>，该方法是一个无限循环，负责处理提交请求、处理应用层消息和定时任务等操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Chain)</span></span> run() &#123;<br><br><span class="hljs-comment">// 进入主循环，在循环中通过 select 语句监听多个通道的事件</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><br><span class="hljs-comment">// submitC 通道：接收提交请求，根据当前节点的角色进行处理：</span><br><span class="hljs-comment">// 如果节点是 leader，将请求进行排序和处理；如果节点不是 leader，将请求转发给 leader 节点处理。</span><br><span class="hljs-keyword">case</span> s := &lt;-submitC:<br><br>s.leader &lt;- soft.Lead<br><span class="hljs-comment">// 如果当前节点的领导者不是自身节点，则继续下一次循环。</span><br><span class="hljs-keyword">if</span> soft.Lead != c.raftID &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 如果当前节点是领导者，对提交请求进行排序和处理</span><br>batches, pending, err := c.ordered(s.req)<br><br><span class="hljs-comment">// 提交排序后的请求并出块</span><br>c.propose(propC, bc, batches...)<br><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-1-ordered-函数"><a href="#2-4-1-ordered-函数" class="headerlink" title="2.4.1 ordered 函数"></a>2.4.1 ordered 函数</h4><p>如果是 leader 节点，那么将会执行 ordered 函数：</p><ul><li>如果是 Config 消息，调用 BlockCutter.Cut() 直接切割区块</li><li>如果是 Normal 消息，调用 BlockCutter.Ordered() 进入缓存排序，根据当前交易量决定增加交易或切割</li></ul><p>ordered 处理之后，会得到由 BlockCutter 返回的数据包 bathches 和缓存是否还有数据的信息。如果缓存还有余留数据未出块，则启动计时器，否则重置计时器 timer.C。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Orders the envelope in the `msg` content. SubmitRequest.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Chain)</span></span> ordered(msg *orderer.SubmitRequest) (batches [][]*common.Envelope, pending <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-keyword">if</span> isconfig &#123;<br><span class="hljs-comment">// ConfigMsg</span><br>&#125;<br><br><span class="hljs-comment">// it is a normal message</span><br><span class="hljs-comment">// 对交易进行排序 orderer/common/blockcutter/blockcutter.go</span><br>batches, pending = c.support.BlockCutter().Ordered(msg.Payload)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-propose-函数"><a href="#2-4-2-propose-函数" class="headerlink" title="2.4.2 propose 函数"></a>2.4.2 propose 函数</h4><p>propose 会根据上一步的 batches 数据包调用 createNextBlock 打包出 block，并将 block 传递给 c.ch 通道。</p><p>becomeLeader 时会启动一个线程处理该消息，只有 leader 具有 propose 的权限。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Chain)</span></span> propose(ch <span class="hljs-keyword">chan</span>&lt;- *common.Block, bc *blockCreator, batches ...[]*common.Envelope) &#123;<br><br><span class="hljs-keyword">for</span> _, batch := <span class="hljs-keyword">range</span> batches &#123;<br><br><span class="hljs-comment">// 创建下一个区块</span><br>b := bc.createNextBlock(batch)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// 将创建的区块发送到通道中</span><br><span class="hljs-keyword">case</span> ch &lt;- b:<br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用 c.Node.Propose 将数据传递给底层 raft 状态机。</p><p><strong>从这一段的逻辑可以看出，所有客户端发送给 Orderer 的请求，都会被发送给 raft 的 leader 节点，由 leader 节点排序并生成区块，生成好的区块发送给底层 raft 状态机进行应用同步。</strong></p><h2 id="3-验证"><a href="#3-验证" class="headerlink" title="3 验证"></a>3 验证</h2><h3 id="3-1-StoreBlock-函数"><a href="#3-1-StoreBlock-函数" class="headerlink" title="3.1 StoreBlock 函数"></a>3.1 StoreBlock 函数</h3><p><code>gossip/privdata/coordinator.go</code></p><p>coordinator 是 Fabric 中的一个关键组件，负责协调和处理与区块链交互相关的操作，它是 ledger 的主要控制器：</p><ol><li><p><strong>接收和验证区块</strong>：当一个新的区块到达节点时，coordinator 负责验证区块的有效性，包括验证区块的签名、交易的正确性以及相关的权限和策略。</p></li><li><p><strong>处理私有数据</strong>：在存储区块时，coordinator 会处理区块中的私有数据，包括从分类账中检索私有数据、处理缺失的私有数据以及将私有数据与区块关联起来。</p></li><li><p><strong>提交区块</strong>：一旦区块和私有数据都成功存储，coordinator 将提交区块到分类账中，使其成为区块链的一部分。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// StoreBlock stores block with private data into the ledger</span><br><span class="hljs-comment">// 该函数在 gossip/state/state.go 调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *coordinator)</span></span> StoreBlock(block *common.Block, privateDataSets util.PvtDataCollections) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-comment">// 校验区块信息和交易签名 VSCC</span><br>err := c.Validator.Validate(block)<br><br><span class="hljs-comment">// 提交区块，在此过程中执行 MVCC 验证</span><br>err = c.CommitLegacy(blockAndPvtData, &amp;ledger.CommitOptions&#123;&#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Validate-函数"><a href="#3-2-Validate-函数" class="headerlink" title="3.2 Validate 函数"></a>3.2 Validate 函数</h3><p><code>core/committer/txvalidator/v20/validator.go</code></p><p>Validate 执行区块的 VSCC 验证。每个交易的验证并行进行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *TxValidator)</span></span> Validate(block *common.Block) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> tIdx, d := <span class="hljs-keyword">range</span> block.Data.Data &#123;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(index <span class="hljs-type">int</span>, data []<span class="hljs-type">byte</span>)</span></span> &#123;<br><br><span class="hljs-comment">// 将每个交易封装成结构体并调用 validateTx，将验证结果发送到 results 通道中</span><br>v.validateTx(&amp;blockValidationRequest&#123;<br>d:     data,<br>block: block,<br>tIdx:  index,<br>&#125;, results)<br>&#125;(tIdx, d)<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 主线程从 results 通道中接收验证结果，并根据结果进行处理</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(block.Data.Data); i++ &#123;<br>res := &lt;-results<br><br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果某个交易验证失败，则会记录第一个失败交易的错误</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果结果中没有错误，则将验证结果设置到 txsfltr 中，并将交易 ID 存储到 txidArray 中</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-CommitLegacy-函数"><a href="#3-3-CommitLegacy-函数" class="headerlink" title="3.3 CommitLegacy 函数"></a>3.3 CommitLegacy 函数</h3><p><code>core/ledger/kvledger/kv_ledger.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *kvLedger)</span></span> CommitLegacy(pvtdataAndBlock *ledger.BlockAndPvtData, commitOpts *ledger.CommitOptions) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">if</span> err := l.commit(pvtdataAndBlock, commitOpts); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// commit commits the block and the corresponding pvt data in an atomic operation.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *kvLedger)</span></span> commit(pvtdataAndBlock *ledger.BlockAndPvtData, commitOpts *ledger.CommitOptions) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-comment">// 读写集的 MVCC 检查</span><br>txstatsInfo, updateBatchBytes, err := l.txmgr.ValidateAndPrepare(pvtdataAndBlock, <span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 添加区块到文件系统</span><br><span class="hljs-keyword">if</span> err = l.commitToPvtAndBlockStore(pvtdataAndBlock); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><br><span class="hljs-comment">// 提交有效数据到状态数据库</span><br><span class="hljs-keyword">if</span> err = l.txmgr.Commit(); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-ValidateAndPrepare-函数"><a href="#3-3-1-ValidateAndPrepare-函数" class="headerlink" title="3.3.1 ValidateAndPrepare 函数"></a>3.3.1 ValidateAndPrepare 函数</h4><p><code>core/ledger/kvledger/txmgmt/txmgr/lockbased_txmgr.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(txmgr *LockBasedTxMgr)</span></span> ValidateAndPrepare(blockAndPvtdata *ledger.BlockAndPvtData, doMVCCValidation <span class="hljs-type">bool</span>) (<br>[]*validation.TxStatInfo, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>,) &#123;<br><br>batch, txstatsInfo, err := txmgr.commitBatchPreparer.ValidateAndPrepareBatch(blockAndPvtdata, doMVCCValidation)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>core/ledger/kvledger/txmgmt/validation/batch_preparer.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ValidateAndPrepareBatch performs validation of transactions in the block and prepares the batch of final writes</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *CommitBatchPreparer)</span></span> ValidateAndPrepareBatch(blockAndPvtdata *ledger.BlockAndPvtData,<br>doMVCCValidation <span class="hljs-type">bool</span>) (*privacyenabledstate.UpdateBatch, []*TxStatInfo, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 预处理，过滤无效交易</span><br><span class="hljs-keyword">if</span> internalBlock, txsStatInfo, err = preprocessProtoBlock(...) &#123;...&#125;<br><br><span class="hljs-comment">// 读写集检验</span><br><span class="hljs-keyword">if</span> pubAndHashUpdates, err = p.validator.validateAndPrepareBatch(internalBlock, doMVCCValidation); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>core/ledger/kvledger/txmgmt/validation/validator.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// validateAndPrepareBatch performs validation and prepares the batch for final writes</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *validator)</span></span> validateAndPrepareBatch(blk *block, doMVCCValidation <span class="hljs-type">bool</span>) (*publicAndHashUpdates, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 遍历每一笔交易，进行 MVCC 验证，若交易有效，将交易中的写集放入 updates。</span><br><span class="hljs-keyword">for</span> _, tx := <span class="hljs-keyword">range</span> blk.txs &#123;<br><br><span class="hljs-keyword">if</span> validationCode, err = v.validateEndorserTX(tx.rwset, doMVCCValidation, updates); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><br><span class="hljs-keyword">if</span> validationCode == peer.TxValidationCode_VALID &#123;<br><span class="hljs-keyword">if</span> err := updates.applyWriteSet(tx.rwset, committingTxHeight, v.db, tx.containsPostOrderWrites); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-validateEndorserTX-函数"><a href="#3-3-2-validateEndorserTX-函数" class="headerlink" title="3.3.2 validateEndorserTX 函数"></a>3.3.2 validateEndorserTX 函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// validateEndorserTX validates endorser transaction</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *validator)</span></span> validateEndorserTX(...) (peer.TxValidationCode, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// MVCC 验证，不通过则使交易失效</span><br><span class="hljs-keyword">if</span> doMVCCValidation &#123;<br>validationCode, err = v.validateTx(txRWSet, updates)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *validator)</span></span> validateTx(txRWSet *rwsetutil.TxRwSet, updates *publicAndHashUpdates) (peer.TxValidationCode, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-keyword">for</span> _, nsRWSet := <span class="hljs-keyword">range</span> txRWSet.NsRwSets &#123;<br>ns := nsRWSet.NameSpace<br><span class="hljs-comment">// Validate public reads</span><br><span class="hljs-keyword">if</span> valid, err := v.validateReadSet(ns, nsRWSet.KvRwSet.Reads, updates.publicUpdates); !valid || err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><span class="hljs-comment">// Validate range queries for phantom items</span><br><span class="hljs-keyword">if</span> valid, err := v.validateRangeQueries(ns, nsRWSet.KvRwSet.RangeQueriesInfo, updates.publicUpdates); !valid || err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><span class="hljs-comment">// Validate hashes for private reads</span><br><span class="hljs-keyword">if</span> valid, err := v.validateNsHashedReadSets(ns, nsRWSet.CollHashedRwSets, updates.hashUpdates); !valid || err != <span class="hljs-literal">nil</span> &#123;...&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *validator)</span></span> validateReadSet(ns <span class="hljs-type">string</span>, kvReads []*kvrwset.KVRead, updates *privacyenabledstate.PubUpdateBatch) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-keyword">for</span> _, kvRead := <span class="hljs-keyword">range</span> kvReads &#123;<br><span class="hljs-keyword">if</span> valid, err := v.validateKVRead(ns, kvRead, updates); !valid || err != <span class="hljs-literal">nil</span> &#123;...&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *validator)</span></span> validateKVRead(ns <span class="hljs-type">string</span>, kvRead *kvrwset.KVRead, updates *privacyenabledstate.PubUpdateBatch) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-comment">// 比较版本是否匹配</span><br><span class="hljs-keyword">if</span> !version.AreSame(committedVersion, readVersion) &#123;...&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-提交"><a href="#4-提交" class="headerlink" title="4 提交"></a>4 提交</h2><h3 id="4-1-commitToPvtAndBlockStore-函数"><a href="#4-1-commitToPvtAndBlockStore-函数" class="headerlink" title="4.1 commitToPvtAndBlockStore 函数"></a>4.1 commitToPvtAndBlockStore 函数</h3><p><code>core/ledger/kvledger/kv_ledger.go</code></p><p>将区块写入文件系统。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *kvLedger)</span></span> commitToPvtAndBlockStore(blockAndPvtdata *ledger.BlockAndPvtData) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">if</span> err := l.blockStore.AddBlock(blockAndPvtdata.Block); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>common/ledger/blkstorage/blockstore.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(store *BlockStore)</span></span> AddBlock(block *common.Block) <span class="hljs-type">error</span> &#123;<br><br>result := store.fileMgr.addBlock(block)<br><br><span class="hljs-comment">// 更新区块高度和提交时间</span><br>store.updateBlockStats(block.Header.Number, elapsedBlockCommit)<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *blockfileMgr)</span></span> addBlock(block *common.Block) <span class="hljs-type">error</span> &#123;<br><br>blockBytes, info, err := serializeBlock(block)<br><br><span class="hljs-comment">// append blockBytesEncodedLen to the file</span><br>err = mgr.currentFileWriter.<span class="hljs-built_in">append</span>(blockBytesEncodedLen, <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// append the actual block bytes to the file</span><br>err = mgr.currentFileWriter.<span class="hljs-built_in">append</span>(blockBytes, <span class="hljs-literal">true</span>)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Commit-函数"><a href="#4-2-Commit-函数" class="headerlink" title="4.2 Commit 函数"></a>4.2 Commit 函数</h3><p><code>core/ledger/kvledger/txmgmt/txmgr/lockbased_txmgr.go</code></p><p>提交有效更改到状态数据库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(txmgr *LockBasedTxMgr)</span></span> Commit() <span class="hljs-type">error</span> &#123;<br><br>txmgr.commitRWLock.Lock()<br><span class="hljs-keyword">if</span> err := txmgr.db.ApplyPrivacyAwareUpdates(txmgr.current.batch, commitHeight); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br>txmgr.commitRWLock.Unlock()<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>core/ledger/kvledger/txmgmt/privacyenabledstate/db.go</code></p><p>用于将更新批次应用到底层的数据库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *DB)</span></span> ApplyPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-comment">// 这两个函数用于将私有数据更新和哈希更新添加到公共数据更新批次中</span><br>addPvtUpdates(combinedUpdates, updates.PvtUpdates)<br>addHashedUpdates(combinedUpdates, updates.HashUpdates, !s.BytesKeySupported())<br><span class="hljs-keyword">if</span> err := s.metadataHint.setMetadataUsedFlag(updates); err != <span class="hljs-literal">nil</span> &#123;...&#125;<br><br><span class="hljs-keyword">return</span> s.VersionedDB.ApplyUpdates(combinedUpdates.UpdateBatch, height)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-ApplyUpdates-函数"><a href="#4-3-ApplyUpdates-函数" class="headerlink" title="4.3 ApplyUpdates 函数"></a>4.3 ApplyUpdates 函数</h3><p><code>core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb.go</code></p><p>在 leveldb 中的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(vdb *versionedDB)</span></span> ApplyUpdates(batch *statedb.UpdateBatch, height *version.Height) <span class="hljs-type">error</span> &#123;<br><br><span class="hljs-keyword">for</span> _, ns := <span class="hljs-keyword">range</span> namespaces &#123;<br>updates := batch.GetUpdates(ns)<br><span class="hljs-keyword">for</span> k, vv := <span class="hljs-keyword">range</span> updates &#123;<br>dataKey := encodeDataKey(ns, k)<br><br><span class="hljs-keyword">if</span> vv.Value == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果值为 nil，表示需要删除该键，函数将在数据库更新批次中添加一个删除操作</span><br>dbBatch.Delete(dataKey)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果值不为 nil，将值编码为字节序列，并将键值对添加到数据库更新批次中</span><br>encodedVal, err := encodeValue(vv)<br>dbBatch.Put(dataKey, encodedVal)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 将数据库更新批次写入到版本化数据库中，true 表示要求同步写入。</span><br><span class="hljs-keyword">return</span> vdb.db.WriteBatch(dbBatch, <span class="hljs-literal">true</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 3. 部署自定义网络</title>
    <link href="/Project3-Deploy/"/>
    <url>/Project3-Deploy/</url>
    
    <content type="html"><![CDATA[<p>手动来部署一个自定义的 Fabric 测试网络。</p><span id="more"></span><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><p>准备好编译&#x2F;下载的二进制文件和镜像，二进制命令复制到 <code>/usr/local/bin</code> 中，以供全局调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Lunux">$ cp * /usr/local/bin<br></code></pre></td></tr></table></figure><p>也可以将二进制文件加入子进程的临时 PATH 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Lunux">$ export PATH=$PWD/bin:/bin:/usr/bin<br></code></pre></td></tr></table></figure><p>创建一个目录，用于存放各配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Lunux">$ mkdir twoPeerNet<br>$ cd twoPeerNet<br></code></pre></td></tr></table></figure><h2 id="2-生成配置文件"><a href="#2-生成配置文件" class="headerlink" title="2 生成配置文件"></a>2 生成配置文件</h2><p>注意在运行配置文件时报错大概率是因为有 Tab 或者缩进不正确。</p><h3 id="组织配置文件-crypto-config-yaml"><a href="#组织配置文件-crypto-config-yaml" class="headerlink" title="组织配置文件 crypto-config.yaml"></a>组织配置文件 crypto-config.yaml</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cryptogen showtemplate &gt; crypto-config.yaml</span><br></code></pre></td></tr></table></figure><p>文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs crypto-config.yaml">OrdererOrgs:<br>  - Name: Orderer                             # orderer 组织的名称<br>    Domain: example.com                       # orderer 组织的根域名<br>    EnableNodeOUs: true                       # 是否使用组织单元<br>    Specs:<br>      - Hostname: orderer                     # 可以通过 hostname 设置多个 orderer 节点<br>                                              # Hostname + Domain 组成该 orderer 节点的完整域名<br><br>PeerOrgs:                                     # 一个 PeerOrgs 设置多个 peer 组织<br>  - Name: Org1                                # peer 组织的名称<br>    Domain: org1.example.com                  # peer 组织的域名<br>    EnableNodeOUs: true<br>    Template:                                 # 节点的数量（peer0, peer1, .....）<br>      Count: 1<br>    Users:                                    # 用户的数量<br>      Count: 1<br><br>  - Name: Org2<br>    Domain: org2.example.com<br>    EnableNodeOUs: true<br>    Template:<br>      Count: 1<br>    Users:<br>      Count: 1<br></code></pre></td></tr></table></figure><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cryptogen generate --config=crypto-config.yaml</span><br></code></pre></td></tr></table></figure><h3 id="网络配置文件-configtx-yaml"><a href="#网络配置文件-configtx-yaml" class="headerlink" title="网络配置文件 configtx.yaml"></a>网络配置文件 configtx.yaml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs configtx.yaml">Organizations:<br>    - &amp;OrdererOrg<br>        Name: OrdererOrg<br>        ID: OrdererMSP<br>        MSPDir: ./crypto-config/ordererOrganizations/example.com/msp<br>        Policies:<br>            Readers:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;OrdererMSP.member&#x27;)&quot;<br>            Writers:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;OrdererMSP.member&#x27;)&quot;<br>            Admins:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;OrdererMSP.admin&#x27;)&quot;<br>        OrdererEndpoints:<br>            - orderer.example.com:7050<br><br>    - &amp;Org1<br>        Name: Org1MSP<br>        ID: Org1MSP<br>        MSPDir: ./crypto-config/peerOrganizations/org1.example.com/msp<br>        Policies:<br>            Readers:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org1MSP.admin&#x27;, &#x27;Org1MSP.peer&#x27;, &#x27;Org1MSP.client&#x27;)&quot;<br>            Writers:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org1MSP.admin&#x27;, &#x27;Org1MSP.client&#x27;)&quot;<br>            Admins:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org1MSP.admin&#x27;)&quot;<br>            Endorsement:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org1MSP.peer&#x27;)&quot;<br><br>        AnchorPeers:<br>            - Host: peer0.org1.example.com<br>              Port: 7051<br><br>    - &amp;Org2<br>        Name: Org2MSP<br>        ID: Org2MSP<br>        MSPDir: ./crypto-config/peerOrganizations/org2.example.com/msp<br>        Policies:<br>            Readers:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org2MSP.admin&#x27;, &#x27;Org2MSP.peer&#x27;, &#x27;Org2MSP.client&#x27;)&quot;<br>            Writers:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org2MSP.admin&#x27;, &#x27;Org2MSP.client&#x27;)&quot;<br>            Admins:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org2MSP.admin&#x27;)&quot;<br>            Endorsement:<br>                Type: Signature<br>                Rule: &quot;OR(&#x27;Org2MSP.peer&#x27;)&quot;<br><br>        AnchorPeers:<br>            - Host: peer0.org2.example.com<br>              Port: 8051<br><br><br>Capabilities:<br>    Channel: &amp;ChannelCapabilities<br>        V2_0: true<br>    Orderer: &amp;OrdererCapabilities<br>        V2_0: true<br>    Application: &amp;ApplicationCapabilities<br>        V2_0: true<br><br>Application: &amp;ApplicationDefaults<br><br>    Organizations:<br><br>    Policies:<br>        Readers:<br>            Type: ImplicitMeta<br>            Rule: &quot;ANY Readers&quot;<br>        Writers:<br>            Type: ImplicitMeta<br>            Rule: &quot;ANY Writers&quot;<br>        Admins:<br>            Type: ImplicitMeta<br>            Rule: &quot;MAJORITY Admins&quot;<br>        LifecycleEndorsement:<br>            Type: ImplicitMeta<br>            Rule: &quot;MAJORITY Endorsement&quot;<br>        Endorsement:<br>            Type: ImplicitMeta<br>            Rule: &quot;MAJORITY Endorsement&quot;<br><br>    Capabilities:<br>        &lt;&lt;: *ApplicationCapabilities<br><br>Orderer: &amp;OrdererDefaults<br><br>    OrdererType: etcdraft<br><br>    Addresses:                            # orderer 集群节点<br>        - orderer.example.com:7050<br><br>    EtcdRaft:<br>        Consenters:<br>        - Host: orderer.example.com<br>          Port: 7050<br>          ClientTLSCert: ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/server.crt<br>          ServerTLSCert: ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/server.crt<br><br>    BatchTimeout: 2s                      # 生成区块超时时间<br><br>    # Batch Size: Controls the number of messages batched into a block<br>    BatchSize:<br><br>        MaxMessageCount: 10               # 区块的消息数量<br><br>        AbsoluteMaxBytes: 99 MB           # 区块最大字节数<br><br>        PreferredMaxBytes: 512 KB         # 建议消息字节数<br><br>    Organizations:<br><br>    Policies:<br>        Readers:<br>            Type: ImplicitMeta<br>            Rule: &quot;ANY Readers&quot;<br>        Writers:<br>            Type: ImplicitMeta<br>            Rule: &quot;ANY Writers&quot;<br>        Admins:<br>            Type: ImplicitMeta<br>            Rule: &quot;MAJORITY Admins&quot;<br>        BlockValidation:<br>            Type: ImplicitMeta<br>            Rule: &quot;ANY Writers&quot;<br><br>Channel: &amp;ChannelDefaults<br><br>    Policies:<br>        # Who may invoke the &#x27;Deliver&#x27; API<br>        Readers:<br>            Type: ImplicitMeta<br>            Rule: &quot;ANY Readers&quot;<br>        # Who may invoke the &#x27;Broadcast&#x27; API<br>        Writers:<br>            Type: ImplicitMeta<br>            Rule: &quot;ANY Writers&quot;<br>        # By default, who may modify elements at this config level<br>        Admins:<br>            Type: ImplicitMeta<br>            Rule: &quot;MAJORITY Admins&quot;<br><br>    Capabilities:<br>        &lt;&lt;: *ChannelCapabilities<br><br>Profiles:<br>    TwoOrgsChannel:<br>        Consortium: SampleConsortium<br>        &lt;&lt;: *ChannelDefaults<br>        Application:<br>            &lt;&lt;: *ApplicationDefaults<br>            Organizations:<br>                - *Org1<br>                - *Org2<br>            Capabilities:<br>                &lt;&lt;: *ApplicationCapabilities<br>    <br>    TwoOrgsOrdererGenesis:<br>        &lt;&lt;: *ChannelDefaults<br>        Capabilities:<br>            &lt;&lt;: *ChannelCapabilities<br>        Orderer:<br>            &lt;&lt;: *OrdererDefaults<br>            Organizations:<br>                - *OrdererOrg<br>            Capabilities:<br>                &lt;&lt;: *OrdererCapabilities<br>        Consortiums:<br>            SampleConsortium:<br>                Organizations:<br>                    - *Org1<br>                    - *Org2<br></code></pre></td></tr></table></figure><h3 id="创世块文件"><a href="#创世块文件" class="headerlink" title="创世块文件"></a>创世块文件</h3><p>channelID 指定的是系统通道名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block -channelID test-channel</span><br></code></pre></td></tr></table></figure><h3 id="通道文件"><a href="#通道文件" class="headerlink" title="通道文件"></a>通道文件</h3><p>channelID 指定的是应用通道名，不能与上一步同名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel</span><br></code></pre></td></tr></table></figure><h3 id="org1-和-org2-的锚节点"><a href="#org1-和-org2-的锚节点" class="headerlink" title="org1 和 org2 的锚节点"></a>org1 和 org2 的锚节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP</span><br></code></pre></td></tr></table></figure><h2 id="3-启动节点"><a href="#3-启动节点" class="headerlink" title="3 启动节点"></a>3 启动节点</h2><h3 id="编写-docker-compose-文件"><a href="#编写-docker-compose-文件" class="headerlink" title="编写 docker-compose 文件"></a>编写 docker-compose 文件</h3><p>cli 容器通过环境变量 CORE_PEER_ADDRESS 来指定所代表的 Peer 节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs docker-compose.yaml">version: &#x27;2&#x27;<br><br>volumes:<br>  orderer.example.com:<br>  peer0.org1.example.com:<br>  peer0.org2.example.com:<br>  <br>networks:<br>  test:<br>    name: fabric_test<br><br>services:<br>  orderer.example.com:<br>    container_name: orderer.example.com<br>    image: hyperledger/fabric-orderer:latest<br>    environment:<br>      - FABRIC_LOGGING_SPEC=INFO<br>      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0#监听的 IP<br>      - ORDERER_GENERAL_LISTENPORT=7050#监听的端口<br>      - ORDERER_GENERAL_GENESISMETHOD=file        #创世块的来源方式<br>      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block  #创世文件的路径<br>      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP#MSPID<br>      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp#容器中 msp 的路径<br>      - ORDERER_OPERATIONS_LISTENADDRESS=0.0.0.0:17050<br>      - ORDERER_GENERAL_TLS_ENABLED=true<br>      - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key<br>      - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt<br>      - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]<br>      - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt<br>      - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key<br>      - ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]<br>    working_dir: /opt/gopath/src/github.com/hyperledger/fabric<br>    command: orderer<br>    volumes:<br>      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block<br>      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp<br>      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls<br>      - orderer.example.com:/var/hyperledger/production/orderer<br>    ports:<br>      - 7050:7050<br>      - 17050:17050<br>    networks:<br>      - test<br>  <br>  peer0.org1.example.com:<br>    container_name: peer0.org1.example.com<br>    image: hyperledger/fabric-peer:latest<br>    environment:<br>      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock<br>      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test<br>      - CORE_PEER_ID=peer0.org1.example.com<br>      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051#服务的 IP 端口<br>      - CORE_PEER_LISTENADDRESS=0.0.0.0:7051#本地监听的 IP 端口<br>      - CORE_PEER_CHAINCODEADDRESS=peer0.org1.example.com:7052#链码的 IP 端口<br>      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052#链码监听的端口<br>      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051#向哪个节点发起 gossip 连接<br>      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051<br>      - CORE_PEER_LOCALMSPID=Org1MSP<br>      - FABRIC_LOGGING_SPEC=INFO<br>      - CORE_PEER_TLS_ENABLED=true<br>      - CORE_PEER_GOSSIP_USELEADERELECTION=true<br>      - CORE_PEER_GOSSIP_ORGLEADER=false<br>      - CORE_PEER_PROFILE_ENABLED=true<br>      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt<br>      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key<br>      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt<br>      - CORE_CHAINCODE_EXECUTETIMEOUT=300s<br>      - CORE_OPERATIONS_LISTENADDRESS=0.0.0.0:17051<br>    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer<br>    command: peer node start<br>    volumes:<br>      - /var/run/:/host/var/run/<br>      - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp<br>      - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls<br>      - peer0.org1.example.com:/var/hyperledger/production<br>    ports:<br>      - 7051:7051<br>      - 7052:7052<br>      - 17051:17051<br>    networks:<br>      - test<br>      <br>  peer0.org2.example.com:<br>    container_name: peer0.org2.example.com<br>    image: hyperledger/fabric-peer:latest<br>    environment:<br>      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock<br>      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test<br>      - CORE_PEER_ID=peer0.org2.example.com<br>      - CORE_PEER_ADDRESS=peer0.org2.example.com:8051<br>      - CORE_PEER_LISTENADDRESS=0.0.0.0:8051<br>      - CORE_PEER_CHAINCODEADDRESS=peer0.org2.example.com:8052<br>      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:8052<br>      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org2.example.com:8051<br>      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:8051<br>      - CORE_PEER_LOCALMSPID=Org2MSP<br>      - FABRIC_LOGGING_SPEC=INFO<br>      - CORE_PEER_TLS_ENABLED=true<br>      - CORE_PEER_GOSSIP_USELEADERELECTION=true<br>      - CORE_PEER_GOSSIP_ORGLEADER=false<br>      - CORE_PEER_PROFILE_ENABLED=true<br>      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt<br>      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key<br>      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt<br>      - CORE_CHAINCODE_EXECUTETIMEOUT=300s<br>      - CORE_OPERATIONS_LISTENADDRESS=0.0.0.0:18051<br>    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer<br>    command: peer node start<br>    volumes:<br>      - /var/run/:/host/var/run/<br>      - ./crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp<br>      - ./crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls<br>      - peer0.org2.example.com:/var/hyperledger/production<br>    ports:<br>      - 8051:8051<br>      - 8052:8052<br>      - 18051:18051<br>    networks:<br>      - test<br>      <br>  <br>cli1:<br>    container_name: cli1<br>    image: hyperledger/fabric-tools:latest<br>    tty: true<br>    stdin_open: true<br>    environment:<br>      - GOPATH=/opt/gopath<br>      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock<br>      - FABRIC_LOGGING_SPEC=INFO<br>      - CORE_PEER_ID=cli1<br>      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051<br>      - CORE_PEER_LOCALMSPID=Org1MSP<br>      - CORE_PEER_TLS_ENABLED=true<br>      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt<br>      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key<br>      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt<br>      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp<br>    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer<br>    command: /bin/bash<br>    volumes:<br>      - /var/run/:/host/var/run/<br>      - ./chaincode/go/:/opt/gopath/src/github.com/hyperledger/multiple-deployment/chaincode/go  #用于映射本地链码的路径<br>      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/<br>      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts<br>    depends_on:<br>      - peer0.org1.example.com<br>      - peer0.org2.example.com<br>      - orderer.example.com<br>    networks:<br>      - test<br>  <br>cli2:<br>    container_name: cli2<br>    image: hyperledger/fabric-tools:latest<br>    tty: true<br>    stdin_open: true<br>    environment:<br>      - GOPATH=/opt/gopath<br>      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock<br>      - FABRIC_LOGGING_SPEC=INFO<br>      - CORE_PEER_ID=cli2<br>      - CORE_PEER_ADDRESS=peer0.org2.example.com:8051<br>      - CORE_PEER_LOCALMSPID=Org2MSP<br>      - CORE_PEER_TLS_ENABLED=true<br>      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt<br>      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.key<br>      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt<br>      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp<br>    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer<br>    command: /bin/bash<br>    volumes:<br>      - /var/run/:/host/var/run/<br>      - ./chaincode/go/:/opt/gopath/src/github.com/hyperledger/multiple-deployment/chaincode/go  #映射本地链码路径<br>      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/<br>      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts<br>    depends_on:<br>      - peer0.org1.example.com<br>      - peer0.org2.example.com<br>      - orderer.example.com<br>    networks:<br>      - test <br></code></pre></td></tr></table></figure><h3 id="编排容器"><a href="#编排容器" class="headerlink" title="编排容器"></a>编排容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>每个 cli 指向一个组织，通过环境变量的设置使 cli 指向特点组织的节点，通过操作 cli 容器就可以操作组织的节点了。</p><h3 id="创建通道"><a href="#创建通道" class="headerlink" title="创建通道"></a>创建通道</h3><p>进入容器 cli1 创建通道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it cli1 bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></code></pre></td></tr></table></figure><p>-o 排序节点<br>-c 通道名<br>-f 通道文件的路径</p><p>当前目录下生成 mychannel.block。在容器外将 mychannel.block 复制给 cli2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/mychannel.block ./</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> ./mychannel.block cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer</span><br></code></pre></td></tr></table></figure><h3 id="加入通道"><a href="#加入通道" class="headerlink" title="加入通道"></a>加入通道</h3><p>开启两个终端，分别进入 cli1 和 cli2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it cli1 bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it cli2 bash</span><br></code></pre></td></tr></table></figure><p>分别加入通道（两个 cli 都需要操作）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer channel <span class="hljs-built_in">join</span> -b mychannel.block</span><br></code></pre></td></tr></table></figure><h3 id="更新锚节点"><a href="#更新锚节点" class="headerlink" title="更新锚节点"></a>更新锚节点</h3><p>在 cli1 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></code></pre></td></tr></table></figure><p>在 cli2 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></code></pre></td></tr></table></figure><h2 id="4-链码测试"><a href="#4-链码测试" class="headerlink" title="4 链码测试"></a>4 链码测试</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>利用 caliper 中的简单转账链码进行链码测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /twoPeerNet/chaincode/go/simple</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> caliper-benchmarks/src/fabric/scenario/simple/go/* twoPeerNet/chaincode/go/simple</span><br></code></pre></td></tr></table></figure><p>在 docker-compose 中，<code>/twoPeerNet/chaincode/go</code> 与容器内的目录实现了容器卷映射，将链码复制到该目录下，容器中也有了相应的链码。</p><p>在 cli1 中设置 goproxy 代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></code></pre></td></tr></table></figure><p>下载依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /opt/gopath/src/github.com/hyperledger/multiple-deployment/chaincode/go/simple</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">go mod vendor</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /opt/gopath/src/github.com/hyperledger/fabric/peer</span><br></code></pre></td></tr></table></figure><h3 id="打包链码"><a href="#打包链码" class="headerlink" title="打包链码"></a>打包链码</h3><p>在 cli1 中打包链码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer lifecycle chaincode package simple.tar.gz --path /opt/gopath/src/github.com/hyperledger/multiple-deployment/chaincode/go/simple --label simple_1.0</span><br></code></pre></td></tr></table></figure><p>在容器外将 cli1 中打包的链码复制到 cli2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/simple.tar.gz ./</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> ./simple.tar.gz cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer</span><br></code></pre></td></tr></table></figure><h3 id="安装链码"><a href="#安装链码" class="headerlink" title="安装链码"></a>安装链码</h3><p>在两个 cli 中分别操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer lifecycle chaincode install simple.tar.gz</span><br></code></pre></td></tr></table></figure><h3 id="审批链码"><a href="#审批链码" class="headerlink" title="审批链码"></a>审批链码</h3><p>查看 package ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer lifecycle chaincode queryinstalled</span><br></code></pre></td></tr></table></figure><p>在两个 cli 中分别操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer lifecycle chaincode approveformyorg --channelID mychannel --name simple --version 1.0 --init-required --package-id simple_1.0:539969bf4773133bf852368737a5ba505443ca4d6b5eae92f5f4463fd8bbd171 --sequence 1 --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></code></pre></td></tr></table></figure><p>检测是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name simple --version 1.0 --init-required --sequence 1 --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com</span><br></code></pre></td></tr></table></figure><h3 id="提交链码"><a href="#提交链码" class="headerlink" title="提交链码"></a>提交链码</h3><p>只需要在 cli1 执行即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer lifecycle chaincode commit -o orderer.example.com:7050 --channelID mychannel --name simple --version 1.0 --init-required --sequence 1 --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br></code></pre></td></tr></table></figure><h3 id="调用链码"><a href="#调用链码" class="headerlink" title="调用链码"></a>调用链码</h3><p>初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n simple --isInit --ordererTLSHostnameOverride orderer.example.com --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[]&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><p>调用其他方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n simple --ordererTLSHostnameOverride orderer.example.com --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;open&quot;,&quot;Qanly&quot;,&quot;1000&quot;]&#125;&#x27;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">peer chaincode query -C mychannel -n simple -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;Qanly&quot;]&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><h2 id="5-测试一下"><a href="#5-测试一下" class="headerlink" title="5 测试一下"></a>5 测试一下</h2><p>使用 Caliper 测试的时候发现报错：找不到 connection-org1.yaml 这个文件，看一下 fabric-sample 网络的启动脚本发现有一个 ccp-generate.sh 脚本是用来生成这个的，把脚本和 .json .yaml 复制到 <code>twoPeerNet/crypto-config</code> 中，修改一下再运行就 ok 了。</p><p><img src="/Project3-Deploy/1.png" alt="目录"></p><p>记得要先修改 <code>caliper-benchmarks/networks/fabric/test-network.yaml</code> 中的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> caliper-benchmarks</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npx caliper launch manager \</span><br><span class="language-bash">    --caliper-workspace ./ \</span><br><span class="language-bash">    --caliper-networkconfig networks/fabric/test-network.yaml \</span><br><span class="language-bash">    --caliper-benchconfig benchmarks/scenario/simple/config.yaml \</span><br><span class="language-bash">    --caliper-flow-only-test \</span><br><span class="language-bash">    --caliper-fabric-gateway-enabled</span><br></code></pre></td></tr></table></figure><p>测试时我生成了 10 个账户，并用 100 的 tps 进行 500 次交易，可以发现大部分都因为读写冲突被中止了，这也正是我毕设项目希望解决的一个问题。</p><p><img src="/Project3-Deploy/2.png" alt="结果"></p><h2 id="6-查看日志"><a href="#6-查看日志" class="headerlink" title="6 查看日志"></a>6 查看日志</h2><p>创建容器后，可以单独开一个窗口查看输出的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f peer0.org1.example.com</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f orderer.example.com</span><br></code></pre></td></tr></table></figure><p>导出日志以便于查找：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs orderer.example.com 2&gt;&gt;log.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs peer0.org1.example.com 2&gt;&gt;log.txt</span><br></code></pre></td></tr></table></figure><h2 id="7-清理操作"><a href="#7-清理操作" class="headerlink" title="7 清理操作"></a>7 清理操作</h2><p>删除上述步骤生成的文件与容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop $(docker ps -a -q)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -a | awk <span class="hljs-string">&#x27;/fabric/ &#123;print $1&#125;&#x27;</span> | xargs -r docker stop</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -a | awk <span class="hljs-string">&#x27;/fabric/ &#123;print $1&#125;&#x27;</span> | xargs -r docker <span class="hljs-built_in">rm</span> -f</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume prune // 清除旧的卷</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">rm</span> $(docker volume <span class="hljs-built_in">ls</span> -qf <span class="hljs-string">&#x27;name=fabric-*&#x27;</span>)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker network <span class="hljs-built_in">rm</span> fabric_test // 清理网络缓存</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image prune -f //清理 none 镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi $(docker images | grep dev) // 清理链码镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi $(docker images -aq <span class="hljs-string">&#x27;hyperledger/fabric-*&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h2 id="8-脚本文件"><a href="#8-脚本文件" class="headerlink" title="8 脚本文件"></a>8 脚本文件</h2><p>记录一下自己第一次写脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment">## Parse mode</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$#</span> -lt 1 ]] ; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;errrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr&quot;</span><br>  <span class="hljs-built_in">exit</span> 0<br><span class="hljs-keyword">else</span><br>  MODE=<span class="hljs-variable">$1</span><br>  AC=<span class="hljs-variable">$2</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">networkUp</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;===========================================Starting Test Network===========================================&quot;</span><br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Generating files...&quot;</span><br><br>  <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PWD</span>/bin:/bin:/usr/bin<br>  cryptogen generate --config=crypto-config.yaml<br>  configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block -channelID test-channel<br>  configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel<br>  configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP<br>  configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP<br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting docker containers...&quot;</span><br><br>  docker-compose up -d<br>  <span class="hljs-built_in">sleep</span> 3<br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Creating mychannel...&quot;</span><br><br>  docker <span class="hljs-built_in">exec</span> cli1 peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/msp/tlscacerts/tlsca.example.com-cert.pem<br>  docker <span class="hljs-built_in">cp</span> cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/mychannel.block ./<br>  docker <span class="hljs-built_in">cp</span> ./mychannel.block cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer<br>  docker <span class="hljs-built_in">exec</span> cli1 peer channel <span class="hljs-built_in">join</span> -b mychannel.block<br>  docker <span class="hljs-built_in">exec</span> cli2 peer channel <span class="hljs-built_in">join</span> -b mychannel.block<br>  docker <span class="hljs-built_in">exec</span> cli1 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem<br>  docker <span class="hljs-built_in">exec</span> cli2 peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem<br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Installing test chaincode...&quot;</span><br><br>  docker <span class="hljs-built_in">cp</span> ./simple.tar.gz cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer<br>  docker <span class="hljs-built_in">cp</span> ./simple.tar.gz cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer<br><br>  docker <span class="hljs-built_in">exec</span> cli1 peer lifecycle chaincode install simple.tar.gz<br>  docker <span class="hljs-built_in">exec</span> cli2 peer lifecycle chaincode install simple.tar.gz<br><br>  docker <span class="hljs-built_in">exec</span> cli1 peer lifecycle chaincode approveformyorg --channelID mychannel --name simple --version 1.0 --init-required --package-id simple_1.0:6bcbc248b82a10b08863dcdf3f9da8681ec95b7336f345caf75aaeafbe2d5e64 --sequence 1 --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem<br>  docker <span class="hljs-built_in">exec</span> cli2 peer lifecycle chaincode approveformyorg --channelID mychannel --name simple --version 1.0 --init-required --package-id simple_1.0:6bcbc248b82a10b08863dcdf3f9da8681ec95b7336f345caf75aaeafbe2d5e64 --sequence 1 --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem<br>  docker <span class="hljs-built_in">exec</span> cli1 peer lifecycle chaincode commit -o orderer.example.com:7050 --channelID mychannel --name simple --version 1.0 --init-required --sequence 1 --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt<br> <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Initializing the chaincode...&quot;</span><br><br>  docker <span class="hljs-built_in">exec</span> cli1 peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n simple --isInit --ordererTLSHostnameOverride orderer.example.com --tls <span class="hljs-literal">true</span> --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[]&#125;&#x27;</span><br><br>  <span class="hljs-built_in">sleep</span> 3<br>  createAccount<br><br>  <span class="hljs-comment"># cd crypto-config</span><br>  <span class="hljs-comment"># ./ccp-generate.sh</span><br>&#125;<br><br>COMMAND=<span class="hljs-string">&quot;docker exec cli1 peer chaincode invoke \</span><br><span class="hljs-string">    -o orderer.example.com:7050 \</span><br><span class="hljs-string">    -C mychannel \</span><br><span class="hljs-string">    -n simple \</span><br><span class="hljs-string">    --ordererTLSHostnameOverride orderer.example.com \</span><br><span class="hljs-string">    --tls true \</span><br><span class="hljs-string">    --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem \</span><br><span class="hljs-string">    --peerAddresses peer0.org1.example.com:7051 \</span><br><span class="hljs-string">    --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt \</span><br><span class="hljs-string">    --peerAddresses peer0.org2.example.com:8051 \</span><br><span class="hljs-string">    --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">createAccount</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Opening new account ...&quot;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;open&quot;,&quot;A&quot;,&quot;1000&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;open&quot;,&quot;B&quot;,&quot;1000&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;open&quot;,&quot;C&quot;,&quot;1000&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;open&quot;,&quot;D&quot;,&quot;1000&quot;]&#125;&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">sendTransactions</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sending...&quot;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;transfer&quot;,&quot;A&quot;,&quot;B&quot;,&quot;100&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;transfer&quot;,&quot;A&quot;,&quot;B&quot;,&quot;100&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;transfer&quot;,&quot;A&quot;,&quot;C&quot;,&quot;100&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;transfer&quot;,&quot;D&quot;,&quot;A&quot;,&quot;100&quot;]&#125;&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">testReorder</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Testing...&quot;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;transfer&quot;,&quot;A&quot;,&quot;C&quot;,&quot;100&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;copy&quot;,&quot;A&quot;,&quot;B&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;copy&quot;,&quot;A&quot;,&quot;C&quot;]&#125;&#x27;</span><br>  <span class="hljs-variable">$COMMAND</span> -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;copy&quot;,&quot;A&quot;,&quot;D&quot;]&#125;&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">queryAccount</span></span>() &#123;<br>  <span class="hljs-keyword">if</span> [[ -z <span class="hljs-variable">$AC</span> ]]; <span class="hljs-keyword">then</span><br>    docker <span class="hljs-built_in">exec</span> cli1 peer chaincode query -C mychannel -n simple -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;A&quot;]&#125;&#x27;</span><br>    docker <span class="hljs-built_in">exec</span> cli1 peer chaincode query -C mychannel -n simple -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;B&quot;]&#125;&#x27;</span><br>    docker <span class="hljs-built_in">exec</span> cli1 peer chaincode query -C mychannel -n simple -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;C&quot;]&#125;&#x27;</span><br>    docker <span class="hljs-built_in">exec</span> cli1 peer chaincode query -C mychannel -n simple -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;D&quot;]&#125;&#x27;</span><br>  <span class="hljs-keyword">else</span> <br>    docker <span class="hljs-built_in">exec</span> cli1 peer chaincode query -C mychannel -n simple -c <span class="hljs-string">&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;, &quot;&#x27;</span><span class="hljs-string">&quot;<span class="hljs-variable">$AC</span>&quot;</span><span class="hljs-string">&#x27;&quot;]&#125;&#x27;</span><br>  <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">cli1</span></span>() &#123;<br>  docker <span class="hljs-built_in">exec</span> -it cli1 bash<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">networkDown</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;===========================================Ending Test Network===========================================&quot;</span><br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Stoping and Pruning fabric dockers...&quot;</span><br>  docker ps -a | awk <span class="hljs-string">&#x27;/fabric/ &#123;print $1&#125;&#x27;</span> | xargs -r docker stop<br>  docker ps -a | awk <span class="hljs-string">&#x27;/dev/ &#123;print $1&#125;&#x27;</span> | xargs -r docker stop<br>  docker ps -a | awk <span class="hljs-string">&#x27;/fabric/ &#123;print $1&#125;&#x27;</span> | xargs -r docker <span class="hljs-built_in">rm</span> -f<br>  docker ps -a | awk <span class="hljs-string">&#x27;/dev/ &#123;print $1&#125;&#x27;</span> | xargs -r docker <span class="hljs-built_in">rm</span> -f<br>  docker volume prune -f<br>  docker network <span class="hljs-built_in">rm</span> fabric_test<br>  docker rmi $(docker images | grep dev)<br>  docker image prune -f<br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Removing files...&quot;</span><br>  <span class="hljs-built_in">rm</span> -rf ./channel-artifacts<br>  <span class="hljs-built_in">rm</span> -rf ./crypto-config/ordererOrganizations<br>  <span class="hljs-built_in">rm</span> -rf ./crypto-config/peerOrganizations<br>  <span class="hljs-built_in">rm</span> ./mychannel.block<br>&#125;<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;up&quot;</span> ]; <span class="hljs-keyword">then</span><br>  networkUp<br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;down&quot;</span> ]; <span class="hljs-keyword">then</span><br>  networkDown<br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;open&quot;</span> ]; <span class="hljs-keyword">then</span><br>  createAccount<br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;send&quot;</span> ] || [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;s&quot;</span> ]; <span class="hljs-keyword">then</span><br>  sendTransactions<br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;test&quot;</span> ] || [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;t&quot;</span> ]; <span class="hljs-keyword">then</span><br>  testReorder<br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;query&quot;</span> ] || [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;q&quot;</span> ]; <span class="hljs-keyword">then</span><br>  queryAccount<br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;client&quot;</span> ] || [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> == <span class="hljs-string">&quot;c&quot;</span> ]; <span class="hljs-keyword">then</span><br>  cli1<br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;errrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr&quot;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;====================================================Done====================================================&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 TCP/IP 分层结构</title>
    <link href="/Research-FiveLayers/"/>
    <url>/Research-FiveLayers/</url>
    
    <content type="html"><![CDATA[<p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;互联网协议）是互联网的基本协议，也是国际互联网络的基础。TCP&#x2F;IP 是一个协议族，包括多个网络协议，定义了计算机操作系统如何连入互联网，以及数据传输的标准。它是为了解决不同系统的计算机之间的传输通信而提出的一个标准，不同系统的计算机采用了同一种协议后，就能相互通信，从而能够建立网络连接，实现资源共享和网络通信。</p><span id="more"></span><h2 id="TCP-x2F-IP-的分层结构"><a href="#TCP-x2F-IP-的分层结构" class="headerlink" title="TCP&#x2F;IP 的分层结构"></a>TCP&#x2F;IP 的分层结构</h2><p>目前对计算机网络的分层方式一共有三种：1.OSI 七层模型；2.五层模型；3.TCP&#x2F;IP 四层模型</p><p>OSI 是一种理论模型，实现起来过分复杂，而且运行效率低。OSI 先有模型，后有协议，先有标准，后进行实践，而 TCP&#x2F;IP 则相反。TCI&#x2F;IP 已经被广泛使用，成为网络互连实际上的标准。而五层模型一般只出现在计算机网络学习教学过程中，是对七层模型和四层模型的一个折中。</p><p><img src="/Research-FiveLayers/1.png" alt="三种模型"></p><ul><li><p><strong>应用层</strong>：包含所有的高层协议，比如 Telnet（Telecommunications Network，远程登录协议）、FTP、SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）、DNS（Domain Name Service，域名服务）、NNTP（Net News Transfer Protocol，网络新闻传输协议）和 HTTP 等。Telnet 允许一台机器上的用户登录远程机器进行工作，FTP 提供将文件从一台机器上移到另一台机器上的有效方法，SMTP 用于电子邮件的收发，DNS 用于把主机名映射到网络地址，NNTP 用于新闻的发布、检索和获取，HTTP 用于在 WWW 上获取主页。</p><p>  DNS 查询过程如下：</p><p>  <img src="/Research-FiveLayers/6.png"></p></li><li><p><strong>传输层</strong>：著名的 TCP 和 UDP（User Datagram Protocol，用户数据报协议）就在这一层。TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</p></li><li><p><strong>网络层</strong>：该层是整个 TCP&#x2F;IP 体系结构的关键部分，其功能是使主机可以把数据报（Packet，或称为分组）发往任何网络，并使分组独立地传向目标，分组经由不同的网络到达的顺序和发送的顺序可能不同。网络层使用的协议有 IP。</p><p>  <img src="/Research-FiveLayers/4.png"></p><ul><li>主机号全为 1 时指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 时指定某个网络</li><li>CIDR 无分类地址 a.b.c.d&#x2F;x，前 x 位属于网络号，x 的范围是 0 ~ 32</li><li>使用子网掩码也可以划分网络号与主机号，同时划分子网</li></ul><table><thead><tr><th align="center">类别</th><th align="center">IP 地址范围</th><th align="left">最大主机数</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0.0.0.0   ~ 127.255.255.255</td><td align="left">16777214</td></tr><tr><td align="center">B</td><td align="center">128.0.0.0 ~ 191.255.255.255</td><td align="left">65534</td></tr><tr><td align="center">C</td><td align="center">192.0.0.0 ~ 223.255.255.255</td><td align="left">254</td></tr></tbody></table><p>  为了缓解 IPv4 地址紧缺的问题，提出了 NAT（Network Address Translation，网络地址转换），将 <code>私有 IP + 端口</code> 转换为 <code>公有 IP + 端口</code>：</p><p>  <img src="/Research-FiveLayers/5.png"></p></li><li><p><strong>数据链路层</strong>：该层是整个体系结构的基础部分，负责接收 IP 层的 IP 数据报，通过网络向外发送，或接收从网络上来的物理帧，抽出 IP 数据报，向 IP 层发送。该层是主机与网络的实际连接层。数据链路层下面就是实体线路（比如以太网络、光纤网络等）。数据链路层有以太网、令牌环网等标准，负责网卡设备的驱动、帧同步（从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机可以在不同的数据链路层的网络之间（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间）转发数据帧，由于不同数据链路层的帧格式不同，交换机要将进来的数据报拆掉报头重新封装之后再转发。</p></li></ul><p>不同的协议层对数据报有不同的称谓，在传输层叫作段（Segment），在网络层叫作数据报（Datagram），在数据链路层叫作帧（Frame）。数据封装成帧后发送到传输介质上，到达目的主机后，每层协议再剥掉相应的报头，最后将应用层数据交给应用程序处理。</p><p><img src="/Research-FiveLayers/2.png" alt="数据封装"></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>以浏览某个网页为例，看一下浏览网页的过程中 TCP&#x2F;IP 各层做了哪些工作。</p><ul><li>发送方：</li></ul><ol><li>打开浏览器，输入网址 <a href="http://www.xxx.com/">www.xxx.com</a> 按回车键来访问网页，其实就是访问 Web 服务器上的网页，在应用层采用的协议是 HTTP，浏览器将网址等信息组成 HTTP 数据，并将数据传送给传输层。</li><li>传输层在数据前面加上 TCP 报头，并标记端口为 80（Web 服务器的默认端口），将这个数据段给了网络层。</li><li>网络层在这个数据段前面加上自己的 IP 和目的 IP，这时该段被称为 IP 数据报，然后将这个 IP 数据报给了数据链路层。</li><li>数据链路层先在 IP 数据报前面加上自己机器的 MAC 地址以及目的 MAC 地址，加上 MAC 地址的数据称为帧，然后通过物理网卡把这个帧以比特流的方式发送到网络上。</li></ol><p>互联网上有路由器，它会读取比特流中的 IP 地址进行路由操作，到达正确的网段后，这个网段的交换机读取比特流中的 MAC 地址，从而找到要接收的对应机器。</p><ul><li>接收方：</li></ul><ol><li>数据链路层用网卡接收到了比特流，读取比特流中的帧，将帧中的 MAC 地址去掉，就成了 IP 数据报，传递给网络层。</li><li>网络层接收下层传来的 IP 数据报，将 IP 从包的前面拿掉，取出带有 TCP 的数据（数据段）交给传输层。</li><li>传输层拿到了这个数据段，看到 TCP 标记的端口是 80，说明应用层协议是 HTTP，之后将 TCP 头去掉并将数据交给应用层，告诉应用层对方请求的是 HTTP 数据。</li><li>应用层得知发送方请求的是 HTTP 数据，因此调用 Web 服务器程序把 <a href="http://www.xxx.com/">www.xxx.com</a> 的首页文件发送回去。</li></ol><p>如果两台计算机位于不同的网段中，那么数据从一台计算机到另一台计算机传输的过程中要经过一个或多个路由器：</p><p><img src="/Research-FiveLayers/3.png" alt="FTP 例子"></p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 2. 编译 Fabric 源码</title>
    <link href="/Project2-Compile/"/>
    <url>/Project2-Compile/</url>
    
    <content type="html"><![CDATA[<p>本文尝试编译 Fabric 源码来构建网络。</p><span id="more"></span><h2 id="bootstrap-sh"><a href="#bootstrap-sh" class="headerlink" title="bootstrap.sh"></a>bootstrap.sh</h2><p>在上一篇文章中，我直接执行了 bootstrap.sh 这个脚本一键部署。使用这个方法根本不需要拉取 Fabric 的源代码，它为我们做了三件事情：</p><ol><li>从 github 上克隆 hyperledger&#x2F;fabric-samples 并进入该目录，然后检出适当的版本</li><li>在 fabric-samples 目录下安装特定平台的 Hyperledger Fabric 二进制可执行文件和配置文件</li><li>下载指定版本的 Hyperledger Fabric 的 docker 镜像</li></ol><p>其中第二步是执行 curl 去下载 tar 包并解压，二进制文件会被放在 bin 目录下：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>peer</td><td>负责启动节点，存储区块链数据，运行维护链码</td></tr><tr><td>orderer</td><td>负责启动排序节点，对交易进行排序，并将排序好的交易打包成模块</td></tr><tr><td>cryptogen</td><td>生成组织结构和身份文件</td></tr><tr><td>configtxgen</td><td>生成配置区块和配置交易</td></tr><tr><td>configtxlator</td><td>解读配置信息</td></tr><tr><td>fabric-ca-client</td><td>fabric-ca 客户端命令</td></tr><tr><td>discover</td><td>fabric 发现服务的客户端命令</td></tr><tr><td>idemixgen</td><td>身份混合机制</td></tr></tbody></table><p>部分镜像说明如下：</p><table><thead><tr><th>镜像名称</th><th>是否可选</th><th>镜像说明</th></tr></thead><tbody><tr><td>hyperledger&#x2F;fabric-tools</td><td>可选</td><td>包含 crytogen、configtxgen、configtxlator 工具的镜像文件</td></tr><tr><td>hyperledger&#x2F;fabric-couchdb</td><td>可选</td><td>CouchDB 的数据库镜像文件、状态数据库选择 CouchDB 的时候才需要</td></tr><tr><td>hyperledger&#x2F;fabric-kafka</td><td>可选</td><td>Kafka 的镜像文件</td></tr><tr><td>hyperledger&#x2F;fabric-zookeeper</td><td>可选</td><td>Zookeeper 的镜像文件</td></tr><tr><td>hyperledger&#x2F;fabric-peer</td><td>必选</td><td>Peer 节点的镜像文件</td></tr><tr><td>hyperledger&#x2F;fabric-orderer</td><td>必选</td><td>排序服务节点的镜像文件</td></tr><tr><td>hyperledger&#x2F;fabric-javaenv</td><td>可选</td><td>Java 链码的基础镜像文件</td></tr><tr><td>hyperledger&#x2F;fabric-ccenv</td><td>必选</td><td>Golang 链码的基础镜像文件</td></tr><tr><td>hyperledger&#x2F;fabric-ca</td><td>可选</td><td>fabric-ca 的镜像文件，用到 fabric-ca 的时候才需要</td></tr></tbody></table><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>接下来尝试一下从 Fabric 源码入手，来搭建网络。</p><h3 id="1-下载-fabric-源码"><a href="#1-下载-fabric-源码" class="headerlink" title="1. 下载 fabric 源码"></a>1. 下载 fabric 源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ git clone https://github.com/hyperledger/fabric.git<br>$ cd fabric<br>$ git checkout v2.4.0<br></code></pre></td></tr></table></figure><h3 id="2-编译-fabric-源码"><a href="#2-编译-fabric-源码" class="headerlink" title="2. 编译 fabric 源码"></a>2. 编译 fabric 源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ make release<br></code></pre></td></tr></table></figure><p>编译好的二进制可执行文件在 <code>fabric/release/linux-amd64/bin/</code> 下：</p><p><img src="/Project2-Compile/1.png" alt="二进制文件"></p><h4 id="测试编译"><a href="#测试编译" class="headerlink" title="测试编译"></a>测试编译</h4><p>我注意到网上的教程都需要我们把 fabric 的源码放在 <code>$GOPATH/src/github.com/heperledger/</code> 目录下，Makefile 文件中的编译路径也是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">PKGNAME = github.com/hyperledger/fabric<br><br>pkgmap.configtxgen    := <span class="hljs-variable">$(PKGNAME)</span>/cmd/configtxgen<br>pkgmap.configtxlator  := <span class="hljs-variable">$(PKGNAME)</span>/cmd/configtxlator<br>pkgmap.cryptogen      := <span class="hljs-variable">$(PKGNAME)</span>/cmd/cryptogen<br>pkgmap.discover       := <span class="hljs-variable">$(PKGNAME)</span>/cmd/discover<br>pkgmap.ledgerutil     := <span class="hljs-variable">$(PKGNAME)</span>/cmd/ledgerutil<br>pkgmap.orderer        := <span class="hljs-variable">$(PKGNAME)</span>/cmd/orderer<br>pkgmap.osnadmin       := <span class="hljs-variable">$(PKGNAME)</span>/cmd/osnadmin<br>pkgmap.peer           := <span class="hljs-variable">$(PKGNAME)</span>/cmd/peer<br></code></pre></td></tr></table></figure><p>为了测试能否在自定义路径中编译源码，我修改了 <code>fabric/internal/peer/version/version.go</code> :</p><p><img src="/Project2-Compile/3.png" alt="version.go"></p><p>然后编译并执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ make peer<br>$ export PATH=$PWD/build/bin<br>$ peer<br></code></pre></td></tr></table></figure><p><img src="/Project2-Compile/4.png" alt="输出"></p><h3 id="3-下载-fabric-ca-源码"><a href="#3-下载-fabric-ca-源码" class="headerlink" title="3. 下载 fabric-ca 源码"></a>3. 下载 fabric-ca 源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ git clone https://github.com/hyperledger/fabric-ca.git<br>$ cd fabric-ca<br></code></pre></td></tr></table></figure><h3 id="4-编译-fabric-ca-源码"><a href="#4-编译-fabric-ca-源码" class="headerlink" title="4. 编译 fabric-ca 源码"></a>4. 编译 fabric-ca 源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ make fabric-ca-server<br>$ make fabric-ca-client<br></code></pre></td></tr></table></figure><p>编译好的二进制可执行文件在 <code>fabric-ca/bin/</code> 下：</p><p><img src="/Project2-Compile/2.png" alt="二进制文件"></p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>把当前用户加入到 docker 用户组后，分别在 fabric 和 fabric-ca 目录下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ make docker<br></code></pre></td></tr></table></figure><p><img src="/Project2-Compile/6.png" alt="Docker Images"></p><h3 id="镜像代码"><a href="#镜像代码" class="headerlink" title="镜像代码"></a>镜像代码</h3><p><code>Makefile</code> 中制作 docker 镜像的代码如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: docker</span><br><span class="hljs-section">docker: $(RELEASE_IMAGES:%=%-docker)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: $(RELEASE_IMAGES:%=%-docker)</span><br><span class="hljs-section">$(RELEASE_IMAGES:%=%-docker): %-docker: <span class="hljs-variable">$(BUILD_DIR)</span>/images/%/<span class="hljs-variable">$(DUMMY)</span></span><br><br><span class="hljs-variable">$(BUILD_DIR)</span>/images/baseos/<span class="hljs-variable">$(DUMMY)</span>:  BUILD_CONTEXT=images/baseos<br><span class="hljs-variable">$(BUILD_DIR)</span>/images/ccenv/<span class="hljs-variable">$(DUMMY)</span>:   BUILD_CONTEXT=images/ccenv<br><span class="hljs-variable">$(BUILD_DIR)</span>/images/peer/<span class="hljs-variable">$(DUMMY)</span>:    BUILD_ARGS=--build-arg GO_TAGS=$&#123;GO_TAGS&#125;<br><span class="hljs-variable">$(BUILD_DIR)</span>/images/orderer/<span class="hljs-variable">$(DUMMY)</span>: BUILD_ARGS=--build-arg GO_TAGS=$&#123;GO_TAGS&#125;<br><span class="hljs-variable">$(BUILD_DIR)</span>/images/tools/<span class="hljs-variable">$(DUMMY)</span>:   BUILD_ARGS=--build-arg GO_TAGS=$&#123;GO_TAGS&#125;<br><br><span class="hljs-variable">$(BUILD_DIR)</span>/images/%/<span class="hljs-variable">$(DUMMY)</span>:<br>@echo <span class="hljs-string">&quot;Building Docker image <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span>&quot;</span><br>@mkdir -p $(@D)<br><span class="hljs-variable">$(DBUILD)</span> -f images/<span class="hljs-variable">$*</span>/Dockerfile \<br>--build-arg GO_VER=<span class="hljs-variable">$(GO_VER)</span> \<br>--build-arg ALPINE_VER=<span class="hljs-variable">$(ALPINE_VER)</span> \<br><span class="hljs-variable">$(BUILD_ARGS)</span> \<br>-t <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span> ./<span class="hljs-variable">$(BUILD_CONTEXT)</span><br>docker tag <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span> <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span>:<span class="hljs-variable">$(BASE_VERSION)</span><br>docker tag <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span> <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span>:<span class="hljs-variable">$(TWO_DIGIT_VERSION)</span><br>docker tag <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span> <span class="hljs-variable">$(DOCKER_NS)</span>/fabric-<span class="hljs-variable">$*</span>:<span class="hljs-variable">$(DOCKER_TAG)</span><br>@touch <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>其中 <code>$(DBUILD) -f</code> 即 <code>docker build -f</code> 指明了 <code>Dockerfile</code> 的路径。以 <code>fabric/images/peer/Dockerfile</code> 为例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> alpine:$&#123;ALPINE_VER&#125; as peer-base<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache tzdata</span><br><span class="hljs-comment"># set up nsswitch.conf for Go&#x27;s &quot;netgo&quot; implementation</span><br><span class="hljs-comment"># - https://github.com/golang/go/blob/go1.9.1/src/net/conf.go#L194-L275</span><br><span class="hljs-comment"># - docker run --rm debian:stretch grep &#x27;^hosts:&#x27; /etc/nsswitch.conf</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hosts: files dns&#x27;</span> &gt; /etc/nsswitch.conf</span><br><br><span class="hljs-keyword">FROM</span> golang:$&#123;GO_VER&#125;-alpine$&#123;ALPINE_VER&#125; as golang<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache \</span><br><span class="language-bash">bash \</span><br><span class="language-bash">binutils-gold \</span><br><span class="language-bash">gcc \</span><br><span class="language-bash">git \</span><br><span class="language-bash">make \</span><br><span class="language-bash">musl-dev</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . <span class="hljs-variable">$GOPATH</span>/src/github.com/hyperledger/fabric</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$GOPATH</span>/src/github.com/hyperledger/fabric</span><br><br><span class="hljs-keyword">FROM</span> golang as peer<br><span class="hljs-keyword">ARG</span> GO_TAGS<br><span class="hljs-keyword">RUN</span><span class="language-bash"> make peer GO_TAGS=<span class="hljs-variable">$&#123;GO_TAGS&#125;</span></span><br><br><span class="hljs-keyword">FROM</span> peer-base<br><span class="hljs-keyword">ENV</span> FABRIC_CFG_PATH /etc/hyperledger/fabric<br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /etc/hyperledger/fabric</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /var/hyperledger</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=peer /go/src/github.com/hyperledger/fabric/build/bin /usr/local/bin</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=peer /go/src/github.com/hyperledger/fabric/sampleconfig/msp <span class="hljs-variable">$&#123;FABRIC_CFG_PATH&#125;</span>/msp</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=peer /go/src/github.com/hyperledger/fabric/sampleconfig/core.yaml <span class="hljs-variable">$&#123;FABRIC_CFG_PATH&#125;</span></span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">7051</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;peer&quot;</span>,<span class="hljs-string">&quot;node&quot;</span>,<span class="hljs-string">&quot;start&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>这是一个分阶段构建镜像的过程，每个阶段生成一个镜像，下一个阶段在此基础上生成：</p><ol><li><p><strong>peer-base</strong> 阶段：</p><ul><li>基于指定的 Alpine 版本构建基础镜像。</li><li>安装 tzdata 包，用于时区设置。</li><li>配置 nsswitch.conf 文件，以支持 Go 的 “netgo” 实现。</li></ul></li><li><p><strong>golang</strong> 阶段：</p><ul><li>基于指定的 Go 版本和 Alpine 版本构建 Golang 镜像。</li><li>安装构建所需的工具和依赖，如 bash、binutils-gold、gcc、git、make 和 musl-dev。</li><li>将<strong>当前目录下</strong>的文件复制到 Golang 镜像的对应路径 <code>$GOPATH/src/github.com/hyperledger/fabric</code>。</li></ul></li><li><p><strong>peer</strong> 阶段：</p><ul><li>基于 golang 阶段构建一个临时的 Golang 镜像。</li><li>使用 make 命令构建 Peer 节点的二进制文件。</li><li>使用 GO_TAGS 参数指定构建所需的 Go 标签。</li></ul></li><li><p><strong>最终</strong>阶段：</p><ul><li>基于 peer-base 阶段构建最终的镜像。</li><li>设置环境变量 FABRIC_CFG_PATH 为 &#x2F;etc&#x2F;hyperledger&#x2F;fabric。</li><li>创建两个数据卷，分别用于存储 Fabric 配置文件和 Hyperledger 数据。</li><li>从 peer 阶段复制生成的二进制文件到 &#x2F;usr&#x2F;local&#x2F;bin 目录下。</li><li>从 peer 阶段复制生成的 MSP 配置到 &#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;msp 目录下。</li><li>从 peer 阶段复制生成的核心配置文件 core.yaml 到 &#x2F;etc&#x2F;hyperledger&#x2F;fabric 目录下。</li><li>暴露容器的 7051 端口。</li><li>使用 CMD 指令在容器启动时运行 peer node start 命令。</li></ul></li></ol><p><strong>可以看出该镜像并非直接复制主机编译的二进制文件，而是复制当前目录的代码，在容器中自己编译。</strong></p><h3 id="测试镜像"><a href="#测试镜像" class="headerlink" title="测试镜像"></a>测试镜像</h3><p>保留之前测试编译的更改，制作 peer 镜像并进入容器测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ make peer-docker<br>$ docker run hyperledger/fabric-peer<br>$ docker exec -it container_id /bin/sh<br># peer<br></code></pre></td></tr></table></figure><p><img src="/Project2-Compile/5.png" alt="输出"></p><h2 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd fabric-samples<br></code></pre></td></tr></table></figure><p>将之前编译的二进制文件全部放在 <code>fabric-samples/bin</code> 下：</p><p><img src="/Project2-Compile/7.png" alt="bin"></p><p>此时还需要生成节点的配置文件，将 <code>fabric/sampleconfig</code> 复制到 fabric-samples，并改名 config。</p><p>启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd test-network<br>$ ./network.sh up<br></code></pre></td></tr></table></figure><p>成功启动！</p><p>但是在创建通道的时候组织二的节点无法加入，将 peer 的二进制文件更换为官方提供直接下载的则没有这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(12)：存储和数据库</title>
    <link href="/ByteDance-12/"/>
    <url>/ByteDance-12/</url>
    
    <content type="html"><![CDATA[<p>存储的本质 —— 状态。</p><span id="more"></span><h2 id="1-存储系统"><a href="#1-存储系统" class="headerlink" title="1 存储系统"></a>1 存储系统</h2><p>一个提供了读写、控制类接口，能够安全有效地把数据持久化的软件，就可以称为存储系统。</p><h3 id="1-1-系统特点"><a href="#1-1-系统特点" class="headerlink" title="1.1 系统特点"></a>1.1 系统特点</h3><ul><li>作为后端软件的底座，性能敏感</li><li>存储系统软件架构，容易受硬件影响</li><li>存储系统代码，既“简单”又“复杂”</li></ul><h3 id="1-2-RAID-技术"><a href="#1-2-RAID-技术" class="headerlink" title="1.2 RAID 技术"></a>1.2 RAID 技术</h3><p>单机存储系统怎么做到高性能&#x2F;高性价比&#x2F;高可靠性：R(edundant) A(rray) of I(nexpensive) D(isks)。</p><ul><li><p>RAID 0</p><ul><li>多块磁盘简单组合</li><li>数据条带化存储，提高磁盘带宽</li><li>没有额外的容错设计</li></ul></li><li><p>RAID 1</p><ul><li>一块磁盘对应一块额外镜像盘</li><li>真实空间利用率仅 50%</li><li>容错能力强</li></ul></li><li><p>RAID 0 + 1</p><ul><li>结合了 RAID 0 和 RAID 1</li><li>真实空间利用率仅 50%</li><li>容错能力强，写入带宽好</li></ul></li></ul><h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2 数据库"></a>2 数据库</h2><ul><li><p><strong>关系型数据库</strong><br>  关系型数据库是把数据以表的形式进行储存，然后再各个表之间建立关系，通过这些表之间的关系来操作不同表之间的数据。</p><ul><li>结构化数据友好</li><li>支持事务（ACID）</li><li>支持复杂查询语言</li></ul></li><li><p><strong>非关系型数据库</strong><br>  NoSQL 或非关系数据库，支持存储和操作非结构化及半结构化数据。相比于关系型数据库，NoSQL 没有固定的表结构，且数据之间不存在表与表之间的关系，数据之间可以是独立的。NoSQL 的关键是它们放弃了传统关系型数据库的强事务保证和关系模型，通过所谓最终一致性和非关系数据模型（例如键值对，图，文档）来提高 Web 应用所注重的高可用性和可扩展性。</p><ul><li>半结构化数据友好</li><li><strong>可能</strong>支持事务（ACID）</li><li><strong>可能</strong>支持复杂查询语言</li></ul></li></ul><h3 id="2-1-结构化数据管理"><a href="#2-1-结构化数据管理" class="headerlink" title="2.1 结构化数据管理"></a>2.1 结构化数据管理</h3><p><img src="/ByteDance-12/1.png"></p><h3 id="2-2-事物能力"><a href="#2-2-事物能力" class="headerlink" title="2.2 事物能力"></a>2.2 事物能力</h3><ul><li>A(tomicity)，事务内的操作要么全做，要么不做</li><li>C(onsistency)，事务执行前后，数据状态是一致的（数据完整，逻辑一致）</li><li>I(solation)，可以隔离多个并发事务，避免影响</li><li>D(urability)，事务一旦提交成功，数据保证持久性</li></ul><h3 id="2-3-复杂查询能力"><a href="#2-3-复杂查询能力" class="headerlink" title="2.3 复杂查询能力"></a>2.3 复杂查询能力</h3><p><img src="/ByteDance-12/2.png"></p><h2 id="3-主流产品"><a href="#3-主流产品" class="headerlink" title="3 主流产品"></a>3 主流产品</h2><h3 id="3-1-单机存储"><a href="#3-1-单机存储" class="headerlink" title="3.1 单机存储"></a>3.1 单机存储</h3><p>单个计算机节点上的存储软件系统，一般不涉及网络交互。</p><ul><li><p><strong>本地文件系统</strong>：如 Linux 文件系统</p><ul><li>Index Node 记录文件元数据，如 id、大小、权限、磁盘位置等。inode 是一个文件的唯一标识，会被存储到磁盘上，其总数在格式化文件系统时就固定了。</li><li>Directory Entry 记录文件名、inode 指针，层级关系（parent）等。dentry 是内存结构，与 inode 的关系是 N:1（hardlink的实现）。</li></ul></li><li><p><strong>key-value 存储</strong>：如 RocksDB</p></li></ul><h3 id="3-2-分布式存储"><a href="#3-2-分布式存储" class="headerlink" title="3.2 分布式存储"></a>3.2 分布式存储</h3><p>在单机存储基础上实现了分布式协议，涉及大量网络交互。</p><ul><li><strong>HDFS</strong>：支持海量数据存储，高容错性，弱 POSIX 语义，使用普通 x86 服务器，性价比高</li><li><strong>Ceph</strong>：一套系统支持对象接口、块接口、文件接口，但是一切皆对象，数据写入采用主备复制模型，数据分布模型采用 CRUSH 算法</li></ul><h3 id="3-3-单机数据库"><a href="#3-3-单机数据库" class="headerlink" title="3.3 单机数据库"></a>3.3 单机数据库</h3><p>单个计算机节点上的数据库系统。</p><ul><li><p><strong>关系型数据库</strong></p><ul><li>Oracle</li><li>MySQL</li><li>PostgreSQL</li></ul></li><li><p><strong>非关系型数据库</strong></p><ul><li>MongoDB</li><li>Redis</li><li>Elasticsearch</li></ul></li></ul><h3 id="3-4-分布式数据库"><a href="#3-4-分布式数据库" class="headerlink" title="3.4 分布式数据库"></a>3.4 分布式数据库</h3><ul><li><strong>容量</strong>：单点容量有限，受硬件限制；存储节点池化，动态扩缩容</li><li><strong>弹性</strong>：方便扩缩容</li><li><strong>性价比</strong>：平衡容量与 CPU 利用率需求</li></ul><h2 id="4-MySQL"><a href="#4-MySQL" class="headerlink" title="4 MySQL"></a>4 MySQL</h2><h3 id="4-1-SQL"><a href="#4-1-SQL" class="headerlink" title="4.1 SQL"></a>4.1 SQL</h3><p>一种编程语言，目前几乎所有的关系数据库都使用 SQL (Structured Query Language) 编程语言来查询、操作和定义数据，进行数据访问控制。</p><p><img src="/ByteDance-12/3.png"></p><h4 id="4-1-1-SQL-引擎"><a href="#4-1-1-SQL-引擎" class="headerlink" title="4.1.1 SQL 引擎"></a>4.1.1 SQL 引擎</h4><ul><li><p><strong>查询解析 Parser</strong>：解析器（Parser）一般分为词法分析（Lexical analysis）、语法分析（Syntax analysis）、语义分析（Semantic analyzer）等步骤。SQL 语言接近自然语言，入门容易。但是各种关键字、操作符组合起来，可以表达丰富的语意。因此想要处理 SQL 命令，首先将文本解析成结构化数据，也就是抽象语法树（AST）</p></li><li><p><strong>查询优化 Optimizer</strong>：SQL 是一门非过程化的语言，只说“做什么”，而不说“怎么做”。所以需要一些复杂的逻辑选择“如何拿数据”，也就是选择一个好的查询计划。优化器的作用根据 AST 优化产生最优执行计划（Plan Tree）</p></li><li><p><strong>查询执行 Executor</strong>：根据查询计划，完成数据读取、处理、写入等操作</p></li></ul><h4 id="4-1-2-事务引擎"><a href="#4-1-2-事务引擎" class="headerlink" title="4.1.2 事务引擎"></a>4.1.2 事务引擎</h4><p>处理事务一致性、并发、读写隔离等。</p><ul><li>Atomicity：Undo Log 是逻辑日志，记录的是数据的增量变化。利用 Undo Log 可以进行事务回滚，从而保证事务的原子性。同时也实现了多版本并发控制（MVCC），解决读写冲突和一致性读的问题</li><li>Isolation：锁、MVCC</li><li>Durability：Redo Log 是物理日志，记录的是页面的变化，它的作用是保证事务持久化。如果数据写入磁盘前发生故障，重启 MySQL 后会根据 Redo Log 重做</li></ul><h4 id="4-1-3-存储引擎"><a href="#4-1-3-存储引擎" class="headerlink" title="4.1.3 存储引擎"></a>4.1.3 存储引擎</h4><p>内存中的数据缓存区、数据文件、日志文件。</p><p><img src="/ByteDance-12/4.png"></p><ul><li><p>Buffer Pool</p><p>  <img src="/ByteDance-12/5.png"></p><p>  MySQL 中每个 chunk 的大小一般为 128M，每个 block 对应一个page，一个 chunk 下面有 8192 个 block。这样可以避免内存碎片化。分成多个 instance，可以有效避免并发冲突。</p><p>  Page id % instance num 得到它属于哪个 instance。</p></li><li><p>Page</p><p>  <img src="/ByteDance-12/6.png"></p></li><li><p>B+ Tree</p><p>  页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。<br>  <img src="/ByteDance-12/7.png"></p></li></ul><h2 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5 Redis"></a>5 Redis</h2><p>Redis 用于解决关系型数据库性能问题，可以将经常访问的热数据放入内存中。</p><h3 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h3><p><img src="/ByteDance-12/8.png"></p><ul><li>内存数据库，数据从内存中读写</li><li>数据保存到硬盘上防止重启数据丢失<ul><li>增量数据保存到 AOF 文件（Append Only File）</li><li>全量数据保存到 RDB 文件（Redis Database Backup file）</li></ul></li><li>单线程处理所有操作命令</li></ul><h3 id="5-2-数据结构"><a href="#5-2-数据结构" class="headerlink" title="5.2 数据结构"></a>5.2 数据结构</h3><h4 id="5-2-1-字符串-sds"><a href="#5-2-1-字符串-sds" class="headerlink" title="5.2.1 字符串 - sds"></a>5.2.1 字符串 - sds</h4><p>最常规的 set&#x2F;get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p><p><img src="/ByteDance-12/9.png"></p><h4 id="5-2-2-链表-Quicklist"><a href="#5-2-2-链表-Quicklist" class="headerlink" title="5.2.2 链表 - Quicklist"></a>5.2.2 链表 - Quicklist</h4><p>Quicklist 由一个双向链表和 listpack 实现。可以做简单的消息队列的功能。</p><p><img src="/ByteDance-12/10.png" alt="Quicklist"><br><img src="/ByteDance-12/11.png" alt="listpack"></p><h4 id="5-2-3-集合-set"><a href="#5-2-3-集合-set" class="headerlink" title="5.2.3 集合 - set"></a>5.2.3 集合 - set</h4><p>无序的字符串集合，不存在重复的元素。</p><p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>Zset：有序集合，多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。</p><h4 id="5-2-4-哈希表-dict"><a href="#5-2-4-哈希表-dict" class="headerlink" title="5.2.4 哈希表 - dict"></a>5.2.4 哈希表 - dict</h4><p>这个结构体里定义了两个哈希表，在正常服务请求阶段，插入的数据，都会写入到 ht[0]，此时的 ht[1] 并没有被分配空间。随着数据逐步增多，会触发 rehash 操作用于扩大空间。</p><p><img src="/ByteDance-12/12.png"></p><p>rehash：给 ht[1] 分配空间，一般会比 ht[0] 大 2 倍。将 ht[0] 中的数据，全部迁移到 ht[1] 中。迁移完成后，ht[0] 的空间会被释放，并把 ht[1] 设置为 ht[0]，然后在 ht[1] 新创建一个空白的哈希表，为下次 rehash 做准备。数据量小的场景下，直接将数据从 ht[0] 拷贝到 ht[1] 速度是较快的。数据量大的场景，例如存有上百万的 KV 时，迁移过程将会明显阻塞用户请求。</p><p>渐进式 rehash：为避免出现这种情况，每次用户访问时都会迁移少量数据。将整个迁移过程，平摊到所有请求过程中。</p><h4 id="5-2-5-跳表-zskiplist"><a href="#5-2-5-跳表-zskiplist" class="headerlink" title="5.2.5 跳表 - zskiplist"></a>5.2.5 跳表 - zskiplist</h4><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是 O(N)，于是就出现了跳表。跳表是在链表基础上改进过来的，实现了一种<strong>多层</strong>的有序链表，这样的好处是能快读定位数据。</p><p><img src="/ByteDance-12/13.png"></p><h3 id="5-3-注意事项"><a href="#5-3-注意事项" class="headerlink" title="5.3 注意事项"></a>5.3 注意事项</h3><h4 id="5-3-1-大-Key"><a href="#5-3-1-大-Key" class="headerlink" title="5.3.1 大 Key"></a>5.3.1 大 Key</h4><p>String 类型 value 的字节数大于 10KB 即为大 key；Hash&#x2F;Set&#x2F;Zset&#x2F;list 等复杂数据结构类型元素个数大于 5000 个或总 value 字节数大于 10MB 即为大 key。</p><ul><li>读取成本高</li><li>容易导致慢查询（过期、删除）</li><li>主从复制异常，服务阻塞无法正常响应请求</li></ul><p><strong>解决方法</strong>：</p><ol><li>拆分：将大 key 拆分为小 key。例如一个 String 拆分成多个 String</li><li>压缩：将 value 压缩后写入 redis，读取时解压后再使用</li><li>集合类结构 hash、list、set、set<ol><li>拆分：可以用 hash 取余、位掩码的方式决定放在哪个 key 中</li><li>区分冷热：如榜单列表场景使用 zset，只缓存前 10 页数据，后续数据读取 db</li></ol></li></ol><h4 id="5-3-2-热-Key"><a href="#5-3-2-热-Key" class="headerlink" title="5.3.2 热 Key"></a>5.3.2 热 Key</h4><p>用户访问一个 Key 的 QPS 特别高，导致 Server 实例出现 CPU 负载突增或者不均的情况。</p><p><strong>解决方法</strong>：</p><ol><li>设置 Localcache：在访问 Redis 前，在业务服务侧设置 LocalCache，降低访问 Redis 的 QPS。LocalCache 中缓存过期或未命中，则从 Redis 中将数据更新到 LocalCache</li><li>拆分：将 key:value 这一个热 Key 复制写入多份，例如 keyl:value，key2:value，访问的时候访问多个 key，但 value 是同一个，以此将 QPS 分散到不同实例上，降低负载。代价是，更新时需要更新多个 key，存在数据短暂不一致的风险</li></ol><h4 id="5-3-3-慢查询"><a href="#5-3-3-慢查询" class="headerlink" title="5.3.3 慢查询"></a>5.3.3 慢查询</h4><p><strong>容易导致 Redis 慢查询的操作</strong>：</p><ol><li>批量操作一次性传入过多的 key&#x2F;value，如 mset&#x2F;hmset&#x2F;sadd&#x2F;zadd 等 O(n) 操作建议单批次不要超过 100，超过 100 之后性能下降明显</li><li>zset 大部分命令都是 O(log(n))，当大小超过 5k 以上时，简单的 zadd&#x2F;zrem 也可能导致慢查询</li><li>操作的单个 value 过大，超过 10KB。即避免使用大 Key</li><li>对大 key 的 delete&#x2F;expire 操作也可能导致慢查询</li></ol><h4 id="5-3-4-缓存穿透"><a href="#5-3-4-缓存穿透" class="headerlink" title="5.3.4 缓存穿透"></a>5.3.4 缓存穿透</h4><p>热点数据查询绕过缓存，直接查询数据库。</p><ol><li>查询一个一定不存在的数据（穿透）：通常不会缓存不存在的数据，这类查询请求都会直接打到 db，如果有系统 bug 或人为攻击，那么容易导致 db 响应慢甚至宕机</li><li>缓存过期时（击穿）：在高并发场景下，一个热 key 如果过期，会有大量请求同时击穿至 db，容易影响 db 性能和稳定。同一时间有大量 key 集中过期时，也会导致大量请求落到 db 上，导致查询变慢，甚至出现 db 无法响应新的查询</li></ol><p><strong>解决方法</strong>：</p><ol><li>缓存空值：如一个 id 在缓存和数据库中都不存在。则可以缓存一个空值，下次再查缓存直接反空值</li><li>布隆过滤器：通过 bloom filter 算法来存储合法 Key，得益于该算法超高的压缩率，只需占用极小的空间就能存储大量 key 值</li><li>IP 拉黑，但可能会用不同的 IP 来攻击</li><li>接口层增加参数合法性校验，如用户鉴权校验，id &lt;&#x3D; 0 的直接拦截</li></ol><h4 id="5-3-5-缓存雪崩"><a href="#5-3-5-缓存雪崩" class="headerlink" title="5.3.5 缓存雪崩"></a>5.3.5 缓存雪崩</h4><p>大量缓存同时过期，导致大量请求全部打到数据库，造成数据库挂掉。</p><p><strong>解决方法</strong>：</p><ol><li>设置过期时间：将缓存失效时间分散开，比如在原有的失效时间基础上增加一个随机值，例如不同 Key 过期时间，可以设置为 10 分 1 秒过期，10 分 23 秒过期，10 分 8 秒过期。单位秒部分就是随机时间，这样过期时间就分散了。对于热点数据，过期时间尽量设置得长一些，冷门的数据可以相对设置过期时间短一些</li><li>使用缓存集群，避免单机宕机造成的缓存雪崩</li><li>设置热点数据永远不过期。</li><li>不断的用定时任务去刷新缓存</li></ol><h2 id="6-ClickHouse"><a href="#6-ClickHouse" class="headerlink" title="6 ClickHouse"></a>6 ClickHouse</h2><h3 id="6-1-列式存储"><a href="#6-1-列式存储" class="headerlink" title="6.1 列式存储"></a>6.1 列式存储</h3><p><img src="/ByteDance-12/14.png" alt="行式存储"><br><img src="/ByteDance-12/15.png" alt="列式存储"><br><img src="/ByteDance-12/16.png"></p><p><strong>列存的优点</strong>：</p><ol><li><p>数据压缩</p><ul><li>数据压缩可以使读的数据量更少，在 IO 密集型计算中获得大的性能优势</li><li>相同类型压缩效率更高</li><li>排序之后压缩效率更高</li><li>可以针对不同类型使用不同的压缩算法</li><li>几种常见的压缩算法：LZ4、Run-length encoding、Delta encoding</li></ul></li><li><p>数据选择</p><ul><li>可以选择特定的列做计算而不是读所有列，对聚合计算友好</li></ul></li><li><p>延迟物化：</p><ul><li>尽可能推迟物化操作的发生（物化：将列数据转换为可以被计算或者输出的行数据或者内存数据结果的过程，物化后的数据通常可以用来做数据过滤，聚合计算，Join）</li><li>缓存友好</li><li>CPU &#x2F; 内存带宽友好</li><li>可以利用到执行计划和算子的优化，例如 filter</li><li>保留直接在压缩列做计算的机会</li></ul></li><li><p>向量化</p><ul><li>SIMD（single instruction multiple data）：对于现代多核 CPU，其都有能力用一条指令执行多条数据。用 SIMD 指令完成的代码设计和执行的逻辑就叫做向量化</li><li>数据格式要求：需要处理多个数据，因此数据需要是连续内存。需要明确数据类型</li><li>执行模型要求：数据需要按批读取，函数的调用需要明确数据类型</li></ul></li></ol><h3 id="6-2-ClickHouse-存储设计"><a href="#6-2-ClickHouse-存储设计" class="headerlink" title="6.2 ClickHouse 存储设计"></a>6.2 ClickHouse 存储设计</h3><p><img src="/ByteDance-12/17.png"></p><p>每个 column 都是一个文件，所有的 column 文件都在自己的 part 文件夹下</p><p>一个 part 有一个主键索引，每个 column 都有列索引</p><p><img src="/ByteDance-12/18.png"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 A Transactional Perspective on Execute-order-validate Blockchains</title>
    <link href="/Paper-Fabric-Sharp/"/>
    <url>/Paper-Fabric-Sharp/</url>
    
    <content type="html"><![CDATA[<p>Hyperledger Fabric 支持交易并行化执行，但却在序列化时可能会呈现许多无效交易。受到现代数据库乐观并行控制技术启发，我们提出了一种通过<strong>对交易重新排序来减少中止率</strong>的方法改进 execute-order-validate 架构。</p><span id="more"></span><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>新的 EOV 结构将交易的执行细节限制在背书节点，从而增强了机密性并使用了并发性。但这样的并发性是以中止不符合序列化的交易为代价的。</p><p><img src="/Paper-Fabric-Sharp/1.png" alt="Throughput"></p><p>解决这个问题有两个方向：一是改进 Fabric 的体系结构，以提高其可达到的吞吐量，例如 FastFabric；二是是抽象出交易生命周期，以降低中止率，例如 Fabric++。本文工作选取第二个方向，作为区块链“数据库化”的主要尝试。</p><p>我们分析了当前 Fabric 和 Fabric++ 的实现，发现两者都有强可串行性（Strong Serializability）。这种实现比原始 Fabric 协议规定的单拷贝可串行性（One-Copy Serializability 或 simply Serializability）更严格。这两个系统都采用了一种预防性方法，这种方法可能会过度中止仍然可以序列化的交易。我们的提案包括一种新的重新排序技术，该技术消除了由于分类账内冲突而导致的不必要的中止，并建立可序列化性保证。贡献如下：</p><ul><li><p>从理论上分析了具有 EOV 架构的区块链和具有乐观并发控制的数据库中事务处理的相似性。基于这种相似性分析了最先进的 EOV 区块链的交易行为，如 Fabric 和 Fabric++。</p></li><li><p>提出了一个新的定理来识别那些永远无法重新排序以实现序列化的交易。基于这一定理提出了有效的算法来早期过滤掉此类交易，并为重新排序后的剩余交易提供可序列化性保证。还讨论了对安全的影响。</p></li><li><p>在两个现有的区块链之上实现了我们提出的算法。首先使用 Hyperledger Fabric v1.3 作为基础，并将实现命名为 FabricSharp（简称 Fabric#）。其次使用 FastFabric，它在 Fabric 的所有优化中获得了最高的吞吐量，并将实现命名为 FastFabricSharp（简称 FastFabric#）。</p></li><li><p>通过将 FabricSharp 与 Fabric、Fabric++ 和其他两个数据库并发技术进行比较。实验结果表明，与其他系统相比，FabricSharp 的吞吐量高出 25% 以上；FastFabricSharp 相对于 FastFabric 的提升高达 66%。</p></li></ul><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2 BACKGROUND"></a>2 BACKGROUND</h2><h3 id="2-1-EOV-architecture-in-Fabric-and-Fabric"><a href="#2-1-EOV-architecture-in-Fabric-and-Fabric" class="headerlink" title="2.1 EOV architecture in Fabric and Fabric++"></a>2.1 EOV architecture in Fabric and Fabric++</h3><p><img src="/Paper-Fabric-Sharp/2.png" alt="(a) Workflow in Fabric. (b) Fabric++ Reordering Step"></p><p><strong>Fabric++ 在共识之后出块之前加入了对交易重新排序的步骤</strong></p><p><img src="/Paper-Fabric-Sharp/3.png" alt="The Transaction Summary"></p><p>红色代表 staled reads，蓝色代表 installed writes，N.A. 代表 not-allowed transactions。</p><h3 id="2-2-Optimistic-Concurrency-Control-in-Databases"><a href="#2-2-Optimistic-Concurrency-Control-in-Databases" class="headerlink" title="2.2 Optimistic Concurrency Control in Databases"></a>2.2 Optimistic Concurrency Control in Databases</h3><p>考虑到快照隔离会出现异常（如丢失更新和写入偏移），已多次尝试将快照隔离转换为可串行化级别。</p><h2 id="3-THEORETICAL-ANALYSIS"><a href="#3-THEORETICAL-ANALYSIS" class="headerlink" title="3 THEORETICAL ANALYSIS"></a>3 THEORETICAL ANALYSIS</h2><h3 id="3-1-Resemblance-in-Transaction-Processing"><a href="#3-1-Resemblance-in-Transaction-Processing" class="headerlink" title="3.1 Resemblance in Transaction Processing"></a>3.1 Resemblance in Transaction Processing</h3><ul><li><p><strong>Definition 3.1 (Blockchain snapshot)</strong>. 区块链快照是提交区块后区块链的状态。设 M 为提交块的序列号，则对应的快照表示为 M，并称其具有序列号（M+1, 0）。</p></li><li><p><strong>Definition 3.2 (Snapshot consistency)</strong>. 如果存在可以读取交易的所有记录的区块链快照 M，则交易是快照一致的。</p></li></ul><p>Fabric 中的交易满足快照一致性，因为 Fabric 使用锁来确保模拟是从最新状态开始进行的。Fabric++ 删除了锁，但提前中止了跨块读取的交易，所以也满足快照一致性。但是有些交易被过度中止了。</p><p><img src="/Paper-Fabric-Sharp/4.png" alt="Example of Transactions Reading across Blocks"></p><ul><li><p><strong>Example 3.3</strong>. 图 a 中，Txn1 读取快照 1 中的版本（1,1）的 A 和快照 2 中的版本（2,1）中的 B。这些版本与快照 2 中 A 和 B 的版本相同。因此，Txn1 是与块快照 2 一致的快照。相反，同样跨块读取的事务 Txn2 没有实现快照一致性，因为先前读取的 B 的值在块 2 中改变。</p></li><li><p><strong>Proposition 3.4</strong>. 存在跨块读取的快照一致性交易，其块快照由其最后一次读取操作决定。</p></li><li><p><strong>Proof</strong>. 图 a 中的 Txn1 是一个示例。我们在 Example 3.3 中描述了 Txn1 在块 1 和 2 之间读取，并且它仍然与块快照 2 一致。</p></li><li><p><strong>Definition 3.5 (Start timestamp)</strong>. 交易 Txn 的开始时间戳，由 StartTs(Txn) 表示，是其读取快照的序列号。</p></li><li><p><strong>Definition 3.6 (End timestamp)</strong>. 交易 Txn 的结束时间戳，由 EndTs(Txn) 表示，是其在块中的序列号，由共识确定。</p></li></ul><p>如 a 中交易 Txn1 具有 StartTs(Txn1) ＝ (3,0) 和 EndTs(Txn1) ＝ (3,1)，因为它最后从块 2 读取并占据块 3 中的第一个位置。为了简洁起见，我们在之后的叙述中简化为图 b 的样式。交易的开始或结束时间戳的序列号是按字典顺序排列的，例如 (2,1) &lt; (2,2) &#x3D; (2,2) &lt; (3,0)。</p><ul><li><p><strong>Definition 3.7 (Concurrent transactions)</strong>. 如果 Txn1 和 Txn2 的执行重叠，则称它们是并发的。</p></li><li><p><strong>Proposition 3.8</strong>. 同一区块中的每对交易都是并发的。</p></li><li><p><strong>Proof</strong>. 假设两个交易 Txn1 和 Txn2 分别在位置 p 和 q 处提交到同一块 M 中，其中 p ＜ q。由于 Txn2 可以从中读取的最新块是 M−1，因此我们得出：StartTs(Txn2) ≤ (M,0) &lt; EndTs(Txn1) &#x3D; (M,p) &lt; EndTs(Txn2) &#x3D; (M,q)。因此，Txn1 和 Txn2 是并发的。</p></li><li><p><strong>Proposition 3.9</strong>. 存在不属于同一区块的并发交易。</p></li></ul><p><img src="/Paper-Fabric-Sharp/5.png" alt="Txn1 and Txn2 are in different blocks, but they are still concurrent."></p><ul><li><strong>Proof</strong>. 如图，其中 Txn1 和 Txn2 分别属于块 M 和 M+1，Txn2 从早于 M 的块中读取， StartTs(Txn2) ≤ (M,0) &lt; EndTs(Txn1) &#x3D; (M,1) &lt; EndTs(Txn2) &#x3D; (M+1,1)。因此 Txn1 和 Txn2 是并发的。</li></ul><p>由上可见，并发不仅发生在同一块内的交易之间。Fabric++ 没有考虑跨块交易之间的依赖关系。因此，它的重新排序效果是有限的。</p><h3 id="3-2-Serializability-Analysis"><a href="#3-2-Serializability-Analysis" class="headerlink" title="3.2 Serializability Analysis"></a>3.2 Serializability Analysis</h3><p><img src="/Paper-Fabric-Sharp/6.png" alt="Six Canonical Dependencies"></p><p>如图是快照交易依赖（或冲突）的六种场景。根据冲突可串行化定理，可串行化事务调度的效果等效于<strong>任何</strong>按照依赖顺序的串行化执行历史。请注意，可序列化事务调度的依赖关系图必须是无环的。</p><ul><li><p><strong>Definition 3.10 (Strong Serializability)</strong>. 如果交易 schedule 的效果等效于序列化的历史记录，则交易 schedule 是强可序列化的。该历史记录符合交易的提交顺序，该顺序由交易的结束时间戳确定。</p></li><li><p><strong>Theorem 3.11</strong>. 没有 anti-rw 交易的 schedule 实现了强可序列化。</p></li><li><p><strong>Proof</strong>. 首先证明任何没有 anti-rw 交易的 schedule 实现了可序列化：通过反证法，假设一个 schedule 不能实现可序列化，那么其中必然有一个交易子集具有环形依赖，环里最后提交的交易由 Txn 表示。那么 Txn 必须具有 anti-rw 依赖关系，因为 anti-rw 是唯一从后面的交易指向前面的依赖关系，这与假设不符。因此 schedule 实现了可序列化。下一步证明实现了强可序列化：由于其余五个依赖的顺序与其提交顺序一致，因此遵循提交顺序的序列化历史也遵循依赖顺序。根据冲突可串行化定理，这种序列化的交易历史具有可序列化 schedule 的等效效果。因此，schedule 是强序列化的。</p></li></ul><p>我们注意到 Fabric&#x2F;Fabric++ 不允许在两个交易之间的 anti-rw，因为后一个交易将读取前一个更新的旧版本，因此必须中止。可见 Fabric&#x2F;Fabric++ 满足强可序列化。</p><h3 id="3-3-Reorderability-Analysis"><a href="#3-3-Reorderability-Analysis" class="headerlink" title="3.3 Reorderability Analysis"></a>3.3 Reorderability Analysis</h3><p>在可序列化而非强可序列化下，我们分析了 EOV 区块链中交易的可重新排序性。我们通过改变待定交易的提交顺序来确定可序列化的 schedule。</p><ul><li><p><strong>Lemma 3.12</strong>. 在区块链中，重新排序只能发生在并发交易之间。</p></li><li><p><strong>Proof</strong>. 假设交易重新排序发生在两个非并发交易之间。由于 Proposition 3.8，这些交易在不同的区块中进行。改变它们的顺序意味着更改先前提交的块，这在区块链中是不可能的。</p></li><li><p><strong>Lemma 3.13</strong>. 交易在重新排序后不会改变其相对于其他交易的并发关系。</p></li><li><p><strong>Proof</strong>. 易证。</p></li></ul><p>上面的 Lemma 3.12 确保了重新排序不会影响非并发交易及其依赖关系。Lemma 3.13 确保非并发交易不会被重新排序引入。因此，我们将分析限制在并发依赖关系上。我们使用下面的两个引理来描述并发交易的依赖顺序。</p><ul><li><strong>Lemma 3.14</strong>. 如果两个交易 Txn1 和 Txn2 表现出 c-rw 或 anti-rw 依赖性，则改变提交顺序不会影响它们的依赖顺序。</li></ul><p><img src="/Paper-Fabric-Sharp/7.png" alt="Switch Commit Order"></p><ul><li><p><strong>Proof</strong>. 当 Txn1 和 Txn2 表现出 c-rw（或 anti-rw）依赖性时，如果我们切换它们的提交顺序，它们将表现出 anti-rw（或 c-rw）依赖性。因此，在这两种情况下，它们的依赖顺序保持相同，即 Txn1 读取一个键值，该键值稍后将由 Txn2 写入。</p></li><li><p><strong>Lemma 3.15</strong>. 如果两个交易 Txn1 和 Txn2 表现出 c-ww 依赖性，切换它们的提交顺序将翻转它们的依赖顺序。</p></li><li><p><strong>Proof</strong>. 当 Txn1 和 Txn2 表现出 c-ww 依赖性时，Txn1 的写入将被 Txn2 覆盖。如果它们的提交顺序被切换，Txn2 的写入将被 Txn1 覆盖。因此，Txn1 和 Txn2 的依赖顺序被翻转。</p></li><li><p><strong>Theorem 3.16</strong>. 如果存在一个没有 c-ww 依赖关系的环，则 schedule 无法重新排序为可序列化。</p></li></ul><p><img src="/Paper-Fabric-Sharp/8.png" alt="Transaction Schedule Reorderability"></p><ul><li><strong>Proof</strong>. 我们将循环中的依赖分为两类。第一类是在依赖中至少有一个已提交的交易。由于区块链的不变性，重新排序不会影响这些依赖关系，因为两个交易的相对提交顺序是固定的。第二类包括一对待定交易之间的所有依赖关系。对于每个依赖项，其对应的交易必须是并发的，否则前一个交易已经被提交。由于交易是并发的，且没有 c-ww，因此顺序只能在具有 c-rw 或 anti-rw 的冲突交易之间改变。尽管被重新排序，它们的依赖顺序仍然不变（Lemma 3.14）。如图 a，循环 schedule 仍然是不可序列化的。</li></ul><p>然而，如果在待定的交易之间存在一个具有 c-ww 依赖的环，则 schedule 可以被重新排序为可序列化。Lemma 3.15 说明了它们的依赖顺序可以翻转。图 b 中由 Txn1、Txn2 和 Txn3 形成的循环调度通过交换 Txn2 和 Txn3 的提交顺序而变得可串行化。</p><h3 id="3-4-Fine-grained-Concurrency-Control"><a href="#3-4-Fine-grained-Concurrency-Control" class="headerlink" title="3.4 Fine-grained Concurrency Control"></a>3.4 Fine-grained Concurrency Control</h3><p>Theorem 3.16 指出，在待定的交易中没有 c-ww 的循环 schedule，即使重新排序也无法序列化。基于此，我们为 EOV 区块链中的细粒度并发控制制定了以下三个步骤：</p><ol><li>对于一个新交易，首先考虑所有待定交易（包括新交易）中除了 c-ww 的所有依赖项，如果存在依赖循环，将直接丢弃新交易。</li><li>在出块时，我们按照计算的依赖关系检索交易顺序。</li><li>根据检索 schedule 恢复对交易的 c-ww 依赖关系。</li></ol><p>c-ww 依赖关系恢复仍然是必要的，因为未来不可序列化的交易可能会遇到一个包含已提交交易的 c-ww 依赖关系的循环。但它们的提交顺序和依赖顺序都已经固定。因此，依赖关系图在恢复之后仍然是非循环的。</p><p><img src="/Paper-Fabric-Sharp/9.png" alt="Algorithm 1"><br><img src="/Paper-Fabric-Sharp/10.png" alt="Algorithm 2"><br><img src="/Paper-Fabric-Sharp/11.png" alt="Algorithm 3"></p><p>其中算法 3 中的<strong>拓扑排序</strong>（topological sort）始终有解，因为 G 由算法 2 保证无环。</p><p>与 Fabric++ 中的重新排序算法相比，我们的算法更细粒度，因为不可序列化的交易在排序前被中止，并且剩余的交易保证是可序列化的而不会被中止。我们的重新排序不再局限于一个块的范围。另一个显著的区别是，在模拟开始时确定块快照，而 Fabric 和 Fabric++ 则根据上次读取操作来确定。为了获得更多的并行性，我们允许在模拟执行过程中进行块提交，但当模拟过程中提交的交易更新了以前读取的记录时，这可能会引入过时的快照。</p><h3 id="3-5-Security-Analysis"><a href="#3-5-Security-Analysis" class="headerlink" title="3.5 Security Analysis"></a>3.5 Security Analysis</h3><p>我们的重排算法是排序过程的一部分，需要在每个诚实的排序节点复制，以在共识建立交易顺序后形成账本。假设原始共识在其安全模型下实现了安全性和有效性，现在讨论在重新排序后这两个性质是否保持不变。</p><ul><li><p><strong>Safety</strong>. 在最初的 Fabric 设计中，有四个安全属性：agreement，hash chain integrity，no skipping 和 no creation。这要求诚实的排序节点在账本中连续交付一致的数据块，我们的方法保留了哈希链的完整性，并且没有跳过，因为不改变块形成过程。不引入新的交易，所以也没有创建。达成了一致，因为在每个排序节点上完全复制了重新排序，只要诚实的排序节点从一致的交易流中单独执行重新排序，就可以产生相同的账本。</p></li><li><p><strong>Liveness</strong>. Fabric 根据 validity 属性定义了活性，该属性要求所有广播的交易都包含在账本中。由于我们的算法中止的交易被排除在账本之外，可能会破坏这种活性。然而，我们建议采取以下方法来防止滥用。在共识协议中，交易顺序是由领导者节点临时提出的。当这个顺序被其他节点接受时，它就成为了我们重新排序方法的输入。顺序由领导者控制，他可能利用公开的重新排序算法以恶意推迟某些交易。我们可以隐藏交易细节（如访问记录）来解决这个问题，比如客户端只给排序者发送交易哈希。在交易哈希的顺序确定后，再把交易细节公开给排序者来重新排序。</p></li></ul><h2 id="4-IMPLEMENTATION"><a href="#4-IMPLEMENTATION" class="headerlink" title="4 IMPLEMENTATION"></a>4 IMPLEMENTATION</h2><h3 id="4-1-Overview"><a href="#4-1-Overview" class="headerlink" title="4.1 Overview"></a>4.1 Overview</h3><p><img src="/Paper-Fabric-Sharp/12.png" alt="Overview"></p><h3 id="4-2-Snapshot-Read"><a href="#4-2-Snapshot-Read" class="headerlink" title="4.2 Snapshot Read"></a>4.2 Snapshot Read</h3><p>算法 1 中我们依靠存储快照（storage snapshot）机制来确保每个合约调用都是在一致的状态下进行模拟的。在每一个区块被提交的时候，我们都会创建一个存储快照并将其关联到区块号。每一笔交易在模拟执行之前都要获取最新的区块号，没有任何模拟的陈旧快照会被定期清理。这种设计允许在执行阶段的合约模拟和验证阶段的块提交之间有更多的并行性。原生 Fabric 使用读写锁来协调这两个阶段。</p><h3 id="4-3-Dependency-Resolution"><a href="#4-3-Dependency-Resolution" class="headerlink" title="4.3 Dependency Resolution"></a>4.3 Dependency Resolution</h3><p>为了计算算法 2 中的依赖图，我们在排序节点中引入了两个多版本存储，以识别已提交的交易。这些存储器在 LevelDB 中实现，分别表示为 CommittedWriteTxns（CW）和 CommittedReadTxns（CR）。CW 中的键由记录键和更新值的交易的提交序列组成：例如 Txn1 的提交序号是 (3,2) 写入 A 的值，CW 会记录 {A_3_2:Txn1}。CR 中的键由记录键和读取最新值的交易的提交序列组成：例如 {A_4_1:Txn7} 表示 Txn7(4,1) 读取键 A 的最新值。</p><p>CW.Before(key,seq) 返回序列号小于 seq 且更新 key 的最后一笔已提交交易。<br>CW.Last(key) 返回最后一个更新 key 的已提交交易。<br>CW[key][seq:] 返回所有在 seq 之后更新 key 的已提交交易。</p><p>我们在内存中维护两个索引，PendingWriteTxns（PW）和 PendingReadTxns（PR），分别存储待定交易的写入和读取集。如果一个新交易 txn 开始于 startTS，读取的键为 R，写入的键为 W，那么 txn 的所有依赖计算如下：</p><p><img src="/Paper-Fabric-Sharp/13.png" alt="Dependencies Computing"></p><p>请注意，我们忽略待定交易之间的 ww 依赖关系，并且不区分 ww 和 rw 是否并发。这是因为非并发交易可能是一个环的一部分。然后将 txn 的 predecessor 计算为 ww(txn) ∪ n-wr(txn) ∪ rw(txn)，将 successor 计算为 anti-rw(txn)。</p><h3 id="4-4-Cycle-Detection"><a href="#4-4-Cycle-Detection" class="headerlink" title="4.4 Cycle Detection"></a>4.4 Cycle Detection</h3><p>本节讨论如何使用依赖图 G 来检测环并实现可序列化。有两个设计选择：一方面我们可以只维护每个交易的当前链接信息，然后遍历图来检测环；另一方面可以维护每对交易之间的所有可达性信息。后者将开销从计算时间转移到空间消耗。我们通过维护交易的直接 successors (txn.succ) ，并用布隆过滤器表示所有可以到达 txn 的交易（txn.anti_reachable），来实现最佳设计。环检测可以直接通过对由 txn 的 predecessor 和 successor 组成的每对 (p,s) 测试 p.anti_reachable(s)。</p><p><img src="/Paper-Fabric-Sharp/14.png" alt="Algorithm 4"></p><p>我们使用布隆过滤器是因为它们具有内存效率，并且可以执行快速并集。然而，已知布隆过滤器会报告 false positives。如果过滤器向 txn 报告了一对相邻交易的 false positives，我们会预防性地中止 txn。如果报告所有交易对都是 negative，那么 txn 不属于 G 中的任何环。</p><p>算法 4 的一个问题是不断增长的 anti_reachable filter，这会导致单个布隆过滤器的 false positive rate 不断增长。我们使用两个布隆滤波器。一个布隆过滤器捕获在块 M 之后提交的交易，另一布隆过滤器捕捉在块 N 之后的交易。假设 C 是包含 G 中已提交交易最早的区块，我们保持 M &lt; C &lt; N，并使用第一个布隆过滤器检测可达性。一旦 C 变为 M &lt; N &lt; C，第一个布隆过滤器被清空，并开始收集当前区块的交易。我们使用第二个布隆过滤器检测可达性。这样限制了每个过滤器中只包含一定范围区块里的交易，使得 false positive rate 可以接受。为了安全起见，诚实的排序者必须使用相同的 M 和 N。</p><h3 id="4-5-Dependency-Restoration"><a href="#4-5-Dependency-Restoration" class="headerlink" title="4.5 Dependency Restoration"></a>4.5 Dependency Restoration</h3><p>本节展示将 ww 依赖按照提交顺序（待定交易 P 根据 G 的可达性的拓扑排序）加入依赖图 G。</p><p><img src="/Paper-Fabric-Sharp/15.png" alt="Algorithm 5"></p><p>算法 5 概述了恢复 ww 依赖关系的主要步骤。下图中的示例进一步解释了该算法。待定交易（用蓝色虚线边框标记）、提交序列、新的 ww 依赖关系（用蓝色实线标记）和拓扑排序的迭代顺序的依赖关系图的示例。不考虑 Txn0 和 Txn3 之间的 ww 依赖性（用蓝色虚线标记），因为它是隐式的。红色的 Txn1 由于过时而需要修剪。交易年龄以斜体表示。</p><p><img src="/Paper-Fabric-Sharp/16.png" alt="Example"></p><p>对于待定交易（PW）将要更新的每个 key，对其相关交易进行拓扑排序，并在可达性过滤器中选择尚未连接的第一对。在这样的对中，可以从第一个交易的所有 predecessors 到达第二个交易。如果一对中的交易已经在可达性过滤器中连接，这使得恢复是多余的：如图中 Txn0 和 Txn3。对于尚未连接的交易，需要更新它们的 successors。我们将交易放入 (head_txns) 集合中并根据拓扑排序更新 successors。这样可以在迭代中避免重复更新：例如 Txn8 在更新 A 和 B 时都可达，但使用这个算法可达性信息只会更新一次。</p><h3 id="4-6-Dependency-Graph-Pruning"><a href="#4-6-Dependency-Graph-Pruning" class="headerlink" title="4.6 Dependency Graph Pruning"></a>4.6 Dependency Graph Pruning</h3><p>由于图 G 增长速度会很快，我们根据以下原则剪枝：(i) 根据非常旧的快照进行模拟；(ii) 无法影响待定交易。</p><p>对于第一种情况，我们引入一个参数 max_span 来限制交易的区块跨度（如果对块 M 模拟并在块 M+1 中提交，则其块跨度为 1）。如果下一个区块号是 M，我们计算 snapshot threshold：H &#x3D; M − max_span。任何按照 H 或更早区块模拟的交易将会被中止。对于第二种情况，我们将交易 txn 的年龄定义为在 G 中的 txn 可到达交易的最后提交块的序列号。当 snapshot threshold 大于 txn 的年龄时，未来的交易不能与任何可以达到 txn 的交易并发。这种情况下 anti-rw 依赖就不会产生，并且这排除了任何包含 txn 的不可序列化的调度。因此，txn 可以安全地从 G 中剪枝。我们通过将 G 中的所有交易安排到按年龄加权的优先级队列中来修剪。对于要在块 M 中提交的新交易，我们在算法 4（第 7 行）中的遍历过程中将其可到达的交易的年龄增加到 M。为了安全起见，所有排序节点必须使用相同的 max_span 值。</p><h2 id="5-EXPERIMENTS"><a href="#5-EXPERIMENTS" class="headerlink" title="5 EXPERIMENTS"></a>5 EXPERIMENTS</h2><h3 id="5-1-Systems-and-Setup"><a href="#5-1-Systems-and-Setup" class="headerlink" title="5.1 Systems and Setup"></a>5.1 Systems and Setup</h3><p>基于 Hyperledger Fabric 1.3 改进并命名为 FabricSharp。与原生 Fabric 和两个采用 OCC 技术的系统比较。基于 FastFabric 改进并命名为 FastFabricSharp。每组实验采用两个排序节点，三个 Kafka 节点和四个对等节点。</p><h3 id="5-2-Workloads-and-Benchmark-Driver"><a href="#5-2-Workloads-and-Benchmark-Driver" class="headerlink" title="5.2 Workloads and Benchmark Driver"></a>5.2 Workloads and Benchmark Driver</h3><p>我们采用与 Fabric++ 同样的工作负载—— Smallbank benchmark。一笔交易分别读取和写入 1 万个账户中的 4 个银行账户。我们将其中 1% 设置为热门账户。每次读取都有一定的概率访问热门帐户，由 Read hot ratio 参数控制。类似地，对热门帐户的写入由 Write hot ratio 控制。我们引入了另外两个工作负载参数，即 Client Delay 和 Read Interval。前者控制客户端在从对等节点接收到执行结果后向排序节点广播的延迟，模拟客户端的网络传输延迟。后者通过控制连续读取之间的间隔来模拟计算量大的交易。</p><p><img src="/Paper-Fabric-Sharp/17.png" alt="Experiment Parameters"></p><p>参数设置如图，画横线的是默认值。我们固定 max_span 为 10，请求速率 为 700 tps，这是因为 Fabric 在我们的设置中可以维持约 700 tps 的最大原始吞吐量。除非有特别说明，否则所有的吞吐量都指<strong>有效吞吐量</strong>，即通过序列化检验并持久化状态的交易。</p><h3 id="5-3-The-Performance-of-FabricSharp"><a href="#5-3-The-Performance-of-FabricSharp" class="headerlink" title="5.3 The Performance of FabricSharp"></a>5.3 The Performance of FabricSharp</h3><ul><li><strong>Block Size</strong>.</li></ul><p><img src="/Paper-Fabric-Sharp/18.png" alt="Performance under varying block size"></p><ul><li><strong>Write Hot Ratio</strong>.</li></ul><p><img src="/Paper-Fabric-Sharp/19.png" alt="Throughput and reordering latency under varying write hot ratio"></p><ul><li><strong>Read Hot Ratio</strong>.</li></ul><p><img src="/Paper-Fabric-Sharp/20.png" alt="Throughput and transaction processing latency under varying read hot ratio"></p><ul><li><strong>Client Delay</strong>.</li></ul><p><img src="/Paper-Fabric-Sharp/21.png" alt="Throughput of all systems (left) and statistics of FabricSharp (right) under varying client delay"></p><ul><li><strong>Read Interval</strong>.</li></ul><p><img src="/Paper-Fabric-Sharp/22.png" alt="Throughput (left) and abort rate (right) under varying read interval"></p><h3 id="5-4-The-Performance-of-FastFabricSharp"><a href="#5-4-The-Performance-of-FastFabricSharp" class="headerlink" title="5.4 The Performance of FastFabricSharp"></a>5.4 The Performance of FastFabricSharp</h3><p><img src="/Paper-Fabric-Sharp/23.png" alt="Effective Throughput"></p><h2 id="6-RELATED-WORK"><a href="#6-RELATED-WORK" class="headerlink" title="6 RELATED WORK"></a>6 RELATED WORK</h2><p>略</p><h2 id="7-CONCLUSIONS"><a href="#7-CONCLUSIONS" class="headerlink" title="7 CONCLUSIONS"></a>7 CONCLUSIONS</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Blurring the Lines between Blockchains and Database Systems: the Case of Hyperledger Fabric</title>
    <link href="/Paper-Fabric-Plus/"/>
    <url>/Paper-Fabric-Plus/</url>
    
    <content type="html"><![CDATA[<p>区块链系统面临的许多挑战都是基本的交易管理问题，这在很大程度上与传统数据库系统一样。这些相似之处对于模糊了区块链系统和经典数据库系统之间界限的系统来说尤其明显，比如 Hyperledger Fabric。这就引出了两个问题：（1）Fabric 这样的系统和经典的分布式数据库之间存在哪些概念上的相似性和差异？（2）是否可以通过采用数据库技术提高 Fabric 的性能并进一步模糊这两种类型系统之间的界限？为了解决这些问题，我们首先从数据库研究的角度探讨 Fabric，然后通过将数据库概念转换到 Fabric 来解决这些问题，即事务重新排序和早期事务中止。我们的改进版本 Fabric++ 将成功交易的吞吐量提高了 12 倍，同时将平均延迟降低到几乎一半。</p><span id="more"></span><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>经典的分布式数据库系统需要一组可信的参与者，但区块链系统能够处理一定数量的恶意节点。这个特性使得区块链系统可以应用于彼此并不完全信任的个体之间。在拜占庭容错方面，区块链系统比分布式数据库系统具有明显的优势，但就交易处理的其他方面而言，经典数据库系统都领先区块链系统几十年。</p><h3 id="1-1-Catching-up"><a href="#1-1-Catching-up" class="headerlink" title="1.1 Catching up"></a>1.1 Catching up</h3><p>Hyperledger Fabric 使用 simulate-order-validate-commit 模型，该模型在很大程度上受到数据库系统中<strong>乐观并发控制</strong>机制的影响：先并行模拟执行交易，排序后进行冲突检测，最后提交那些不冲突的交易。这个模型的优点很明显：并行执行交易，并因此具有可扩展性。</p><p>但是 Fabric 任然存在某种高度限制并发带来的增益的问题。这些问题可以在两个简单的实验中识别出来。</p><p><img src="/Paper-Fabric-Plus/1.png" alt="Fabric"></p><p>在第一个实验中，我们提交了有意义的资产转移交易流，并检测吞吐量，分为中止和成功交易。这个实验揭示了 Fabric 的一个严重问题：大量交易最终被中止。所有中止的原因都是序列化冲突，这是并发执行的负面影响。</p><p>如果我们想增加成功交易的数量，基本上有两种选择：<br>    （a）增加系统的整体吞吐量；<br>    （b）将原本会被 Fabric 中止的交易变为成功的交易。</p><p>第二个实验看可以看出（a）在 Fabric 中几乎不适用。我们提交了没有任何逻辑的空白交易。空白交易和有意义交易的总吞吐量基本相等。这表明系统的总体吞吐量并不是由交易处理的核心组件决定的，而是取决其他辅助因素：<strong>加密计算</strong>和<strong>网络开销</strong>。</p><h3 id="1-2-Fabric"><a href="#1-2-Fabric" class="headerlink" title="1.2 Fabric++"></a>1.2 Fabric++</h3><p>所以选项（b）是关键，我们将通过一个众所周知的数据库技术来实现这一点：事务重新排序（transaction reordering）。</p><ol><li>首先从概念的角度梳理 Hyperledger Fabric 1.2 版本的交易流程。</li><li>仔细查阅并发控制领域的相关工作，并讨论哪些技术与 Fabric 相关。</li><li>分析 Fabric 中交易流的基础上，我们详细讨论了它的弱点，并描述了如何利用数据库技术来克服这些弱点。</li><li>改进交易排序。系统默认将模拟后的交易任意排序，这导致一些不必要的序列化冲突。我们引入一种事务<strong>重新排序机制</strong>（transaction reordering mechanism）来改善这个问题。</li><li>提前中止交易。Fabric 在最后提交前才检测交易有效性，这使得系统完整的处理了很多本没有机会提交的交易。我们引入<strong>早期中止</strong>（early abort）的概念到流水线的各个阶段。这些改动显著扩展了 Fabric，我们将其称为 Fabric++。</li><li>在 Smallbank 基准测试和自定义工作负载下对 Fabric++ 的优化进行了实验评估。</li></ol><h2 id="2-HYPERLEDGER-FABRIC"><a href="#2-HYPERLEDGER-FABRIC" class="headerlink" title="2 HYPERLEDGER FABRIC"></a>2 HYPERLEDGER FABRIC</h2><h3 id="2-1-Architecture"><a href="#2-1-Architecture" class="headerlink" title="2.1 Architecture"></a>2.1 Architecture</h3><p>Fabric 是一个许可区块链系统，这意味着网络的所有 peers 在任何时间都是已知的，peers 被分到 organization 中，在同一个组织中的 peers 都相互信任。每个 peer 都运行 Fabric 的本地实例。此实例包括分类账（ledger）的副本，其中包括有效事务和无效事务。每个 peer 还以状态数据库的形式包含当前状态（current state），该状态数据库表示分类账中所有有效交易应用到初始状态后的状态。此外还有一个名为 ordering service 的独立实例。</p><h3 id="2-2-High-level-Workflow"><a href="#2-2-High-level-Workflow" class="headerlink" title="2.2 High-level Workflow"></a>2.2 High-level Workflow</h3><p><img src="/Paper-Fabric-Plus/2.png" alt="High-level Workflow of Fabric"></p><h4 id="2-2-1-Simulation-Phase"><a href="#2-2-1-Simulation-Phase" class="headerlink" title="2.2.1 Simulation Phase."></a>2.2.1 Simulation Phase.</h4><p>背书节点根据本地当前状态并行模拟执行交易，结果并不用于更新当前状态。生成并返回读写集给客户端。</p><h4 id="2-2-2-Ordering-Phase"><a href="#2-2-2-Ordering-Phase" class="headerlink" title="2.2.2 Ordering Phase."></a>2.2.2 Ordering Phase.</h4><p>按照交易到达的顺序排序。</p><h4 id="2-2-3-Validation-Phase"><a href="#2-2-3-Validation-Phase" class="headerlink" title="2.2.3 Validation Phase."></a>2.2.3 Validation Phase.</h4><p>先检查背书签名，再检查序列化冲突。</p><h4 id="2-2-4-Commit-Phase"><a href="#2-2-4-Commit-Phase" class="headerlink" title="2.2.4 Commit Phase."></a>2.2.4 Commit Phase.</h4><p>提交区块到本地帐本，并将有效交易的写集应用于当前状态。</p><h2 id="3-RELATED-WORK"><a href="#3-RELATED-WORK" class="headerlink" title="3 RELATED WORK"></a>3 RELATED WORK</h2><p>尽管 Fabric 是一个并行事务处理系统，但它在四个方面与并行数据库系统不同：</p><ol><li><p>Fabric 以块的粒度提交，而不是以单个交易的粒度提交。</p></li><li><p>Fabric 是一个分布式系统，其状态在网络上完全复制，交易在所有节点上运行。与此相反，并行数据库系统通常要么本地安装在单个节点上，要么在网络上对其状态进行分区，使得事务在网络的子集上操作。</p></li><li><p>Fabric 在多个节点上并行模拟单个交易以建立信任，对交易进行模拟的状态可能会因为跨节点而发生变化。在并行数据库系统中，情况要简单得多：一个事务只针对系统中存在的唯一状态执行一次。</p></li><li><p>Fabric 的性能在很大程度上取决于加密签名计算、网络通信和信任验证。相比之下，并行数据库系统的性能在很大程度上受到底层组件的影响，例如用于并发控制的锁定机制。</p></li></ol><h3 id="3-1-Class-1-Transaction-Throughput"><a href="#3-1-Class-1-Transaction-Throughput" class="headerlink" title="3.1 Class 1: Transaction Throughput"></a>3.1 Class 1: Transaction Throughput</h3><p>此节列举许多在数据库中增加吞吐量的技术，但是由第一章的实验可知并不适用于 Fabric。</p><h3 id="3-2-Class-2-Transaction-Abort-amp-Success"><a href="#3-2-Class-2-Transaction-Abort-amp-Success" class="headerlink" title="3.2 Class 2: Transaction Abort &amp; Success"></a>3.2 Class 2: Transaction Abort &amp; Success</h3><p>此节列举了一些将中止交易转化为成功交易的研究，并认为这是 Fabric 性能提升的关键。</p><h2 id="4-BLURRED-LINES-FABRIC-VS-DISTRIBUTED-DATABASE-SYSTEMS"><a href="#4-BLURRED-LINES-FABRIC-VS-DISTRIBUTED-DATABASE-SYSTEMS" class="headerlink" title="4 BLURRED LINES: FABRIC VS DISTRIBUTED DATABASE SYSTEMS"></a>4 BLURRED LINES: FABRIC VS DISTRIBUTED DATABASE SYSTEMS</h2><h3 id="4-1-The-Importance-of-Transaction-Order"><a href="#4-1-The-Importance-of-Transaction-Order" class="headerlink" title="4.1 The Importance of Transaction Order"></a>4.1 The Importance of Transaction Order</h3><p>排序机制存在于任何具有事务语义的分布式数据库系统中，因此是将数据库技术转变为 Fabric 技术一个很好的候选者。由于 Fabric 的排序在交易执行之后，所以会影响产生冲突交易的数量。</p><p>最简单的排序方式是任意排序，比如按照交易到达的时间建立顺序，Fabric 就是采用的这种方式。如下图所示这种策略可能是有问题的：</p><p><img src="/Paper-Fabric-Plus/3.png" alt="T1 ⇒ T2 ⇒ T3 ⇒ T4"></p><p>T1 将 k1 从版本 v1 更新到版本 v2。由于 T2、T3 和 T4 在其模拟过程中每个都读取版本 v1 中的 k1，因此它们将在验证阶段被标记为无效，客户必须重新提交相应的交易提案，从而进行新一轮的模拟、排序和验证。</p><p>然而这四个交易其实存在无冲突排序，可以使它们都被标记为有效交易：</p><p><img src="/Paper-Fabric-Plus/4.png" alt="T4 ⇒ T2 ⇒ T3 ⇒ T1"></p><h3 id="4-2-On-the-Lifetime-of-Transactions"><a href="#4-2-On-the-Lifetime-of-Transactions" class="headerlink" title="4.2 On the Lifetime of Transactions"></a>4.2 On the Lifetime of Transactions</h3><p>根据 Fabric 验证标准，通过系统的每个交易都被分类为有效或无效，这一步发生在最终提交之前。这种延迟中止（late abort）形式的一个严重缺点是，在早期阶段已经违反验证标准的交易仍在处理并传递给所有节点。这不仅让整个系统做了许多无用功，还会<strong>延迟向客户端发出交易无效通知的时间</strong>。</p><h4 id="4-2-1-Violation-in-the-simulation-phase-cross-block-conflicts"><a href="#4-2-1-Violation-in-the-simulation-phase-cross-block-conflicts" class="headerlink" title="4.2.1 Violation in the simulation phase (cross-block conflicts)"></a>4.2.1 Violation in the simulation phase (cross-block conflicts)</h4><p>来看看 Fabric 是如何处理模拟执行阶段发生的冲突交易的：假设有四个交易 T1、T2、T3 和 T4，它们当前处于排序阶段并最终形成大小为 4 的块发给所有节点验证。在节点 P 内开始该块的验证之前，交易提议 T5 的智能合约在 P 中开始模拟。为此，它获取整个当前状态的 read lock。当 T5 模拟执行时，块必须等待验证，因为它必须获取当前状态的独占 write lock。</p><p>这种情况下的问题是：如果 T1、T2、T3 或 T4 将写入由 T5 读取的键值，那么 T5 对过时的数据进行模拟。因此在读取的那一刻，交易就已经变得无效。可是 Fabric 在 T5 的验证阶段之前没有检测到这种过时的读取。因此 T5 将继续其模拟并经历排序阶段，只是最终被无效。</p><h4 id="4-2-2-Violation-in-the-ordering-phase-within-block-conflicts"><a href="#4-2-2-Violation-in-the-ordering-phase-within-block-conflicts" class="headerlink" title="4.2.2 Violation in the ordering phase (within-block conflicts)"></a>4.2.2 Violation in the ordering phase (within-block conflicts)</h4><p>冲突除了发生在不同区块，也有可能发生在同一个区块内部：如 4.1 节所示，这种情况出现在排序之后。尽管块内 3&#x2F;4 的交易实际上是无效的，也将传递给网络的所有节点进行验证。</p><p>尽早“清理”流水线的概念在数据库中被称为 early abort，它减少了网络流量并节省了计算资源。</p><h2 id="5-FABRIC"><a href="#5-FABRIC" class="headerlink" title="5 FABRIC++"></a>5 FABRIC++</h2><h3 id="5-1-Transaction-Reordering"><a href="#5-1-Transaction-Reordering" class="headerlink" title="5.1 Transaction Reordering"></a>5.1 Transaction Reordering</h3><p>对一组交易 S 重新排序时遇到的挑战：首先我们需要确定 S 中的哪些交易是相互冲突的。由于 S 中的交易在完全隔离的环境下模拟执行，这些冲突仍有可能会发生。因为 S 的提交发生在之后的阶段，它们没有机会看到彼此潜在的冲突修改。</p><p>假设 Ti 写入由 Tj 读取的键值（记为 Ti ↛  Tj），那么 Ti 必须排在 Tj 之后（记为 Tj ⇒ Ti），否则 Tj 将无效。如果发生冲突循环，简单的重新排序无法解决问题。比如 Ti ↛  Tj ↛  Tk ↛  Ti，这种情况下只有先删除某笔交易来形成一个无环子集。</p><p><strong>五个步骤</strong>：</p><ol><li>建立 S 的所有交易的冲突图</li><li>识别冲突图中的所有环</li><li>识别每一笔交易出现在哪个环中</li><li>依次中止出现在最多环中的交易，直到解决所有的环</li><li>使用剩余的交易建立一个可串行化调度</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reordering</span><span class="hljs-params">(Transaction[] S)</span></span> &#123;<br>    <span class="hljs-comment">// Step 1: For each transaction in S buildConflictGraph()</span><br>    <span class="hljs-comment">// inspects the read and write set and builds a conflict graph.</span><br>    Graph cg = buildConflictGraph(S)<br><br>    <span class="hljs-comment">// Step 2: Within the conflict graph, we have to identify all</span><br>    <span class="hljs-comment">// occurring cycles. We do that by dividing cg into strongly</span><br>    <span class="hljs-comment">// connected subgraphs using Tarjans algorithm in</span><br>    <span class="hljs-comment">// divideIntoSubgraphs().</span><br>    Graph[] cg_subgraphs = divideIntoSubgraphs(cg)<br>    <span class="hljs-comment">// In a strongly connected graph, each node is reachable from</span><br>    <span class="hljs-comment">// every other node. This implies that each strongly connected</span><br>    <span class="hljs-comment">// subgraph of cg with more than one node must contain at least</span><br>    <span class="hljs-comment">// one cycle. We identify the cycles within the subgraphs using</span><br>    <span class="hljs-comment">// Johnsons algorithm in getAllCycles().</span><br>    Cycle[] cycles = emptyList()<br>    foreach subgraph in cg_subgraphs:<br>        <span class="hljs-keyword">if</span>(subgraph.numNodes() &gt; <span class="hljs-number">1</span>) :<br>            cycles.add(subgraph.getAllCycles())<br>    <br>    <span class="hljs-comment">// Step 3: To remove the cycles in cg, we have to remove</span><br>    <span class="hljs-comment">// conflicting transactions from S. To identify the</span><br>    <span class="hljs-comment">// transactions that cause the most problems, for each</span><br>    <span class="hljs-comment">// transaction of S, we count in how many cycles it occurs.</span><br>    MaxHeap transactions_in_cycles = emptyMaxHeap()<br>    foreach Cycle c in cycles :<br>        foreach Transaction t in c :<br>            <span class="hljs-keyword">if</span> transactions_in_cycles.contains(t)<br>                transactions_in_cycles[t]++<br>            <span class="hljs-keyword">else</span><br>                transactions_in_cycles[t] = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment">// Step 4: Let us define S’ as S. We now greedily remove the</span><br>    <span class="hljs-comment">// transaction from S’ that occurs in most cycles, until all</span><br>    <span class="hljs-comment">// cycles have been resolved.</span><br>    Transaction[] S’ = S<br>    while not cycles.empty() :<br>        Transaction t = transactions_in_cycles.popMax()<br>        S’.remove(t)<br>        foreach Cycle c in cycles :<br>            <span class="hljs-keyword">if</span> c.contains(t) :<br>                c.remove(t)<br>                cycles.remove(c)<br>            foreach Transaction t’ in c :<br>                transactions_in_cycles[t’]--<br>    <br>    <span class="hljs-comment">// Step 5: From S’ we have to form the actual serializable</span><br>    <span class="hljs-comment">// schedule. We start by building the (cycle-free) conflict</span><br>    <span class="hljs-comment">// graph of S’.</span><br>    Graph cg’ = buildConflictGraph(S’)<br>    <span class="hljs-comment">// Compute schedule. We start at some node of the graph,</span><br>    <span class="hljs-comment">// that hasn&#x27;t been visited yet.</span><br>    Transactions[] order = emptyList()<br>    Node startNode = cg’.getNextNode()<br>    while order.length() &lt; cg’.numNodes() :<br>        addNode = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">if</span> startNode.alreadyScheduled() :<br>            startNode = cg’.getNextNode()<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment">// Traverse upwards to find a source.</span><br>        foreach Node parentNode in startNode.parents() :<br>            <span class="hljs-keyword">if</span> not parentNode.alreadyScheduled() :<br>                startNode = parentNode<br>                addNode = <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-comment">// A source has been found, so schedule it and traverse downwards.</span><br>        <span class="hljs-keyword">if</span> addNode :<br>            startNode.scheduled()<br>            order.<span class="hljs-built_in">append</span>(startNode)<br>            foreach Node childNode in startNode.children() :<br>                <span class="hljs-keyword">if</span> not childNode.alreadyScheduled() :<br>                    startNode = childNode<br>                    <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> order.invert()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-1-1-Example"><a href="#5-1-1-Example" class="headerlink" title="5.1.1 Example"></a>5.1.1 Example</h4><p>假设有六个交易 T0 到 T5，一共访问了十个键值 K0 到 K9。</p><p><img src="/Paper-Fabric-Plus/5.png" alt="K0 to K9"></p><p><strong>Step 1</strong>：建立交易冲突图。</p><p><img src="/Paper-Fabric-Plus/6.png" alt="Conflict graph C(S)"></p><p><strong>Step 2</strong>：我们应用 Tarjan 的算法来识别所有强连通子图，使用 Johnson 的算法识别强连通子图中的所有环。第一个子图有两个环，第二个子图有一个环，第三个子图无环。</p><p><img src="/Paper-Fabric-Plus/7.png" alt="Subgraphs"></p><p><strong>Step 3</strong>：标记每一笔交易所在的环。</p><p><img src="/Paper-Fabric-Plus/8.png" alt="Transaction in Which Cycle"></p><p><strong>Step 4</strong>：首先处理所在环数最多的交易 T0 和 T3，移除下标较小的一个 T0 以保证算法的确定性，这步操作清除了 c1 和 c2 两个环。接着移除 T2 清除 c3，使图变为无环状态。我们可以从剩下的交易子集 S’ &#x3D; {T1,T3,T4,T5} 建立无冲突调度序列。</p><p><img src="/Paper-Fabric-Plus/9.png" alt="cycle-free conflict graph C(S’)"></p><p><strong>Step 5</strong>：重复执行以下两步，直到所有节点都被 scheduled：(a) 定位当前子图源节点；(b) 对该源节点可访问的所有节点 scheduling。</p><p>首先从 C(S’) 中下标最小的交易 T1 开始（即代码中的 startNode），我们必须找到 T1 的源节点，将它排在最后。T1 有两个父节点 T3 和 T4，T3 没有被访问过但是它有父节点 T4，T4 没有被访问过且是源节点，因此我们将 T4 放在 schedule 的最后一个位置。</p><p>图中 T4 能够到达的所有节点都要排在它前面，T4 有两个子节点 T1 和 T3，T1 没有被 scheduled，但是 T3 指向 T1，所以不能直接 schedule T1。我们访问 T3 并发现它有一个父节点 T4 是源节点，所以将 T3 排在 T4 之前，T1 排在 T3 之前。到此，源节点能够到达的节点都排完了，然后再对剩下的节点进行排序得到 T5 ⇒ T1 ⇒ T3 ⇒ T4。</p><p>请注意，我们的重新排序机制并不能保证中止最少数量的交易，因为这将是一个 NP 难题。然而它提供了一种非常轻量级的方法来生成一个可串行化的调度，只需要少量的中止。</p><h4 id="5-1-2-Batch-Cutting"><a href="#5-1-2-Batch-Cutting" class="headerlink" title="5.1.2 Batch Cutting"></a>5.1.2 Batch Cutting</h4><p>上述讨论忽视了排序服务的出块操作，我们在 Fabric 原有出块条件的基础上加入了一个条件：批处理中交易访问的键值达到一定数量。这个条件确保了我们的重新排序机制的运行时间保持有界。</p><h3 id="5-2-Early-Transaction-Abort-using-Advanced-Concurrency-Control"><a href="#5-2-Early-Transaction-Abort-using-Advanced-Concurrency-Control" class="headerlink" title="5.2 Early Transaction Abort using Advanced Concurrency Control"></a>5.2 Early Transaction Abort using Advanced Concurrency Control</h3><p>重排机制将交易中止时间从验证阶段提前到了排序阶段。</p><h4 id="5-2-1-Early-Abort-in-the-Simulation-Phase"><a href="#5-2-1-Early-Abort-in-the-Simulation-Phase" class="headerlink" title="5.2.1 Early Abort in the Simulation Phase"></a>5.2.1 Early Abort in the Simulation Phase</h4><p>为了在模拟阶段实现 early abort，必须通过更细粒度的并发控制机制来扩展 Fabric，该机制允许在 Peer 中并行执行模拟和验证。有了这样的机制，我们就有机会在模拟过程中识别过时的读取。</p><p>再来看看 4.2.1 的例子，在细粒度的并发控制机制下，当提案 T5 的智能合约正在模拟时，包含 T1、T2、T3 和 T4 的块将不必等待验证，这四个交易将以原子方式应用它们的更新。对于 T5 执行的每一次读取，我们都可以检查读取值是否仍然是最新的。一旦检测到过时的读取，就可以中止对 T5 的模拟并直接通知相应的客户，以便其重新提交提案。</p><p><strong>如何实现</strong>：在现代数据库系统的背景下，高级并发控制机制已经建立起来。这种技术通常在记录级别甚至在单个单元&#x2F;值级别执行细粒度锁定，而不是锁定整个存储。由于数据库系统的存储和 Fabric 中使用的存储在概念上没有区别，因此可以在这里应用类似的技术。</p><p>Fabric 用键值对存储其当前状态，该存储将每个单独的键映射到一对值和版本号。版本号实际上由执行更新的交易 ID 以及块 ID 组成，其唯一目的是识别过时的读取。我们在 Fabric++ 中删除读写锁，因为使用每个值维护的版本号足以确保与 Fabric 相同的交易隔离。为了确保并行运行的模拟阶段不会读到验证阶段执行的更新，我们在模拟过程中检查每个读取值的版本号，并测试它是否是最新的。</p><p><img src="/Paper-Fabric-Plus/10.png" alt="Fine-grained Concurrency Control"></p><p>在模拟阶段开始时，首先识别账本的最后一个区块 ID，在此记为 last-block-ID。如图 last-block-ID &#x3D; 4。在模拟执行期间，任何读取的版本号所包含的 block-ID 都不应该高于 last-block-ID，否则该值在交易模拟阶段已经被更改而过期。模拟阶段中的 balA＝70 的读取发生在验证阶段将 balA 更新为 50 之前。因此读数是最新的，模拟仍在继续。balB 的读取发生在验证阶段将 balB 更新为 100 之后。由于 5 高于 last-block-ID &#x3D; 4，我们可以直接将该交易标记为无效，因为交易将没有机会通过验证阶段。</p><h4 id="5-2-2-Early-Abort-in-the-Ordering-Phase"><a href="#5-2-2-Early-Abort-in-the-Ordering-Phase" class="headerlink" title="5.2.2 Early Abort in the Ordering Phase"></a>5.2.2 Early Abort in the Ordering Phase</h4><p>由于 Fabric 以整个块的粒度执行提交，因此同一块中读取相同键的两个交易必须读取相同版本。因此一旦检测到同一块内的交易之间的版本不匹配，就可以提前中止后一个交易。这种策略确保只有那些有提交机会的交易最终会进入块中。</p><h2 id="6-EXPERIMENTAL-EVALUATION"><a href="#6-EXPERIMENTAL-EVALUATION" class="headerlink" title="6 EXPERIMENTAL EVALUATION"></a>6 EXPERIMENTAL EVALUATION</h2><h3 id="6-1-Setup"><a href="#6-1-Setup" class="headerlink" title="6.1 Setup"></a>6.1 Setup</h3><p>略</p><h3 id="6-2-Benchmark-Framework-and-Workload"><a href="#6-2-Benchmark-Framework-and-Workload" class="headerlink" title="6.2 Benchmark Framework and Workload"></a>6.2 Benchmark Framework and Workload</h3><h4 id="6-2-1-Framework"><a href="#6-2-1-Framework" class="headerlink" title="6.2.1 Framework"></a>6.2.1 Framework</h4><p>主要使用自己搭建的测试工具，也使用了 Caliper。</p><h4 id="6-2-2-Workload"><a href="#6-2-2-Workload" class="headerlink" title="6.2.2 Workload"></a>6.2.2 Workload</h4><p><strong>两种不同的工作负载</strong>：</p><p>第一种是 Smallbank，它模拟了一个典型的资产转移场景。最初，它为一定数量的用户分别创建一个支票账户和一个储蓄账户，并用随机余额初始化它们。工作负载由六笔交易组成，其中五笔交易以某些方式更新账户余额：TransactSavings 和 DepositChecking 将储蓄账户和支票账户分别增加一定数额。SendPayment 在两个支票账户之间转账。WriteCheck 减少支票账户，而 Amalgamate 将所有资金从储蓄账户转移到支票账户。还有一个只读交易 Query 读取用户的支票以及储蓄账户。在一次运行过程中，我们以随机的方式重复发送这六个交易，其中我们以一定的概率 Pw 从五个修改交易中统一选择一个，以概率 1−Pw 读取交易。对于每个选择的交易，通过遵循 Zipfian 分布来确定要访问的帐户，可以通过设置 s 值来进行配置。</p><p>第二种工作负载仅由一个高度可配置的交易组成，对一组帐户余额执行一定数量的读写访问。最初，我们创建一定数量的帐户（N），每个帐户都用一个随机整数初始化。交易对这些帐户的一个子集执行一定数量的读写（RW）。在这些帐户中，存在一定数量的热帐户（HSS），它们具有更高概率的读写访问。可以分别配置用于读取（HR）和用于写入（HW）的热帐户的概率。在一次运行中，我们以一定的概率在一定的时间内发送固定的交易流。</p><p><img src="/Paper-Fabric-Plus/11.png" alt="Experiment and System Configuration"></p><h3 id="6-3-The-Impact-of-the-Blocksize"><a href="#6-3-The-Impact-of-the-Blocksize" class="headerlink" title="6.3 The Impact of the Blocksize"></a>6.3 The Impact of the Blocksize</h3><p>我们通过调查块大小对 Fabric 和 Fabric++ 的影响来开始测试。默认情况下，Fabric 的 sample network 将块大小限制为最多 10 个交易。在下面的实验中，我们以对数递增将块大小从 16 增加到 2048，并观察成功交易数量。Smallbank 作为工作负载，有 100000 名用户 Pw &#x3D; 95% 的高写工作负载和 s &#x3D; 0 的均匀分布。下图展示了总共 90 秒运行时间里每秒的平均成功交易数。</p><p><img src="/Paper-Fabric-Plus/12.png" alt="Effect of the Blocksize"></p><h3 id="6-4-Transactional-Throughput"><a href="#6-4-Transactional-Throughput" class="headerlink" title="6.4 Transactional Throughput"></a>6.4 Transactional Throughput</h3><h4 id="6-4-1-Throughput-under-Smallbank"><a href="#6-4-1-Throughput-under-Smallbank" class="headerlink" title="6.4.1 Throughput under Smallbank"></a>6.4.1 Throughput under Smallbank</h4><p><img src="/Paper-Fabric-Plus/13.png" alt="Smallbank Workload Configuration"></p><p><img src="/Paper-Fabric-Plus/14.png" alt="Result"></p><h4 id="6-4-2-Throughput-under-custom-workload"><a href="#6-4-2-Throughput-under-custom-workload" class="headerlink" title="6.4.2 Throughput under custom workload"></a>6.4.2 Throughput under custom workload</h4><p><img src="/Paper-Fabric-Plus/15.png" alt="Custom Workload Configuration"></p><p><img src="/Paper-Fabric-Plus/16.png" alt="Result"></p><h4 id="6-4-3-Observations"><a href="#6-4-3-Observations" class="headerlink" title="6.4.3 Observations"></a>6.4.3 Observations</h4><p>Fabric++ 倾向于选择更多访问较少键值的交易，而不是选择少数访问次数较多的交易，以提高成功交易的端到端吞吐量。对于可能具有非冲突读写集的工作负载，Fabric++ 能够重新组织交易块，以最大限度地减少不必要的中止次数。</p><h3 id="6-5-Optimization-Breakdown"><a href="#6-5-Optimization-Breakdown" class="headerlink" title="6.5 Optimization Breakdown"></a>6.5 Optimization Breakdown</h3><p><img src="/Paper-Fabric-Plus/17.png" alt="BS=1024, RW=8, HR=40%, HW=10%, HSS=1%"></p><h3 id="6-6-Scaling-Channels-and-Clients"><a href="#6-6-Scaling-Channels-and-Clients" class="headerlink" title="6.6 Scaling Channels and Clients"></a>6.6 Scaling Channels and Clients</h3><p>之前的实验是在单通道四客户端进行的，接下来改变这两个配置。</p><p><img src="/Paper-Fabric-Plus/18.png" alt="BS=1024, RW=8, HR=40%, HW=10%, HSS=1%"></p><h3 id="6-7-Hyperledger-Caliper"><a href="#6-7-Hyperledger-Caliper" class="headerlink" title="6.7 Hyperledger Caliper"></a>6.7 Hyperledger Caliper</h3><p>Caliper 在高交易触发率下受影响严重，所以我们用四个客户端分别以 150 交易每秒发送交易，总共 600 交易每秒。</p><p><img src="/Paper-Fabric-Plus/19.png" alt="N=10000, BS=512, RW=4, HR=40%, HW=10%, HSS=1%"></p><h2 id="7-CONCLUSION"><a href="#7-CONCLUSION" class="headerlink" title="7 CONCLUSION"></a>7 CONCLUSION</h2><p>略</p><h2 id="8-ACKNOWLEDGEMENT"><a href="#8-ACKNOWLEDGEMENT" class="headerlink" title="8 ACKNOWLEDGEMENT"></a>8 ACKNOWLEDGEMENT</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(11)：RPC 原理</title>
    <link href="/ByteDance-11/"/>
    <url>/ByteDance-11/</url>
    
    <content type="html"><![CDATA[<p>RPC —— Remote Procedure Calls。</p><span id="more"></span><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-1-远程函数调用"><a href="#1-1-远程函数调用" class="headerlink" title="1.1 远程函数调用"></a>1.1 远程函数调用</h3><p><strong>RPC 需要解决的问题</strong>：</p><ol><li>函数映射<br> 在本地调用中，函数体是直接通过函数指针来指定的，我们调用哪个方法，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以函数都有自己的一个 ID，在 RPC 的时候要附上这个 ID，还得有个 ID 和函数的对照关系表，通过 ID 找到对应的函数并执行。</li><li>数据转换成字节流<br> 在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。这时候就需要客户端把参数先转成一个字节流，传给服务端把字节流转成能读取的格式。</li><li>网络传输</li></ol><h3 id="1-2-完整过程"><a href="#1-2-完整过程" class="headerlink" title="1.2 完整过程"></a>1.2 完整过程</h3><p><img src="/ByteDance-11/1.png"></p><ul><li><p>IDL (Interface description language) 文件：IDL 是方法与参数的描述文件，它通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信</p></li><li><p>生成代码：通过编译器工具把 IDL 文件转换成语言对应的静态库</p></li><li><p>编解码：从内存中表示到字节序列的转换称为编码，反之为解码，也常叫做序列化和反序列化</p></li><li><p>通信协议：规范了数据在网络中的传输内容和格式。除必须的请求&#x2F;响应数据外，通常还会包含额外的元数据</p></li><li><p>网络传输：通常基于成熟的网络库 TCP&#x2F;UDP 传输</p></li></ul><h3 id="1-3-RPC-的优势"><a href="#1-3-RPC-的优势" class="headerlink" title="1.3 RPC 的优势"></a>1.3 RPC 的优势</h3><ol><li>单一职责，有利于分工协作和运维开发（可以采用不同语言）</li><li>可扩展性强，资源使用率更优（底层基础服务可以复用）</li><li>故障隔离，服务的整体可靠性更高</li></ol><h3 id="1-4-RPC-的问题"><a href="#1-4-RPC-的问题" class="headerlink" title="1.4 RPC 的问题"></a>1.4 RPC 的问题</h3><ol><li>服务宕机，对方应该如何处理？</li><li>在调用过程中发生网络异常，如何保证消息的可达性？</li><li>请求量突增导致服务无法及时处理，有哪些应对措施？</li></ol><p>用 RPC 框架来解决这些问题。</p><h2 id="2-分层设计"><a href="#2-分层设计" class="headerlink" title="2 分层设计"></a>2 分层设计</h2><p><img src="/ByteDance-11/2.png"></p><h3 id="2-1-编解码层"><a href="#2-1-编解码层" class="headerlink" title="2.1 编解码层"></a>2.1 编解码层</h3><h4 id="2-1-1-生成代码"><a href="#2-1-1-生成代码" class="headerlink" title="2.1.1 生成代码"></a>2.1.1 生成代码</h4><p><img src="/ByteDance-11/3.png"></p><h4 id="2-1-2-数据格式"><a href="#2-1-2-数据格式" class="headerlink" title="2.1.2 数据格式"></a>2.1.2 数据格式</h4><ul><li><p>语言特定的格式：许多编程语言都内建了将内存对象编码为字节序列的支持，例如 Java 有 java.io.Serializable。这种编码形式好处是非常方便，可以用很少的额外代码实现内存对象的保存与恢复，这类编码通常与特定的编程语言深度绑定，其他语言很难读取这种数据。</p></li><li><p>文本格式：JSON、XML、CSV 等文本格式，具有人类可读性。但是数字的编码多有歧义之处，比如 XML 和 CSV 不能区分数字和字符串，JSON 虽然区分字符串和数字，但是不区分整数和浮点数，而且不能指定精度。处理大量数据时，这个问题更严重了，没有强制模型约束，实际操作中往往只能采用文档方式来进行约定，这可能会给调试带来一些不便。由于 JSON 在一些语言中的序列化和反序列化需要采用反射机制，所以性能比较差。</p></li><li><p>二进制编码：具备跨语言和高性能等优点，常见有 Thrift 的 BinaryProtocol，Protobuf 等。</p></li></ul><h4 id="2-1-3-二进制编码"><a href="#2-1-3-二进制编码" class="headerlink" title="2.1.3 二进制编码"></a>2.1.3 二进制编码</h4><p><strong>TLV 编码</strong></p><ul><li>Tag：标签，可以理解为类型</li><li>Length：长度</li><li>Value：值，Value 也可以是个 TLV 结构</li></ul><p><img src="/ByteDance-11/4.png"></p><p>TLV 编码结构简单清晰，并且扩展性较好，但是由于增加了 Type 和 Length 两个冗余信息，有额外的内存开销，特别是在大部分字段都是基本类型的情况下有不小的空间浪费。</p><h3 id="2-2-协议层"><a href="#2-2-协议层" class="headerlink" title="2.2 协议层"></a>2.2 协议层</h3><h4 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1 概念"></a>2.2.1 概念</h4><p>特殊结束符：过于简单，对于一个协议单元必须要全部读入才能够进行处理，除此之外必须要防止用户传输的数据不能同结束符相同，否则就会出现紊乱。HTTP 协议头就是以回车（CR）加换行（LF）符号序列结尾。<br>变长协议：一般都是自定义协议，由 header 和 payload 组成，会以定长加不定长的部分组成，其中定长的部分需要描述不定长的内容长度，使用比较广泛。</p><h4 id="2-2-2-构造"><a href="#2-2-2-构造" class="headerlink" title="2.2.2 构造"></a>2.2.2 构造</h4><p><img src="/ByteDance-11/5.png"></p><ul><li>LENGTH (32bits)：数据包大小，不包含自身</li><li>HEADER MAGIC (16bits)：标识版本信息，协议解析时候快速校验</li><li>SEQUENCE NUMBER (32bits)：表示数据包的 seqID,可用于多路复用，单连接内递增</li><li>HEADERSIZE (16bits)：头部长度，从第 14 个字节开始计算一直到 PAYLOAD 前</li><li>PROTOCOL ID：编解码方式，有 Binary 和 Compact 两种</li><li>TRANSFORM ID：压缩方式，如 zlib 和 snappy</li><li>INFOID：传递一些定制的 meta 信息</li><li>PAYLOAD：消息体</li></ul><h3 id="2-3-网络通信层"><a href="#2-3-网络通信层" class="headerlink" title="2.3 网络通信层"></a>2.3 网络通信层</h3><h4 id="2-3-1-Sockets-API"><a href="#2-3-1-Sockets-API" class="headerlink" title="2.3.1 Sockets API"></a>2.3.1 Sockets API</h4><p><img src="/ByteDance-11/6.png"><br><img src="/ByteDance-11/7.png"></p><p>套接字编程中的客户端必须知道两个信息：服务器的 IP 地址，端口号。</p><p>socket 函数创建一个套接字，bind 将一个套接字绑定到一个地址上，listen 监听进来的连接，accept 函数从队列中取出连接请求并接收它。</p><p>connect 客户端向服务器发起连接，accept 接收一个连接请求，如果没有连接则会一直阻塞直到有连接进来。调用 read，write 函数和客户端通讯，读写方式和其他 I&#x2F;O 类似。</p><p>socket 关闭套接字，当另一端 socket 关闭后，这一端读写的情况：尝试去读会得到一个 EOF，并返回 O。</p><h4 id="2-3-2-网络库"><a href="#2-3-2-网络库" class="headerlink" title="2.3.2 网络库"></a>2.3.2 网络库</h4><ul><li><p>提供易用 API</p><ul><li>封装底层 Socket API</li><li>连接管理和事件分发</li></ul></li><li><p>功能</p><ul><li>协议支持：tcp、udp 和 uds 等</li><li>优雅退出、异常处理等</li></ul></li><li><p>性能</p><ul><li>应用层 buffer 减少 copy </li><li>高性能定时器、对象池等</li></ul></li></ul><h2 id="3-关键指标"><a href="#3-关键指标" class="headerlink" title="3 关键指标"></a>3 关键指标</h2><h2 id="3-1-稳定性"><a href="#3-1-稳定性" class="headerlink" title="3.1 稳定性"></a>3.1 稳定性</h2><ul><li><p><strong>保障策略</strong></p><ul><li>熔断：保护调用方，防止被调用的服务出现问题而影响到整个链路。一个服务 A 调用服务 B 时，服务 B 的业务逻辑又调用了服务 C，而这时服务 C 响应超时了，由于服务 B 依赖服务 C，C 超时直接导致 B 的业务逻辑一直等待，而这个时候服务 A 继续频繁地调用服务 B，服务 B 就可能会因为堆积大量的请求而导致服务宕机，由此就导致了服务雪崩的问题。</li><li>限流：保护被调用方，防止大流量把服务压垮超时。当调用端发送请求过来时，服务端在执行业务逻辑之前先执行检查限流逻辑，如果发现访问量过大并且超出了限流条件，就让服务端直接降级处理或者返回给调用方一个限流异常。</li><li>控制：避免浪费资源在不可用节点上。当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，避免浪费资源。</li></ul></li><li><p><strong>请求成功率</strong></p><ul><li>负载均衡</li><li>重试：防止重试风暴，限制单点重试和限制链路重试。</li></ul></li><li><p><strong>长尾请求</strong><br>  长尾请求一般是指明显高于均值的那部分占比较小的请求。业界关于延迟有一个常用的 P99 标准，P99 单个请求响应耗时从小到大排列，顺序处于 99% 位置的值即为 P99 值，那后面这 1% 就可以认为是长尾请求。在较复杂的系统中，长尾延时总是会存在。造成的原因非常多，常见的有网络抖动，GC，系统调度。</p></li></ul><h2 id="3-2-易用性"><a href="#3-2-易用性" class="headerlink" title="3.2 易用性"></a>3.2 易用性</h2><h2 id="3-3-扩展性"><a href="#3-3-扩展性" class="headerlink" title="3.3 扩展性"></a>3.3 扩展性</h2><h2 id="3-4-观测性"><a href="#3-4-观测性" class="headerlink" title="3.4 观测性"></a>3.4 观测性</h2><h2 id="3-5-高性能"><a href="#3-5-高性能" class="headerlink" title="3.5 高性能"></a>3.5 高性能</h2><ul><li><strong>高吞吐</strong></li><li><strong>低延迟</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「毕」 1. 测试 Fabric 2.4.0</title>
    <link href="/Project1-Test/"/>
    <url>/Project1-Test/</url>
    
    <content type="html"><![CDATA[<p>fabric：<a href="https://github.com/hyperledger/fabric">https://github.com/hyperledger/fabric</a>.<br>tape：<a href="https://github.com/Hyperledger-TWGC/tape">https://github.com/Hyperledger-TWGC/tape</a>.<br>Caliper：<a href="https://hyperledger.github.io/caliper/v0.4.2/installing-caliper/">https://hyperledger.github.io/caliper/v0.4.2/installing-caliper/</a></p><span id="more"></span><h2 id="搭建-Fabric-网络"><a href="#搭建-Fabric-网络" class="headerlink" title="搭建 Fabric 网络"></a>搭建 Fabric 网络</h2><ol><li><p>创建项目目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ mkdir fabric<br>$ cd fabric<br></code></pre></td></tr></table></figure></li><li><p>拉取 fabric 项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ git clone https://github.com/hyperledger/fabric.git<br>$ cd fabric<br>$ git checkout v2.4.0<br></code></pre></td></tr></table></figure></li><li><p>拉取 fabric 镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd fabric/fabric/scripts<br></code></pre></td></tr></table></figure><p> <strong>此处我们需要修改当前目录下的 bootstrap.sh 脚本</strong></p><p> 此脚本先会拉取 fabric-samples，再拉取环境所用的二进制文件，但国内网络是无法访问的，从而导致后面的操作失败，所以我们选择手动拉取 fabric-samples 再切换到 v2.4.0 分支。此脚本仅仅作为拉取镜像的操作。</p><p> 修改：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bootstrap.sh">DOCKER=true<br>SAMPLES=false<br>BINARIES=false<br></code></pre></td></tr></table></figure><p> 运行脚本</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ ./bootstrap.sh<br></code></pre></td></tr></table></figure></li><li><p>拉取 fabric-samples</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd fabric<br>$ git clone https://github.com/hyperledger/fabric-samples.git<br>$ git checkout v2.4.0<br></code></pre></td></tr></table></figure></li><li><p>下载需要的二进制文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd fabric/fabric-samples<br>$ wget https://github.com/hyperledger/fabric/releases/download/v2.4.0/hyperledger-fabric-linux-amd64-2.4.0.tar.gz<br>$ tar -xzvf hyperledger-fabric-linux-amd64-2.4.0.tar.gz<br>$ wget https://github.com/hyperledger/fabric-ca/releases/download/v1.5.6/hyperledger-fabric-ca-linux-amd64-1.5.6.tar.gz<br>$ tar -xzvf hyperledger-fabric-ca-linux-amd64-1.5.6.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>启动&#x2F;关闭网络</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd fabric/fabric-samples/test-network<br>$ ./network.sh up<br></code></pre></td></tr></table></figure><p> 成功启动一个 orderer 节点 和两个 peer 节点。</p><p> 关闭网络</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ ./network.sh down<br></code></pre></td></tr></table></figure><p> 该命令将停止并删除节点和链码容器，删除组织加密材料，并从 Docker Registry 移除链码镜像，另外还会删除之前运行的通道项目。</p></li></ol><h2 id="使用-Tape-测试"><a href="#使用-Tape-测试" class="headerlink" title="使用 Tape 测试"></a>使用 Tape 测试</h2><ol><li><p>启动 Fabric 网络</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd fabric/fabric-samples/test-network<br>$ ./network.sh up createChannel -s couchdb<br></code></pre></td></tr></table></figure></li><li><p>安装默认链码</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go<br></code></pre></td></tr></table></figure></li><li><p>克隆官方 tape 仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ git clone https://github.com/Hyperledger-TWGC/tape<br></code></pre></td></tr></table></figure></li><li><p>将 fabric-samples&#x2F;test-network 的网络生成的证书文件夹（organizations）复制到 tape 文件内</p></li><li><p>将 tape&#x2F;config.yaml 文件配置信息替换为如下配置信息：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs config.yaml"># Definition of nodes<br>peer1: &amp;peer1<br>    addr: localhost:7051<br>    ssl_target_name_override: peer0.org1.example.com<br>    org: org1<br>    tls_ca_cert: /config/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/tlscacerts/tlsca.org1.example.com-cert.pem<br><br>peer2: &amp;peer2<br>    addr: localhost:9051<br>    ssl_target_name_override: peer0.org2.example.com<br>    org: org2<br>    tls_ca_cert: /config/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp/tlscacerts/tlsca.org2.example.com-cert.pem<br><br>orderer1: &amp;orderer1<br>    addr: localhost:7050<br>    ssl_target_name_override: orderer.example.com<br>    org: org1<br>    tls_ca_cert: /config/organizations/ordererOrganizations/example.com/msp/tlscacerts/tlsca.example.com-cert.pem<br><br>policyFile: /config/test/andLogic.rego<br><br># Nodes to interact with<br>endorsers:<br>    - *peer1<br># we might support multi-committer in the future for more complex test scenario,<br># i.e. consider tx committed only if it&#x27;s done on &gt;50% of nodes. But for now,<br># it seems sufficient to support single committer.<br>committers: <br>    - *peer1<br>    - *peer2<br><br>commitThreshold: 1<br><br>orderer: *orderer1<br><br># Invocation configs<br>channel: mychannel<br>chaincode: basic<br>args:<br>    - GetAllAssets<br>mspid: Org1MSP<br>private_key: /config/organizations/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/keystore/priv_sk<br>sign_cert: /config/organizations/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/signcerts/User1@org1.example.com-cert.pem<br>num_of_conn: 10<br>client_per_conn: 10<br></code></pre></td></tr></table></figure></li><li><p>在 tape 文件夹下命令行启动执行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ docker run --network=host -v $PWD:/config guoger/tape tape -c /config/config.yaml -n 50000<br></code></pre></td></tr></table></figure><p> <img src="/Project1-Test/1.png" alt="result"></p></li></ol><h2 id="使用-Caliper-测试"><a href="#使用-Caliper-测试" class="headerlink" title="使用 Caliper 测试"></a>使用 Caliper 测试</h2><p>Caliper 测试起来感觉比较复杂，不如 Tape 轻量，之前也一直报错，但是最近试了一下又成功了，记录一下。</p><ol><li><p>安装 Caliper<br> 首先 caliper-benchmarks 需要下载到指定文件路径位置。因为阅读了 caliper-benchmarks 的相关配置文件后，发现它 yaml 文件对 test-network 里的文件是采用相对路径定位的，需要将其下载到 fabric-sample 的上一级目录的位置才能正确执行。当然也可以随便下载到一个位置，然后修改 caliper-benchmarks 的配置内容。<br> <img src="/Project1-Test/2.png" alt="位置"></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ git clone https://github.com/hyperledger/caliper-benchmarks<br>$ cd caliper-benchmarks<br>$ npm init -y<br>$ npm install --only=prod @hyperledger/caliper-cli@0.4.2  # 0.4.2 对应的是 fabric2.x，0.3.2 对应 fabric1.x<br>$ npx caliper bind --caliper-bind-sut fabric:2.2  # 绑定，这里用的 2.2，用 2.4 失败了<br><br>$ npx caliper --version  #查看所安装的 caliper 版本<br></code></pre></td></tr></table></figure></li><li><p>部署链码</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd ../fabric-samples/test-network  # 回到 test-network 文件夹<br>$ ./network.sh down<br>$ ./network.sh up createChannel<br><br># 部署 caliper 自带的 fabcar 样例，以供展开测试<br>$ ./network.sh deployCC -ccn fabcar -ccp ../../caliper-benchmarks/src/fabric/samples/fabcar/go -ccl go<br></code></pre></td></tr></table></figure></li><li><p>进行测试</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Linux">$ cd ../../caliper-benchmarks/<br><br>$ npx caliper launch manager \<br>    --caliper-workspace ./ \<br>    --caliper-networkconfig networks/fabric/test-network.yaml \<br>    --caliper-benchconfig benchmarks/samples/fabric/fabcar/config.yaml \<br>    --caliper-flow-only-test \<br>    --caliper-fabric-gateway-enabled<br></code></pre></td></tr></table></figure><p> <img src="/Project1-Test/3.png" alt="result"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>毕设项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 07. 栈与队列</title>
    <link href="/Algorithm-stack/"/>
    <url>/Algorithm-stack/</url>
    
    <content type="html"><![CDATA[<p>栈与队列相关题目。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>队列是先进先出（队头删除，队尾插入），栈是先进后出。</p><p><img src="/Algorithm-stack/1.png"></p><p>Go 语言中，并没有栈与队列相关的数据结构，但是我们可以借助切片来实现栈与队列的操作。</p><p>Linux 系统中，cd 这个进入目录的命令就是栈的应用。</p><p><strong>递归的实现是栈</strong>：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><h3 id="1-1-用栈实现队列"><a href="#1-1-用栈实现队列" class="headerlink" title="1.1 用栈实现队列"></a>1.1 用栈实现队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>    stackIn  []<span class="hljs-type">int</span> <span class="hljs-comment">// 输入栈</span><br>    stackOut []<span class="hljs-type">int</span> <span class="hljs-comment">// 输出栈</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br>    <span class="hljs-keyword">return</span> MyQueue&#123;<br>        stackIn:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>        stackOut: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 往输入栈做 push</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>    this.stackIn = <span class="hljs-built_in">append</span>(this.stackIn, x)<br>&#125;<br><br><span class="hljs-comment">// 在输出栈做 pop，pop 时如果输出栈数据为空，需要将输入栈全部数据导入，如果非空，则可直接使用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    inLen, outLen := <span class="hljs-built_in">len</span>(this.stackIn), <span class="hljs-built_in">len</span>(this.stackOut)<br>    <span class="hljs-keyword">if</span> outLen == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> inLen == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i := inLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>            this.stackOut = <span class="hljs-built_in">append</span>(this.stackOut, this.stackIn[i])<br>        &#125;<br>        this.stackIn = []<span class="hljs-type">int</span>&#123;&#125;      <span class="hljs-comment">// 导出后清空</span><br>        outLen = <span class="hljs-built_in">len</span>(this.stackOut) <span class="hljs-comment">// 更新长度值</span><br>    &#125;<br>    val := this.stackOut[outLen<span class="hljs-number">-1</span>]<br>    this.stackOut = this.stackOut[:outLen<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-comment">// 返回队列首部的元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br>    val := this.Pop()<br>    <span class="hljs-keyword">if</span> val == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.stackOut = <span class="hljs-built_in">append</span>(this.stackOut, val)<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(this.stackIn) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(this.stackOut) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-用队列实现栈"><a href="#1-2-用队列实现栈" class="headerlink" title="1.2 用队列实现栈"></a>1.2 用队列实现栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    queue []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br>    <span class="hljs-keyword">return</span> MyStack &#123;<br>        queue: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Push element x onto stack. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>)  &#123;<br>    this.queue = <span class="hljs-built_in">append</span>(this.queue, x)<br>&#125;<br><br><br><span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(this.queue) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 除了最后一个，其余的都重新添加到队列里</span><br>        val := this.queue[<span class="hljs-number">0</span>]<br>        this.queue = this.queue[<span class="hljs-number">1</span>:]<br>        this.queue = <span class="hljs-built_in">append</span>(this.queue, val)<br>        n--<br>    &#125;<br>    <span class="hljs-comment">// 弹出元素</span><br>    val := this.queue[<span class="hljs-number">0</span>]<br>    this.queue = this.queue[<span class="hljs-number">1</span>:]<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><br><span class="hljs-comment">/** Get the top element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 利用 Pop 函数，弹出来的元素重新添加</span><br>    val := this.Pop()<br>    this.queue = <span class="hljs-built_in">append</span>(this.queue, val)<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><br><span class="hljs-comment">/** Returns whether the stack is empty. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(this.queue) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2 题目"></a>2 题目</h2><h3 id="2-1-leetcode-20-题"><a href="#2-1-leetcode-20-题" class="headerlink" title="2.1 leetcode 20 题"></a>2.1 <a href="https://leetcode.cn/problems/valid-parentheses/">leetcode 20 题</a></h3><p>有效的括号。</p><p>由于栈结构的特殊性，非常适合做对称匹配类的题目。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    hash := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;<br>    stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, s[i])<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] == hash[s[i]] &#123;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-leetcode-150-题"><a href="#2-2-leetcode-150-题" class="headerlink" title="2.2 leetcode 150 题"></a>2.2 <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">leetcode 150 题</a></h3><p>逆波兰表达式求值。</p><p>题目本身不难，题解巧妙使用了 err 值得学习。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(tokens []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>stack := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, token := <span class="hljs-keyword">range</span> tokens &#123;<br>val, err := strconv.Atoi(token)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, val)<br>&#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// 如果 err 不为 nil 说明不是数字</span><br>num1, num2 := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>], stack[(<span class="hljs-built_in">len</span>(stack))<span class="hljs-number">-1</span>]<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]<br><span class="hljs-keyword">switch</span> token &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>stack = <span class="hljs-built_in">append</span>(stack, num1+num2)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>stack = <span class="hljs-built_in">append</span>(stack, num1-num2)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>stack = <span class="hljs-built_in">append</span>(stack, num1*num2)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>stack = <span class="hljs-built_in">append</span>(stack, num1/num2)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-leetcode-239-题"><a href="#2-3-leetcode-239-题" class="headerlink" title="2.3 leetcode 239 题"></a>2.3 <a href="https://leetcode.cn/problems/sliding-window-maximum/">leetcode 239 题</a></h3><p>滑动窗口最大值。</p><p>构建一个递减队列来不断存储更新最大值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> queue, res []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &gt; queue[<span class="hljs-number">0</span>] &#123;<br>                queue = queue[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> nums[i] &gt; queue[<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>] &#123;<br>                    queue = queue[:<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]<br>                &#125;<br>            &#125;<br>        &#125;<br>        queue = <span class="hljs-built_in">append</span>(queue, nums[i])<br>    &#125;<br>    res = <span class="hljs-built_in">append</span>(res, queue[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-keyword">for</span> i := k; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i-k] == queue[<span class="hljs-number">0</span>] &#123;<br>            queue = queue[<span class="hljs-number">1</span>:]<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &gt; queue[<span class="hljs-number">0</span>] &#123;<br>                queue = queue[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> nums[i] &gt; queue[<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>] &#123;<br>                    queue = queue[:<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]<br>                &#125;<br>            &#125;<br>        &#125;<br>        queue = <span class="hljs-built_in">append</span>(queue, nums[i])<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue) &gt; k &#123;<br>            queue = queue[:k]<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, queue[<span class="hljs-number">0</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-leetcode-739-题"><a href="#2-4-leetcode-739-题" class="headerlink" title="2.4 leetcode 739 题"></a>2.4 <a href="https://leetcode.cn/problems/daily-temperatures/">leetcode 739 题</a></h3><p>给定一个整数数组 temperatures，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>该题使用暴力解法时间复杂度为 O(n^2)，可以使用<strong>单调栈</strong>，空间换时间，实现 O(n) 的时间复杂度。</p><p>本题要使用递增循序（从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素 i 的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是 i。</p><p><strong>如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temperatures))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(temperatures); i++ &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, i)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> temperatures[i] &gt; temperatures[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; temperatures[i] &gt; temperatures[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &#123;<br>                res[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] = i - stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125; <br>        stack = <span class="hljs-built_in">append</span>(stack, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-leetcode-42-题"><a href="#2-5-leetcode-42-题" class="headerlink" title="2.5 leetcode 42 题"></a>2.5 <a href="https://leetcode.cn/problems/trapping-rain-water/">leetcode 42 题</a></h3><p>接雨水，单调栈参考<a href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">解析</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    stack := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(height); i++ &#123; <br>        <span class="hljs-keyword">if</span> height[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &lt; height[i] &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; height[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &lt; height[i] &#123;<br>                top := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>                    tmp := (min(height[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]], height[i]) - height[top]) * (i - stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>)<br>                    res += tmp<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> height[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] == height[i] &#123;<br>            stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] = i<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(10)：消息队列</title>
    <link href="/ByteDance-10/"/>
    <url>/ByteDance-10/</url>
    
    <content type="html"><![CDATA[<p>消息队列（MQ），指保存消息的一个容器，本质是个队列。但这个队列呢，需要支持高吞吐，高并发，并且高可用。</p><span id="more"></span><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>分布式的、分区的、多副本的日志提交服务，在高吞吐场景下发挥较为出色。</p><p><img src="/ByteDance-10/1.png"> </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/ByteDance-10/2.png"> </p><ul><li>Topic：逻辑队列，可以理解成每一个不同的业务场景就是一个不同的 Topic，对于这个业务来说，所有的数据都存储在这个 Topic 中</li><li>Partition：分片，通常 Topic 会有多个分片，不同分片之间消息是可以并发来处理的，这样提高单个 Topic 的吞吐量</li><li>Cluster：物理集群，每个集群中可以建立多个不同的 Topic</li><li>Producer：生产者，负责将业务消息发送到 Topic 中</li><li>Consumer：消费者，负责消费 Topic 中的消息</li><li>ConsumerGroup：消费者组，不同组 Consumer 消费进度互不干涉</li></ul><p><img src="/ByteDance-10/3.png"> </p><ul><li>Offset：消息在 Partition 内的相对位置信息，可以理解为唯一 ID，在 Partition 内部严格递增</li><li>Replica：分片的副本，分布在不同的机器上，可用来容灾，Leader 对外服务，Follower 异步拉取 Leader 的数据进行同步，如果 Leader 挂掉了，可以将 Follower 提升成 Leader 再对外进行服务</li><li>ISR：意思是同步中的副本，对于 Follower 来说，始终和 Leader 是有一定差距的，但当这个差距比较小的时候，我们就可以将这个 Follower 副本加入到 ISR 中，不在 ISR 中的副本是不允许提升成 Leader 的</li></ul><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>下图代表着 Kafka 中副本的分布图。Broker 代表每一个 Kafka 的节点，所有的 Broker 节点最终组成了一个集群。图中整个集群，包含了 4 个 Broker 机器节点，集群有两个 Topic，分别是 Topic1 和 Topic2，Topic1 有两个分片，Topic2 有 1 个分片，每个分片都是三副本的状态。这里中间有一个 Broker 同时也扮演了 Controller 的角色，Controller 是整个集群的大脑，负责对副本和 Broker 进行分配。</p><p><img src="/ByteDance-10/4.png"> </p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/ByteDance-10/5.png"></p><p>在集群的基础上，还有一个模块是 ZooKeeper，这个模块其实是存储了集群的元数据信息，比如副本的分配信息等等，Controller 计算好的方案都会放到这个地方。</p><h3 id="提高吞吐"><a href="#提高吞吐" class="headerlink" title="提高吞吐"></a>提高吞吐</h3><ul><li><p>Producer：批量发送，数据压缩</p></li><li><p>Broker：顺序写，消息索引，零拷贝<br>  <img src="/ByteDance-10/10.png" alt="零拷贝"></p></li><li><p>Consumer：Rebalance</p></li></ul><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li><p>数据复制问题</p><p> 举个例子来说，如果我们对一个机器进行重启：首先，我们会关闭一个 Broker，此时如果该 Broker 上存在副本的 Leader， 那么该副本将发生 Leader 切换。而因为数据在不断的写入，刚刚关闭重启的 Broker 和新 Leader 之间一定会存在数据的滞后，此时这个 Broker 会追赶数据，重新加入到 ISR 当中。当数据追赶完成之后，我们需要回切 Leader，这一步目的是为了避免在一个集群长期运行后，所有的 Leader 都分布在少数节点上，导致数据的不均衡。</p><p> 通过上面的分析，我们可以发现对于一个 Broker 的重启来说，需要进行数据复制，所以时间成本会比较大，比如一个节点重启需要 10 分钟，一个集群有 1000 个节点，如果该集群需要重启升级，则需要 10000 分钟，那差不多就是一个星期。如果并发多台重启，在一个两副本的集群中，重启了两台机器，对某一分片来讲，可能两个分片都在这台机器上面，则会导致该集群处于不可用的状态，这是更不能接受的。在替换、扩容、缩容的过程中也会遇到数据复制的时间成本问题。</p></li><li><p>负载不均衡</p><p> 某个 Broker 负载较高时，需要将某分片迁移到负载小的机器上，但是数据复制的过程又会加大该 Broker 的负载。所以其负载均衡非常复杂。</p></li><li><p>没有自己的缓存，完全依赖 Page Cache</p></li><li><p>Controller 和 Coordinator 和 Broker 在同一进程中，大量 IO 会造成其性能下降</p></li></ol><h2 id="BMQ"><a href="#BMQ" class="headerlink" title="BMQ"></a>BMQ</h2><p>存算分离，初期定位是承接高吞吐的离线业务场景，逐步替换掉对应的 Kafka 集群。</p><p><img src="/ByteDance-10/7.png"></p><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p><img src="/ByteDance-10/6.png"></p><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>低延迟、强一致、高性能、高可靠、万亿级容量和灵活的可扩展性，在一些实时场景中运用较广。</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/ByteDance-10/8.png"></p><h3 id="架构模型-1"><a href="#架构模型-1" class="headerlink" title="架构模型"></a>架构模型</h3><p><img src="/ByteDance-10/9.png"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 06. KMP 算法</title>
    <link href="/Algorithm-KMP/"/>
    <url>/Algorithm-KMP/</url>
    
    <content type="html"><![CDATA[<p>以 <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">leetcode 28 题</a>为例，学习一下 KMP 算法。本文参考 <a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#_28-%E5%AE%9E%E7%8E%B0-strstr">Carl 的教程</a>。</p><span id="more"></span><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p><code>给你两个字符串 haystack 和 needle，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。</code></p><p>举个例子，就是要在<strong>文本串</strong>：aabaabaafa 中查找是否出现过一个<strong>模式串</strong>：aabaaf，并返回出现的地方。</p><p>暴力解法很容易想到，但是时间复杂度是 <strong>O(m*n)</strong> （m 和 n 分别是文本串和模式串长度）</p><p>而 KMP 算法的时间复杂度为 <strong>O(m+n)</strong> （匹配和单独生成 next 数组）</p><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP 是由三位学者发明的：Knuth，Morris 和 Pratt，取了三位学者名字的首字母，所以叫做 KMP。</p><p>KMP 主要应用在<strong>字符串匹配</strong>上。</p><p>KMP 的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了</strong>。</p><p><img src="/Algorithm-KMP/1.gif" alt="KMP"></p><p>假设文本串有下标 i，模式串有下标 j。</p><p>可以看到整个 KMP 过程中 i 是不需要回溯的，出现不匹配时 j 会回溯到 next[j-1] 的位置，所以构建 next 是关键。</p><h2 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h2><p>next 数组就是一个前缀表（prefix table），记录下标 i 之前（包括 i）的字符串中，有多大长度的<strong>相同前缀后缀</strong>。</p><p>前缀表是用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配。</p><h3 id="如何计算前缀表"><a href="#如何计算前缀表" class="headerlink" title="如何计算前缀表"></a>如何计算前缀表</h3><p>如图：</p><p><img src="/Algorithm-KMP/2.png"></p><p>长度为前 1 个字符的子串 a，最长相同前后缀的长度为 0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串）</p><p><img src="/Algorithm-KMP/3.png"></p><p>长度为前 2 个字符的子串 aa，最长相同前后缀的长度为 1。</p><p><img src="/Algorithm-KMP/4.png"></p><p>长度为前 3 个字符的子串 aab，最长相同前后缀的长度为 0。</p><p>以此类推：长度为前 4 个字符的子串 aaba，最长相同前后缀的长度为 1。长度为前 5 个字符的子串 aabaa，最长相同前后缀的长度为 2。长度为前 6 个字符的子串 aabaaf，最长相同前后缀的长度为0。</p><p><img src="/Algorithm-KMP/5.png"></p><h3 id="前缀表与-next-数组"><a href="#前缀表与-next-数组" class="headerlink" title="前缀表与 next 数组"></a>前缀表与 next 数组</h3><p>next 数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为 -1）之后作为 next 数组。</p><p>其实这并不涉及到 KMP 的原理，而是具体实现，next 数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为 -1）。</p><h3 id="构造-next-数组"><a href="#构造-next-数组" class="headerlink" title="构造 next 数组"></a>构造 next 数组</h3><p>构造 next 数组主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这是我自己写的不右移也不减一的版本。</p><p>总结就是：i 一直往后走，遇到不匹配，j 去找前一位看看回溯到哪里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-type">string</span>, needle <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// KMP, i 是文本串指针, j 是模式串指针, i 不回溯 </span><br>    j := <span class="hljs-number">0</span><br>    next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(needle))<br>    getNext(next, needle)<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(haystack); i++ &#123;<br>        <span class="hljs-comment">// 匹配到不同字符</span><br>        <span class="hljs-keyword">for</span> haystack[i] != needle[j] &amp;&amp; j &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// j 回溯</span><br>            j = next[j<span class="hljs-number">-1</span>]<br>        &#125;<br><br>        <span class="hljs-comment">// 匹配到相同字符</span><br>        <span class="hljs-keyword">if</span> haystack[i] == needle[j] &#123;<br>            j++<br>            <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle) &#123;<br>                <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 构建 next (不减 1)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNext</span><span class="hljs-params">(next []<span class="hljs-type">int</span>, s <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 初始化, 定义两个指针 i 和 j, j 指向前缀末尾位置, i 指向后缀末尾位置</span><br>    j := <span class="hljs-number">0</span><br>    next[<span class="hljs-number">0</span>] = j<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 前后缀不同</span><br>        <span class="hljs-keyword">for</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j] &#123;<br>            j = next[j<span class="hljs-number">-1</span>]<br>        &#125;<br><br>        <span class="hljs-comment">// 前后缀相同</span><br>        <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>            j++<br>        &#125;<br>        next[i] = j<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只简单介绍了 KMP 算法的流程，但是关于为什么它可以解决字符串匹配的问题，没有详细讨论。感兴趣的话可以参考<a href="https://blog.csdn.net/weixin_52622200/article/details/110563434">这篇文章</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 05. 字符串</title>
    <link href="/Algorithm-string/"/>
    <url>/Algorithm-string/</url>
    
    <content type="html"><![CDATA[<p>字符串相关题目。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>字符串在 Go 语言中是不可变的，这意味着一旦创建了一个字符串，就不能直接修改它的内容。如果需要修改字符串，可以先将其转换为字节数组（[]byte）进行修改，然后再转换回字符串。</p><p>Go 使用的 UTF-8 变长编码，每个字符所占的字节是不一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">utf_8Test</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;英文名为Jamison&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(str)) <span class="hljs-comment">// 19</span><br><span class="hljs-comment">// 四个汉字每个汉字三个字节，其余英文每个一字节</span><br><span class="hljs-comment">// 所以含有一个字节以上的字符不能使用传统 for 循环遍历，应该使用 for range</span><br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> str &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, s) <span class="hljs-comment">// result: 英文名为Jamison</span><br>&#125;<br><br><span class="hljs-comment">// 错误做法</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, str[i]) <span class="hljs-comment">// result: è±æåä¸ºJamison</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对字符串使用 <code>len</code> 方法得到的是字节数不是字符数</p></li><li><p>对字符串直接使用下标访问，得到的是字节而不是字符</p></li><li><p>字符串被 <code>range</code> 遍历时，被解码为 rune 类型的字符</p></li><li><p>UTF-8 编码解码算法位于 <code>runtime/utf8.go</code></p></li></ul><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2 题目"></a>2 题目</h2><h3 id="2-1-leetcode-344-题"><a href="#2-1-leetcode-344-题" class="headerlink" title="2.1 leetcode 344 题"></a>2.1 <a href="https://leetcode.cn/problems/reverse-string/">leetcode 344 题</a></h3><p><strong>原地</strong>修改输入数组，反转字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    left := <span class="hljs-number">0</span><br>    right := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        s[left], s[right] = s[right], s[left]<br>        left++<br>        right--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-剑指-Offer-05"><a href="#2-2-剑指-Offer-05" class="headerlink" title="2.2 [剑指 Offer 05]"></a>2.2 [剑指 Offer 05]</h3><p>把字符串 s 中的每个空格替换成”%20”。</p><p>如果想把这道题目做到极致，首先扩充数组到每个空格替换成”%20”之后的大小，然后双指针法<strong>从后向前</strong>替换空格。</p><p>从前向后填充就是 O(n^2) 的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    b := []<span class="hljs-type">byte</span>(s)<br>    length := <span class="hljs-built_in">len</span>(b)<br>    spaceCount := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 计算空格数量</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> b &#123;<br>        <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            spaceCount++<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 扩展原有切片</span><br>    resizeCount := spaceCount * <span class="hljs-number">2</span><br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, resizeCount)<br>    b = <span class="hljs-built_in">append</span>(b, tmp...)<br>    i := length - <span class="hljs-number">1</span><br>    j := <span class="hljs-built_in">len</span>(b) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> b[i] != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            b[j] = b[i]<br>            i--<br>            j--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            b[j] = <span class="hljs-string">&#x27;0&#x27;</span><br>            b[j<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;2&#x27;</span><br>            b[j<span class="hljs-number">-2</span>] = <span class="hljs-string">&#x27;%&#x27;</span><br>            i--<br>            j = j - <span class="hljs-number">3</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-leetcode-151-题"><a href="#2-3-leetcode-151-题" class="headerlink" title="2.3 leetcode 151 题"></a>2.3 <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">leetcode 151 题</a></h3><p>翻转字符串里的单词，不使用辅助空间，空间复杂度要求为 O(1)：</p><ol><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    fast, slow := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    b := []<span class="hljs-type">byte</span>(s)<br>    lens := <span class="hljs-built_in">len</span>(b)<br><br>    <span class="hljs-comment">// top sp</span><br>    <span class="hljs-keyword">for</span> ; fast &lt; lens; fast++ &#123;<br>        <span class="hljs-keyword">if</span> b[fast] != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>           <span class="hljs-keyword">break</span> <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// mid sp</span><br>    <span class="hljs-keyword">for</span> ; fast &lt; lens; fast++ &#123;<br>        <span class="hljs-keyword">if</span> fast<span class="hljs-number">-1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; b[fast]==<span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; b[fast<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        b[slow] = b[fast]<br>        slow++<br>    &#125;<br><br>    <span class="hljs-comment">// end sp</span><br>    <span class="hljs-keyword">if</span> b[slow<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>        b = b[:slow<span class="hljs-number">-1</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        b = b[:slow]<br>    &#125;<br>    <br>    reverseStr(b, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(b)<span class="hljs-number">-1</span>)<br><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; j &lt;= <span class="hljs-built_in">len</span>(b); j++ &#123;<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(b) &#123;<br>            reverseStr(b, i, <span class="hljs-built_in">len</span>(b)<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> b[j] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            reverseStr(b, i, j<span class="hljs-number">-1</span>)<br>            i = j + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseStr</span><span class="hljs-params">(b []<span class="hljs-type">byte</span>, begin <span class="hljs-type">int</span>, end <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, j := begin, end; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        (b)[i], (b)[j] = (b)[j], (b)[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：在 Go 中，字符串是不可变的，也就是说无法直接通过下标操作来修改字符串的内容。因此，无法直接通过下标操作来实现字符串的反转。要反转字符串，可以将字符串转换为字节数组（[]byte）。</p><h3 id="2-4-leetcode-3-题"><a href="#2-4-leetcode-3-题" class="headerlink" title="2.4 leetcode 3 题"></a>2.4 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">leetcode 3 题</a></h3><p>无重复字符的最长子串。</p><p>滑动窗口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">int</span>) &#123;<br>    b := []<span class="hljs-type">byte</span>(s)<br>    bmap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(b); j++ &#123;<br>        bmap[b[j]]++<br>        <span class="hljs-keyword">if</span> bmap[b[j]] &gt; <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> bmap[b[i]] != bmap[b[j]] &#123;<br>                bmap[b[i]]--<br>                i++<br>            &#125;<br>            bmap[b[i]]--<br>            i++<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j-i+<span class="hljs-number">1</span>) &gt; res &#123;<br>            res = j-i+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 04. 哈希表</title>
    <link href="/Algorithm-hash/"/>
    <url>/Algorithm-hash/</url>
    
    <content type="html"><![CDATA[<p>哈希表相关题目。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>哈希表（Hash table）用来快速判断一个元素是否出现集合里。</p><h3 id="1-1-哈希函数"><a href="#1-1-哈希函数" class="headerlink" title="1.1 哈希函数"></a>1.1 哈希函数</h3><p>比如把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。哈希函数通过 hashCode 把名字转化为数值，一般 hashCode 是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img src="/Algorithm-hash/1.png"></p><h3 id="1-2-哈希碰撞"><a href="#1-2-哈希碰撞" class="headerlink" title="1.2 哈希碰撞"></a>1.2 哈希碰撞</h3><p>如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。</p><p><img src="/Algorithm-hash/2.png"></p><ul><li><p><strong>拉链法</strong></p><p>  刚刚小李和小王在索引 1 的位置发生了冲突，发生冲突的元素都被存储在链表中，这样我们就可以通过索引找到小李和小王了。</p><p>  <img src="/Algorithm-hash/3.png"></p><p>  数据规模是 dataSize， 哈希表的大小为 tableSize。</p></li><li><p><strong>线性探测法</strong></p><p>  使用线性探测法，一定要保证 tableSize 大于 dataSize。我们需要依靠哈希表中的空位来解决碰撞问题。例如冲突的位置放了小李，那么就向下找一个空位放置小王的信息。</p></li></ul><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2 题目"></a>2 题目</h2><h3 id="2-1-字母异位词"><a href="#2-1-字母异位词" class="headerlink" title="2.1 字母异位词"></a>2.1 <a href="https://leetcode.cn/problems/valid-anagram/">字母异位词</a></h3><p>给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram1</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">var</span> c1, c2 [<span class="hljs-number">26</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br>        c1[ch-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> t &#123;<br>        c2[ch-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br>    <span class="hljs-keyword">return</span> c1 == c2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram2</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    cnt := <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br>        cnt[ch]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> t &#123;<br>        cnt[ch]--<br>        <span class="hljs-keyword">if</span> cnt[ch] &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-快乐数"><a href="#2-2-快乐数" class="headerlink" title="2.2 快乐数"></a>2.2 <a href="https://leetcode.cn/problems/happy-number/">快乐数</a></h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    resMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> resMap[n] == <span class="hljs-literal">false</span> &#123;<br>        <span class="hljs-keyword">if</span> sqSum(n) == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        resMap[n] = <span class="hljs-literal">true</span><br>        n = sqSum(n)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqSum</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>        sum += (n%<span class="hljs-number">10</span>) * (n%<span class="hljs-number">10</span>)<br>        n /= <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-两数之和"><a href="#2-3-两数之和" class="headerlink" title="2.3 两数之和"></a>2.3 <a href="https://leetcode.cn/problems/two-sum/">两数之和</a></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> index, val := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> preIndex, ok := m[target-val]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;preIndex, index&#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m[val] = index<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-三数之和"><a href="#2-4-三数之和" class="headerlink" title="2.4 三数之和"></a>2.4 <a href="https://leetcode.cn/problems/3sum/">三数之和</a></h3><p>给你一个整数数组 nums，判断是否存在三元组满足 <code>nums[i] + nums[j] + nums[k] == 0</code>。请你返回所有和为 0 且不重复的三元组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>; i++ &#123;<br>        left, right := i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <br>        target := -nums[i]<br>        <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>        <span class="hljs-keyword">for</span> left &lt; right &#123;<br>            <span class="hljs-keyword">if</span> nums[left] + nums[right] &gt; target &#123;<br>                right--<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[left] + nums[right] &lt; target &#123;<br>                left++<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = <span class="hljs-built_in">append</span>(res, []<span class="hljs-type">int</span>&#123;nums[i], nums[left], nums[right]&#125;)<br>                left++<br>                right--<br>                <span class="hljs-comment">// Skip duplicates</span><br>                <span class="hljs-keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left<span class="hljs-number">-1</span>] &#123;<br>                    left++<br>                &#125;<br>                <span class="hljs-keyword">for</span> left &lt; right &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>] &#123;<br>                    right--<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>此题使用哈希表去重非常困难，建议使用双指针。</p><h3 id="2-5-四数之和"><a href="#2-5-四数之和" class="headerlink" title="2.5 四数之和"></a>2.5 <a href="https://leetcode.cn/problems/4sum-ii/">四数之和</a></h3>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(09)：分布式定时任务</title>
    <link href="/ByteDance-9/"/>
    <url>/ByteDance-9/</url>
    
    <content type="html"><![CDATA[<p>自动化 + 定时执行 + 海量数据 + 高效稳定 &#x3D; 分布式定时任务</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>定时任务是指系统为了<strong>自动</strong>完成特定任务，<strong>实时、延时、周期性</strong>完成任务调度的过程。</p><p>分布式定时任务是把分散的、可靠性差的定时任务纳入统一的平台，并实现集群管理调度和<strong>分布式部署</strong>的一种定时任务的管理方式。</p><p><strong>按触发时机分类</strong>：</p><ul><li>定时任务：特定时间触发，比如今天 15:06 执行</li><li>延时任务：延时触发，比如 10s 后执行</li><li>周期任务：固定周期时间，或固定频率周期调度触发，比如每隔 5s 或者每天 12 点执行</li></ul><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul><li>自动化：全自动完成定时任务的调度和执行</li><li>平台化：基于平台化的思维管控一系列的分布式定时任务</li><li>分布式：在分布式系统环境下运行任务调度，突破单机定时任务的性能瓶颈</li><li>伸缩性：采用集群方式部署，可以随时按需扩缩容</li><li>高可用：单点故障不影响最终任务结果，可以做到故障转移</li></ul><h3 id="1-2-执行模式"><a href="#1-2-执行模式" class="headerlink" title="1.2 执行模式"></a>1.2 执行模式</h3><ul><li>单机任务：随机触发一台机器执行任务，适用于计算量小、并发度低的任务</li><li>广播任务：广播到所有机器上执行同一个任务，比如所有机器一起清理日志</li><li>Map 任务：一个任务可以分出多个子任务，每个子任务负责一部分的计算。适用于计算量大，单机无法满足要求的任务</li><li>MapReduce 任务：在 Map 任务的基础上，还可以对所有子任务的结果做汇总计算，适用于计算量大，并且需要对子任务结果做汇总的任务</li></ul><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2 实现原理"></a>2 实现原理</h2><h3 id="2-1-核心架构"><a href="#2-1-核心架构" class="headerlink" title="2.1 核心架构"></a>2.1 核心架构</h3><p>分布式定时任务核心要解决<strong>触发、调度、执行</strong>三个关键问题。</p><p><img src="/ByteDance-9/1.png"></p><ul><li>触发器（Trigger）：解析任务，生成触发事件</li><li>调度器（Scheduler）：分配任务，管理任务生命周期</li><li>执行器（Executor）：获取执行任务单元，执行任务逻辑</li><li>控制台（Admin）：提供任务管理和干预的功能。</li></ul><h3 id="2-2-数据流"><a href="#2-2-数据流" class="headerlink" title="2.2 数据流"></a>2.2 数据流</h3><p><img src="/ByteDance-9/2.png"></p><h3 id="2-3-控制台"><a href="#2-3-控制台" class="headerlink" title="2.3 控制台"></a>2.3 控制台</h3><p><img src="/ByteDance-9/3.png"></p><ul><li>任务：Job，任务元数据</li><li>任务实例：Joblnstance，周期任务会生成多个任务实例</li><li>任务结果：JobResult，任务实例运行的结果</li><li>任务历史：JobHistory，用户可以修改任务信息，任务实例对应的任务元数据可以不同，因而使用任务历史存储</li></ul><h3 id="2-4-触发器"><a href="#2-4-触发器" class="headerlink" title="2.4 触发器"></a>2.4 触发器</h3><p>给定一系列任务，解析它们的触发规则，在规定的时间点触发任务的调度</p><p><strong>方案一</strong>：定期扫描 + 延时消息（腾讯、字节方案）</p><p><img src="/ByteDance-9/4.png"></p><p><strong>方案二</strong>：时间轮（Quartz所用方案）</p><p><img src="/ByteDance-9/5.png"></p><p>时间轮是一个存储环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表。</p><p><img src="/ByteDance-9/6.png"><br><img src="/ByteDance-9/7.png"><br><img src="/ByteDance-9/8.png"><br><img src="/ByteDance-9/9.png"></p><h3 id="2-5-调度器"><a href="#2-5-调度器" class="headerlink" title="2.5 调度器"></a>2.5 调度器</h3><h4 id="2-5-1-节点选择"><a href="#2-5-1-节点选择" class="headerlink" title="2.5.1 节点选择"></a>2.5.1 节点选择</h4><ul><li>随机节点执行：选择集群中一个可用的执行节点执行调度任务。适用场景：定时对账。</li><li>广播执行：在集群中所有的执行节点分发调度任务并执行。适用场景：批量运维。</li><li>分片执行：按照用户自定义分片逻辑进行拆分，分发到集群中不同节点并行执行，提升资源利用效率。适用场景：海量日志统计。</li></ul><h4 id="2-5-2-任务分片"><a href="#2-5-2-任务分片" class="headerlink" title="2.5.2 任务分片"></a>2.5.2 任务分片</h4><p>通过任务分片来提高任务执行的效率和资源的利用率。</p><p><img src="/ByteDance-9/10.png"></p><h4 id="2-5-3-任务编排"><a href="#2-5-3-任务编排" class="headerlink" title="2.5.3 任务编排"></a>2.5.3 任务编排</h4><p>使用有向无环图 DAG(Directed Acyclic Graph) 进行可视化任务编排。</p><h4 id="2-5-4-故障转移"><a href="#2-5-4-故障转移" class="headerlink" title="2.5.4 故障转移"></a>2.5.4 故障转移</h4><p>分片任务基于一致性 hash 策略分发任务，当某 Executor 异常时，调度器会将任务分发到其他 Executor。</p><h4 id="2-5-5-高可用"><a href="#2-5-5-高可用" class="headerlink" title="2.5.5 高可用"></a>2.5.5 高可用</h4><p>调度器可以集群部署，做到完全的无状态，靠消息队列的重试机制保障任务一定会被调度。</p><h3 id="2-6-执行器"><a href="#2-6-执行器" class="headerlink" title="2.6 执行器"></a>2.6 执行器</h3><p><img src="/ByteDance-9/11.png"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Utilizing Parallelism in Smart Contracts on Decentralized Blockchains by Taming Application-Inherent Conflicts</title>
    <link href="/Paper-Taming-Conflicts/"/>
    <url>/Paper-Taming-Conflicts/</url>
    
    <content type="html"><![CDATA[<p>区块链系统随着共识技术的发展，性能已经大大提高，交易执行成为一个新的性能瓶颈。我们观察到应用内在的冲突是限制并行执行的主要因素。本文提出使用<strong>分区计数器</strong>和特殊的<strong>可交换指令</strong>来打破应用程序冲突链，以最大化性能。我们还提出了 <strong>OCC-DA</strong>，一个具有确定性中止的乐观并发控制调度器，使得在<strong>公链</strong>中使用 OCC 调度成为可能。</p><span id="more"></span><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>为了了解现有交易工作负载中可以利用的并行度，本文实证研究了一段历史以太坊交易。我们的发现：</p><ol><li>与串行执行相比，并行可实现的总体加速限制约为 4 倍。虽然有许多块的执行速度随着线程数量的增加而增大，但很大一部分块的执行情况要差得多。</li><li>大多数块都被单个交易依赖链所阻塞，这些交易需要串行执行，因此影响了总体的执行时间。</li><li>对瓶颈交易的人工检查显示，它们中的大多数在单个计数器或数组上发生冲突。从应用程序的角度来看，大多数瓶颈交易可以分为三类：代币分发、收藏品和去中心化金融。</li></ol><p>研究结果表明，我们工作的重点应该是消除智能合约中这些常见的争用源，而不是优化调度器的实现。本文提出了三种独立的技术来消除上述瓶颈：</p><ol><li><p>最简单方法是使用多个发送方地址。手动将单个发送方的一组交易划分为多个不相交的交易集。</p></li><li><p>第二种方法是使用分区计数器（partitioned counters），类似于 Sloppy Counters。在这种方法中，我们维护几个子计数器，它们的总和构成原始计数器的值。写入基于某些属性（例如发送方地址）被路由到不同的子计数器并在其上操作。分区计数器可以减少任何两个写入交易冲突的概率。</p></li><li><p>第三种方法是消除由虚拟机级别的交换更新引起的可避免冲突。两个增加计数器但不使用其原始值的交易在语义上是可交换的。然而，在当前的以太坊虚拟机语义下，这些增量被转换为读取（SLOAD）和写入（SSTORE）指令，这将导致读写冲突。我们提出了一个名为 CADD（commutative add）的新指令。在给定状态条目上没有其他读写操作，而只有 CADD 操作的两个交易被视为不冲突。增量在交易提交期间逐个应用。</p></li></ol><p>上述方案可以达到 18 倍以上的提速。此外，为了解决并行执行导致节点状态不一致问题，我们引入了一种具有确定性事务中止的乐观调度器。这种方法允许我们引入并行性的激励措施，以换取可接受的性能影响。</p><h2 id="2-BACKGROUND-AND-MOTIVATION"><a href="#2-BACKGROUND-AND-MOTIVATION" class="headerlink" title="2 BACKGROUND AND MOTIVATION"></a>2 BACKGROUND AND MOTIVATION</h2><p>为了解决 Bitcoin 和 Ethereum 的性能瓶颈，大家都做了很多努力。</p><p>在并行执行研究上，通过调查以太坊的历史工作负载，我们发现必须按顺序执行的一系列交易的许多关键路径都是由<strong>共享全局计数器</strong>的使用引起的。我们认为，进一步提高实际工作负载并行性的重要方法是引入更好的编程范式，使开发人员能够更容易地表达并行性，同时保持原始语义。并且需要对激励机制进行一些新的设计，以使该范式适用于现实世界的应用。</p><h2 id="3-EMPIRICAL-STUDY"><a href="#3-EMPIRICAL-STUDY" class="headerlink" title="3 EMPIRICAL STUDY"></a>3 EMPIRICAL STUDY</h2><h3 id="3-1-Methodology"><a href="#3-1-Methodology" class="headerlink" title="3.1 Methodology"></a>3.1 Methodology</h3><p>我们使用以太坊历史交易对现实世界数据集（2018 年 1 月 1 日到 2018 年 5 月 28 日共 8582236 个区块）中存在的并行性进行了实证研究。本实验的主题是智能合约存储冲突，即同一块内的两个交易访问状态树中的同一条目，并且这些访问中至少有一个是写入。</p><p>考虑到交易的执行时间是未知的，并且可能因节点而异，我们使用从交易收据中获得的 gas 成本作为近似值。</p><p>从交易的状态访问跟踪和 gas 成本导出的依赖性，我们为每个块构建了一个依赖图。然后，模拟在 2、4、8、16 和 32 个线程上的非抢占式执行，我们为每个块构建了一个最优调度。确保不需要中止任何交易的调度，同时最大限度地提高线程利用率。在这种执行模型下，该计划的总体执行成本为我们能够实现的潜在加速设定了上限。</p><h3 id="3-2-Results-and-Findings"><a href="#3-2-Results-and-Findings" class="headerlink" title="3.2 Results and Findings"></a>3.2 Results and Findings</h3><ul><li><p><em>Execution Bottlenecks.</em> 该实验揭示了我们在并行执行以太坊交易时可以实现的加速限制。我们发现，与串行执行相比，观察到的总体加速仅为 4 倍，考虑到我们有 8 个、16 个甚至更多的线程可用，这一结果并不令人满意。许多区块的加速效率很高，但也有相当一部分区块的性能很差。</p><p>  <img src="/Paper-Taming-Conflicts/1.png" alt="Distribution of parallel speedup bounds"></p><p>  将一个块的执行成本与其依赖图中最重路径的执行成本进行比较时，我们发现这两者经常重合，这意味着性能瓶颈在最重路径的执行上。这往往是块中的某一笔交易，而我们想解决的是两笔或更多交易之间的瓶颈冲突链。所以我们又进行了一次实验，以 30 个块为一批并行执行。这相比串行执行速度提高了 9.46 倍，我们观察到：瓶颈通常在几十个或几百个依赖交易所组成的单个依赖链。</p></li><li><p><em>Classification of Smart Contract Conflicts.</em> 我们确定了三大类：ERC20 代币（代币分发、空投）占样本瓶颈的 60%，去中心化金融（DeFi）应用程序占 29%，而游戏和收藏品（不可替代代币、NFT）占 10%。</p></li><li><p><em>Bottleneck Code Examples.</em></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs code">function transfer(address _to , uint256 _val) /* ... */ &#123;<br>    balances[msg.sender] -= _val ; // &lt;&lt;&lt;<br>    balances[_to] += _val ;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用 transfer 时，发送者的余额被记 debited，而接收者的余额被记 credited。发送方的余额对应于状态树中的一个特定存储位置。借记操作将编译为加载（SLOAD）、添加（ADD）和存储（SSTORE）操作等。当两个交易同时从同一个发送方地址触发此函数时，将导致冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs code">function _createKitty(/* ... */) /* ... */ &#123;<br>    uint256 newKittenId = kitties.push(_kitty) - 1; // &lt;&lt;&lt;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在以太坊流行的 CryptoKitties 游戏中，每个新的收藏品都存储在一个数组中。Solidity 数组上的 push 操作将修改两个存储条目：首先，它将把新项目存储在从数组长度导出的位置，其次，它将增加数组长度。两个并发交易都会修改数组长度，因此它们会发生冲突。</p><h3 id="3-3-Generalizability-of-the-Observations"><a href="#3-3-Generalizability-of-the-Observations" class="headerlink" title="3.3 Generalizability of the Observations"></a>3.3 Generalizability of the Observations</h3><p>我们相信所选择的时间段代表了当今以太坊的工作量，因此我们的发现是普遍的。</p><h2 id="4-AVOIDING-APPLICATION-INHERENT-CONFLICTS"><a href="#4-AVOIDING-APPLICATION-INHERENT-CONFLICTS" class="headerlink" title="4 AVOIDING APPLICATION INHERENT CONFLICTS"></a>4 AVOIDING APPLICATION INHERENT CONFLICTS</h2><p>由第三章可以看出，很大一部分存储冲突与计数器或数组的存储槽相关联。这里所说的计数器（counter）是指一个变量，无论其当前值如何，都可以通过递增或递减来跟踪一个量。Solidity 中的数组（Arrays）是一种简单的数据结构，用于存储元素序列和元素数量。</p><p>为了减轻交易瓶颈链的影响，我们需要通过消除所涉及的交易子集之间的依赖关系，将它们分解为多个较短的链：</p><p><img src="/Paper-Taming-Conflicts/2.png" alt="Breaking up a conflict chain into multiple disjoint conflict chains"></p><ul><li><p><em><strong>Technique 1: Conflict-Aware Token Distribution.</strong></em> 我们发现代币分发是迄今为止瓶颈冲突最常见的来源。在大多数情况下，冲突的来源是存储发送者帐户当前余额的条目。</p><p>  最简单方法是使用多个发送者地址。通过将初始资金（在适用的情况下）分配给一组发送方账户，而不是单个账户，并对连续的交易使用不同的发送方地址，我们可以将瓶颈交易集划分为不相交的冲突交易集，每个交易集都不太可能形成瓶颈。</p></li><li><p><em><strong>Technique 2: Partitioned Counters.</strong></em> 使用一种类似于 Linux 内核中 sloppy counters 的技术，我们提出了一种将同一计数器上的多个写入路由到多个不同存储条目的方法。由于对不同存储条目的写入不会发生冲突，因此可以大幅降低冲突率。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs code">contract PartitionedCounter &#123; // LEN = 3<br>    int256[LEN] public cnt;<br><br>    function add(uint32 n) internal &#123;<br>        uint8 slot = uint8(tx.origin) % LEN<br>        cnt[slot] += n;<br>    &#125;<br><br>    function get() internal view returns (int256 sum) &#123;<br>        for (uint8 i = 0; i &lt; LEN; ++i) &#123;sum += cnt[i];&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里我们有一个单独的合约，它代表一个计数器实例。计数器的值实际上保存在 3 个称为子计数器的独立存储条目上。每次交易修改计数器的值时，我们都会根据发送方地址分配一个子计数器。由于地址是使用加密哈希导出的，因此可以将其视为伪随机子计数器分配。读取计数器的值时，将访问所有子计数器，并对其值进行求和。</p><p>  给定交易的写入操作即使多次递增计数器也都将在单个存储条目上进行，因为在整个交易执行过程中，发送方地址不会更改。来自两个不同发送方地址的两个交易都增加了计数器，但在同一子计数器上操作的机会大大减少，因此通常可以避免冲突。也可以根据计数器使用频率分派不同的子计数器数量和路由规则（本例是根据发送方地址）。</p><p>  此方案的缺点在于虽然我们只需要访问一个存储条目来写入计数器，但读取它将涉及到所有子计数器。因此，任何读取计数器的交易都将与所有写入交易发生冲突。因此，这种技术适用于 write-heavy 计数器。幸运的是，我们分析的许多计数器从来都不是通过交易读取的。其次，分区计数器可能比内置整数开销大得多，尤其是在读取计数器时。分区计数器提供的并行加速抵消了这一缺点。</p></li><li><p><em><strong>Technique 3: Commutative EVM Instructions.</strong></em> 我们已经讨论了两种方法。一种是在应用程序级别，通过引入与应用程序交互的特定方式来解决冲突。另一种是在智能合约层面上，通过向合约开发人员提供工具来避免冲突。第三种方法是通过使用具有更好的冲突容忍度的新指令来扩展协议，从而在虚拟机级别上解决冲突。</p><p>  当以太坊虚拟机（EVM）执行增量操作时，它首先将存储条目的当前值加载到内存中（SLOAD），然后修改该值（ADD），最后将最终结果存储回存储条目中（SSTORE）。两个交易递增同一计数器将同时读取和写入同一存储条目，因此它们将发生冲突。</p><p>  对于计数器增量，当前值仅用于计算新值，所以与其他读写冲突不同，增量是可交换的（commutative），即递增同一计数器但不使用其值的两个交易可以按任何顺序执行。然而，在 EVM 的当前语义下，这样的交易将发生冲突。</p><p>  我们引入了特殊的语义，用于以不会导致冲突的方式执行增量。将增量编译成一条代表交换加法的 CADD 指令，而不是编译成 SSLOAD 和 SSTORE 指令。此指令以一个存储位置和一个值作为其参数。当虚拟机遇到 CADD 指令时，它不会立即执行加法，而是将此操作记录在内存临时存储器中。如果虚拟机遇到 SSTORE 操作，则会移除同一存储位置上挂起的 CADD 指令，因为它们已经被覆盖。如果虚拟机遇到 SLOAD 操作，它将首先在同一存储位置上执行所有挂起的 CADD 操作，然后将结果用于此 SLOAD。</p><p>  在交易被执行之后，调度程序继续检查冲突。对同一存储位置的并发读取和写入构成冲突，但是如果两个交易在一个存储位置上只有 CADD 操作，而没有其他读取操作，则不认为它们有冲突。在这种情况下，这些 CADD 操作是在提交阶段是串行执行的。引入 CADD 指令以向 VM 发送交换操作的信号，使我们能够避免源自单个计数器上的主要交易冲突。</p></li></ul><h2 id="5-OCC-WITH-DETERMINISTIC-ABORTS"><a href="#5-OCC-WITH-DETERMINISTIC-ABORTS" class="headerlink" title="5 OCC WITH DETERMINISTIC ABORTS"></a>5 OCC WITH DETERMINISTIC ABORTS</h2><h3 id="5-1-Incentives-in-Parallel-Scheduling"><a href="#5-1-Incentives-in-Parallel-Scheduling" class="headerlink" title="5.1 Incentives in Parallel Scheduling"></a>5.1 Incentives in Parallel Scheduling</h3><p>并行调度器的效率取决于各种因素，其中一些因素在用户的控制之下。因此，并行执行必须有一套激励措施，以最大限度地提高其有效性。这种激励制度的详细设计超出了本文的范围。</p><p>基于 OCC 的并行执行不可避免地会导致一些事务中止和重新执行。如果允许用户在没有任何惩罚的情况下故意触发中止，就会导致调度器的 DoS 漏洞。因此，我们的目标是定义一个执行框架，允许调度器通过对交易的重新执行进行确定性定价。</p><h3 id="5-2-Levels-of-Determinism"><a href="#5-2-Levels-of-Determinism" class="headerlink" title="5.2 Levels of Determinism"></a>5.2 Levels of Determinism</h3><p>因为交易的精确时间可能因节点而异，并行调度器在执行中引入了一定程度的非确定性。这与共识机制依赖于节点严格收敛到相同状态的要求直接冲突。因此区块链系统与传统算法相比，并行调度器必须保持更高水平的确定性。我们在乐观事务执行中定义了以下三个确定性级别：</p><ol><li><p><strong>Classic OCC</strong>： first-come-first-served 的执行方式。没有确定性保证，交易在执行完后立即提交，不考虑其在区块中的顺序，不同节点最终结果可能不一致。</p></li><li><p><strong>OCC with deterministic commit order</strong>：交易的提交操作会延迟到区块中前一个交易提交后。这意味着不同节点上的最终执行结果将是相等的，即使实际执行顺序可能不同。通过严格按照块交易顺序提交，或者根据依赖图进行调度，可以满足这一要求。</p></li><li><p><strong>OCC with deterministic aborts</strong>：交易只能看到在执行之前决定的状态版本（即使有更新的版本可用）。交易的每次执行都将在所有节点上提交或中止。虽然确定性顺序保证所有节点的可观察输出（结果状态）相同，但实际执行可能仍然不同：由于交易的时间不同，交易可能在一个节点上提交，而在另一个节点则中止。如果协议依赖于此提交&#x2F;中止决定来惩罚中止并避免 DoS 攻击，这将导致不同的状态。所以我们的目标是中止本身具有确定性：如果交易在一个节点上中止一次，那么在所有其他节点上也会中止一次。</p></li></ol><h3 id="5-3-OCC-DA-OCC-with-Deterministic-Aborts"><a href="#5-3-OCC-DA-OCC-with-Deterministic-Aborts" class="headerlink" title="5.3 OCC-DA: OCC with Deterministic Aborts"></a>5.3 OCC-DA: OCC with Deterministic Aborts</h3><p>我们的执行模型基于快照隔离（snapshot isolation）的 OCC。交易被安排在一组线程上执行，已执行的交易是根据块交易顺序提交的。在执行开始时，每个交易都会接收对应于存储版本的快照，此快照在交易执行过程中不会更改。</p><p>例如，假设交易 #1 已经被提交，交易 #2 正在一个线程上执行，而我们正在另一个线程调度交易 #3。在这种情况下，#3 可以看到存储版本 #1（直到并包括 #1 的写入的存储内容）。如果在 #3 的执行过程中，#2 修改了一些存储值，那么这些更新对 #3 来说是不可见的。如果在 #3 的提交期间，调度器检测到 #3 读取的一些值被 #2 同时修改，即 #3 对过时的值进行了操作，#3 将中止并被重新执行。</p><p><strong>OCC-DA 定义如下</strong>：<br>在执行之前，我们为每个交易的每次执行分配一个存储版本（storage version）：<code>(𝑡𝑥𝑛,𝑖) → 𝑠𝑣𝑛,𝑖</code>。<code>(𝑡𝑥𝑛,𝑖)</code> 代表 𝑖 次执行交易 #n，其中 𝑖 &#x3D; 0, 1, 2, … 根据调度程序的实现，交易可以执行两次或多次。最后一次执行必须提交，而之前的所有执行都将中止。对于在执行单元中（例如在块中）的所有交易 #n 的所有可能的执行，<code>𝑠𝑣𝑛,𝑖</code> 在所有节点上统一定义，并且在执行之前进行定义，从而不受不确定性的执行影响。对于任何 <code>(𝑡𝑥𝑛,𝑖)</code>, 交易 #n 将在所有节点上中止或提交。</p><p>在 <code>(𝑡𝑥𝑛,𝑖)</code> 执行过程中, 调度程序必须允许交易访问 <code>𝑠𝑣𝑛,𝑖</code> 之前且包括此交易写入的存储条目。调度程序不得允许交易访问由 id 高于 <code>𝑠𝑣𝑛,𝑖</code> 的交易写入的存储条目。如果 <code>𝑠𝑣𝑛,𝑖</code> 尚未提交，交易无法开始执行，必须等待。</p><h3 id="5-4-Example"><a href="#5-4-Example" class="headerlink" title="5.4 Example"></a>5.4 Example</h3><p>有 4 笔交易，标记为 #1 到 #4。#1 和 #3 存在存储冲突：#1 写入由 #3 读取的存储条目。然后，让我们在不同的决定论保证下，在两个不同的节点上调度这四个交易，每个节点有2个线程。</p><p><img src="/Paper-Taming-Conflicts/3.png" alt="三个级别"></p><ul><li><p>左图是使用经典 OCC 的调度示例。这种方法没有确定性的保证。特别地，我们可以看到节点 A 上的提交顺序是 #1-#2-#3-#4，而节点B上是 #3-#2-#1-#4。两个冲突交易的不同相对顺序（#1-#3，#3-#1）可能导致两个节点的状态不一致。虽然 #1 和 #3 冲突，但在本例中，它们不是同时执行的，因此都不需要中止。</p></li><li><p>中间的图中，我们看到了一个具有确定性提交顺序的 OCC 示例。在节点 B 上，#3 在 #1 之前完成执行，此时检测到冲突并中止 #3，直到 #1 完成之后才提交。节点 A 和 B 上的最终提交顺序是 #1-#2-#3-#4。由于 #1 和 #3 在两个节点上执行的相对顺序不同，#3 的第一次执行在节点 A 上提交，而在节点 B 上中止。在分布式共识中，这种不确定性是不可接受的。</p></li><li><p>右图显示了 OCC-DA 的工作原理。在执行之前，所有节点都决定 #3 的第一次执行只能读取 #1 执行之前的状态 (<code>𝑠𝑣3,0 := 0</code>)，而第二次执行可以看到 #2 之后的状态 (<code>𝑠𝑣3,1 := 2</code>)。因此，即使在节点 A 中 #3 被安排的 #1 之后，它无法获得 #1 的写入并将中止。这与节点 B 上 #3 与 #1 同时执行的结果一致。第二次执行 #3 将在节点 A 和 B 上获得最新状态，因此它将在两个节点上提交。</p></li></ul><h3 id="5-5-Assigning-Storage-Versions"><a href="#5-5-Assigning-Storage-Versions" class="headerlink" title="5.5 Assigning Storage Versions"></a>5.5 Assigning Storage Versions</h3><p>依赖两种信息：</p><ul><li>首先，我们可以使用交易的预期执行时间来查找交易预期读取的最新存储版本。假如 #3 将在 #1 之后但在 #2 之前开始执行，我们设置 <code>𝑠𝑣3,0 := 1</code>。</li><li>其次，我们通过对事务依赖关系图的估计来允许预防中止。例如，如果我们猜测 #3 可能与 #1 冲突，那么我们可以设置 <code>𝑠𝑣3,0 &gt;= 1</code>。</li></ul><p>存储版本分配的准确性直接影响并行调度程序的性能：如果我们使用的存储版本太低，那么我们就有可能引入更多的中止。如果我们使用的存储版本太高，那么交易可能需要一直等待存储版本可用，从而导致线程利用率不足。</p><h3 id="5-6-The-Algorithm"><a href="#5-6-The-Algorithm" class="headerlink" title="5.6 The Algorithm"></a>5.6 The Algorithm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Algorithm">Input: Transactions 𝑇, gas 𝐺𝑎𝑠, number of threads 𝑡, none or a dependency graph 𝐷<br><br>𝐻𝑡𝑥𝑠 ← an empty minheap of (𝑠𝑣, 𝑖𝑑) ;<br>for 𝑖𝑑 ∈ [0, |𝑇|) do<br>    if 𝐷 exists then<br>        𝑖𝑑𝑚𝑎𝑥 ← −1 ;<br>        for edge (𝑖𝑑, 𝑖𝑑𝑝𝑟𝑒𝑣) ∈ 𝐷 do<br>            //tx_𝑖𝑑 depends on tx_𝑖𝑑𝑝𝑟𝑒𝑣<br>            //tx_𝑖𝑑 reads what tx_𝑖𝑑𝑝𝑟𝑒𝑣 writes<br>            𝑖𝑑𝑚𝑎𝑥 ← 𝑚𝑎𝑥(𝑖𝑑𝑚𝑎𝑥, 𝑖𝑑𝑝𝑟𝑒𝑣) ;<br>        𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((𝑖𝑑𝑚𝑎𝑥, 𝑖𝑑)) ;<br>    else<br>        𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((−1, 𝑖𝑑)) ;<br><br>𝐻𝑟𝑒𝑎𝑑𝑦 ← an empty minheap of (𝑖𝑑, 𝑠𝑣) ;<br>𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠 ← an empty minheap of (𝑔𝑎𝑠, 𝑖𝑑, 𝑠𝑣) ;<br>𝐻𝑐𝑜𝑚𝑚𝑖𝑡 ← an empty minheap of (𝑖𝑑, 𝑠𝑣) ;<br>𝑛𝑒𝑥𝑡 ← 0 ;<br><br>while 𝑛𝑒𝑥𝑡 &lt; |𝑇| do<br>    //Stage 1 : Schedule<br>    for (𝑠𝑣, 𝑖𝑑) ← 𝐻𝑡𝑥𝑠.𝑝𝑜𝑝() do<br>        if 𝑠𝑣 &gt; 𝑛𝑒𝑥𝑡 − 1 then<br>            𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((𝑠𝑣, 𝑖𝑑)) ;<br>            break<br>        else<br>            𝐻𝑟𝑒𝑎𝑑𝑦.𝑝𝑢𝑠ℎ((𝑖𝑑, 𝑠𝑣)) ;<br>    while |𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠| &lt; 𝑝𝑜𝑜𝑙_𝑠𝑖𝑧𝑒 and |𝐻𝑟𝑒𝑎𝑑𝑦| &gt; 0 do<br>        (𝑖𝑑, 𝑠𝑣) ← 𝐻𝑟𝑒𝑎𝑑𝑦.𝑝𝑜𝑝 () ;<br>        𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠.𝑝𝑢𝑠ℎ((𝐺𝑎𝑠[𝑖𝑑], 𝑖𝑑, 𝑠𝑣)) ;<br>    //Stage 2 : Execution<br>    if |𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠| &gt; 0 then<br>        (𝑔𝑎𝑠, 𝑖𝑑, 𝑠𝑣) ← 𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠.𝑝𝑜𝑝 () ;<br>        𝐻𝑐𝑜𝑚𝑚𝑖𝑡 ← (𝑖𝑑, 𝑠𝑣) ;<br>        for 𝑖 ∈ [0, |𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠|) do<br>            𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠[𝑖].𝑔𝑎𝑠 ← 𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠[𝑖].𝑔𝑎𝑠 − 𝑔𝑎𝑠 ;<br>    //Stage 3 : Commit/Abort<br>    while |𝐻𝑐𝑜𝑚𝑚𝑖𝑡| &gt; 0 do<br>        (𝑖𝑑, 𝑠𝑣) ← 𝐻𝑐𝑜𝑚𝑚𝑖𝑡.𝑝𝑜𝑝() ;<br>        if 𝑖𝑑 ≠ 𝑛𝑒𝑥𝑡 then<br>            𝐻𝑐𝑜𝑚𝑚𝑖𝑡.𝑝𝑢𝑠ℎ((𝑖𝑑, 𝑠𝑣)) ;<br>            break<br>        for 𝑖𝑑𝑝𝑟𝑒𝑣 ∈ [𝑠𝑣 + 1, 𝑖𝑑 − 1] do<br>            if tx_𝑖𝑑𝑝𝑟𝑒𝑣’s write set ∩ tx_𝑖𝑑’s read set ≠ ∅ then<br>                get Aborted ;<br>                break<br>        if Aborted then<br>            𝐻𝑡𝑥𝑠.𝑝𝑢𝑠ℎ((𝑖𝑑 − 1, 𝑖𝑑)) ;<br>        else<br>            //Commit successfully<br>            𝑛𝑒𝑥𝑡 ← 𝑛𝑒𝑥𝑡 + 1 ;<br>return<br></code></pre></td></tr></table></figure><p>该算法将一组交易及其依赖项作为输入。依赖图可以通过估计每个交易的读写集来构建。估计不一定是完美的，但它需要在所有区块链节点上具有确定性和一致性。它越精确，我们可能遇到的不必要中断就越少。</p><p>根据依赖关系图，每个交易的存储版本被初始化为它所依赖交易的最大 id，如果没有依赖关系，则为 −1。交易被加入最小堆 𝐻𝑡𝑥𝑠 并按存储版本索引。还有另外三个最小堆：𝐻𝑟𝑒𝑎𝑑𝑦 维护准备好被调度的交易，𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠 是用于执行交易的线程池，𝐻𝑐𝑜𝑚𝑚𝑖𝑡 用于已完成执行并等待提交的交易。全局变量 𝑛𝑒𝑥𝑡 维护下一个要提交交易的 id。接下来：</p><ul><li><p><strong>Stage 1</strong>：将交易调度到线程池中。当与其存储版本对应的交易已提交时，我们认为该交易已准备好执行。如果线程池有空槽，交易将被推入线程池。</p></li><li><p><strong>Stage 2</strong>：线程池中交易的执行。我们选择剩余 gas 最少的交易，即是 𝐻𝑡ℎ𝑟𝑒𝑎𝑑𝑠 的顶部元素，把它推入 𝐻𝑐𝑜𝑚𝑚𝑖𝑡。</p></li><li><p><strong>Stage 3</strong>：逐个尝试提交在 𝐻𝑐𝑜𝑚𝑚𝑖𝑡 中的交易。𝐻𝑐𝑜𝑚𝑚𝑖𝑡 中的交易按照 id 的顺序进行维护，因为我们总是按顺序提交。对于每个交易，算法通过检查当前交易和自开始执行以来提交的交易之间是否存在读写冲突来判断中止或提交。如果中止，交易将被推回到 𝐻𝑡𝑥𝑠 其新存储版本设置为 𝑖𝑑 − 1。</p></li></ul><h2 id="6-EVALUATION"><a href="#6-EVALUATION" class="headerlink" title="6 EVALUATION"></a>6 EVALUATION</h2><h3 id="6-1-Experimental-Setup"><a href="#6-1-Experimental-Setup" class="headerlink" title="6.1 Experimental Setup"></a>6.1 Experimental Setup</h3><p>我们首先构建交易的依赖图，其中顶点（对应于交易）由消耗的 gas 加权。然后我们模拟在一组线程（2、4、8、16、32）上调度事务。</p><h3 id="6-2-Assumptions-and-Limitations"><a href="#6-2-Assumptions-and-Limitations" class="headerlink" title="6.2 Assumptions and Limitations"></a>6.2 Assumptions and Limitations</h3><p>我们的评估是基于使用真实数据的模拟，而不是基于在真实区块链系统中的实现。</p><h3 id="6-3-Evaluation-Results"><a href="#6-3-Evaluation-Results" class="headerlink" title="6.3 Evaluation Results"></a>6.3 Evaluation Results</h3><p>略</p><h2 id="7-THREATS-TO-VALIDITY"><a href="#7-THREATS-TO-VALIDITY" class="headerlink" title="7 THREATS TO VALIDITY"></a>7 THREATS TO VALIDITY</h2><p>略</p><h2 id="8-RELEVANCE-AND-FUTURE-WORK"><a href="#8-RELEVANCE-AND-FUTURE-WORK" class="headerlink" title="8 RELEVANCE AND FUTURE WORK"></a>8 RELEVANCE AND FUTURE WORK</h2><p>略</p><h2 id="9-RELATED-WORK"><a href="#9-RELATED-WORK" class="headerlink" title="9 RELATED WORK"></a>9 RELATED WORK</h2><p>略</p><h2 id="10-CONCLUSION"><a href="#10-CONCLUSION" class="headerlink" title="10 CONCLUSION"></a>10 CONCLUSION</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(08)：微服务框架</title>
    <link href="/ByteDance-8/"/>
    <url>/ByteDance-8/</url>
    
    <content type="html"><![CDATA[<p>微服务框架 —— 不变的基建</p><span id="more"></span><h2 id="1-微服务架构介绍"><a href="#1-微服务架构介绍" class="headerlink" title="1 微服务架构介绍"></a>1 微服务架构介绍</h2><h3 id="1-1-系统架构的演进历史"><a href="#1-1-系统架构的演进历史" class="headerlink" title="1.1 系统架构的演进历史"></a>1.1 系统架构的演进历史</h3><p><img src="/ByteDance-8/1.png" alt="演变历史"></p><ul><li>单体架构：All in one process</li><li>垂直应用架构：按照业务线垂直划分</li><li>分布式架构：抽出与业务无关的公共模块</li><li>SOA 架构：面向服务</li><li>微服务架构：彻底的服务化</li></ul><h3 id="1-2-微服务架构概览"><a href="#1-2-微服务架构概览" class="headerlink" title="1.2 微服务架构概览"></a>1.2 微服务架构概览</h3><p><img src="/ByteDance-8/2.png" alt="架构"></p><h3 id="1-3-微服务架构的三大要素"><a href="#1-3-微服务架构的三大要素" class="headerlink" title="1.3 微服务架构的三大要素"></a>1.3 微服务架构的三大要素</h3><ul><li><p>服务治理：服务注册、服务发现、负载均衡、扩缩容、流量治理、稳定性治理</p></li><li><p>可观测性：日志采集、日志分析、监控打点、监控大盘、异常报警、链路追踪</p></li><li><p>安全：身份验证、认证授权、访问令牌、审计、传输加密、黑产攻击</p></li></ul><h2 id="2-微服务架构原理及特征"><a href="#2-微服务架构原理及特征" class="headerlink" title="2 微服务架构原理及特征"></a>2 微服务架构原理及特征</h2><h3 id="2-1-基本概念及组件"><a href="#2-1-基本概念及组件" class="headerlink" title="2.1 基本概念及组件"></a>2.1 基本概念及组件</h3><p><img src="/ByteDance-8/3.png" alt="基本概念"></p><ul><li><p><strong>服务</strong>（service）：一组具有相同逻辑的运行实体</p></li><li><p><strong>实例</strong>（instance）：一个服务中的每个运行实体都为一个实例</p></li><li><p><strong>集群</strong>（cluster）：通常指服务内部的逻辑划分，包含多个实例</p></li><li><p>实例与进程的关系：没有必然对应关系，一般一对一或者一对多</p></li><li><p>常见的实例承载形式：进程、VM、k8s pod …</p></li></ul><h3 id="2-2-服务间通信"><a href="#2-2-服务间通信" class="headerlink" title="2.2 服务间通信"></a>2.2 服务间通信</h3><p>对于单体服务，不同模块通信只是简单的函数调用。<br>微服务之间通过网络进行通信，常见的通信协议包括 HTTP、RPC。</p><p><img src="/ByteDance-8/4.png" alt="通信"></p><h3 id="2-3-服务注册及服务发现"><a href="#2-3-服务注册及服务发现" class="headerlink" title="2.3 服务注册及服务发现"></a>2.3 服务注册及服务发现</h3><p><strong>基本问题</strong>：服务间调用中，如何指定下游服务实例的地址？</p><p><strong>简单方案</strong>：</p><ul><li><p>直接指定 ip:port</p><p><img src="/ByteDance-8/5.png" alt="Hardcode"></p><ul><li>没有任何动态能力</li><li>有多个实例下游实例怎么办？</li></ul></li><li><p>使用 DNS</p><p><img src="/ByteDance-8/6.png" alt="DNS"></p><ul><li>本地 DNS 存在缓存，导致延迟</li><li>DNS 没有负载均衡</li><li>不支持服务探活检查</li><li>DNS 不能指定端口</li></ul></li></ul><p><strong>服务注册发现</strong></p><p><img src="/ByteDance-8/7.png" alt="服务注册中心"></p><ul><li>新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系</li><li>旧服务实例下线前，从服务注册中心删除该实例，下线流量</li><li>新服务实例上线后，在服务注册中心注册该实例，上线流量</li></ul><p><strong>微服务流量特征</strong></p><p><img src="/ByteDance-8/8.png" alt="流量特征"></p><ul><li>统一网关入口</li><li>外网通信多数采用 HTTP，内网通信多数采用 RPC（Thrift, gRPC）</li></ul><h2 id="3-核心服务治理功能"><a href="#3-核心服务治理功能" class="headerlink" title="3 核心服务治理功能"></a>3 核心服务治理功能</h2><h3 id="3-1-服务发布"><a href="#3-1-服务发布" class="headerlink" title="3.1 服务发布"></a>3.1 服务发布</h3><p>服务发布（deployment）是让一个服务升级运行新的代码的过程。</p><p><strong>难点</strong>：服务不可用、服务抖动、服务回滚</p><p><strong>蓝绿部署</strong></p><p><img src="/ByteDance-8/9.png" alt="蓝绿部署"></p><ul><li>将服务分成两个部分，分别先后发布</li><li>简单、稳定</li><li>但需要两倍资源</li></ul><p><strong>灰度发布（金丝雀发布）</strong></p><p><img src="/ByteDance-8/10.png" alt="灰度发布"></p><ul><li>先发布少部分实例，接着逐步增加发布比例</li><li>不需要增加资源</li><li>回滚难度大，基础设施要求高</li></ul><h3 id="3-2-流量治理"><a href="#3-2-流量治理" class="headerlink" title="3.2 流量治理"></a>3.2 流量治理</h3><p>流量控制是在微服务架构中，可以从各个维度对端到端的流量在链路上进行精确控制。</p><p>控制维度：地区维度、集群维度、实例维度、请求维度</p><p><img src="/ByteDance-8/11.png" alt="流量治理"></p><h3 id="3-3-负载均衡"><a href="#3-3-负载均衡" class="headerlink" title="3.3 负载均衡"></a>3.3 负载均衡</h3><p>负载均衡（Load Balance）负责分配请求在每个下游实例上的分布。</p><p>常见 LB 策略：</p><ul><li>Round Robin</li><li>Random</li><li>Ring Hash</li><li>Least Request</li></ul><h3 id="3-4-稳定性治理"><a href="#3-4-稳定性治理" class="headerlink" title="3.4 稳定性治理"></a>3.4 稳定性治理</h3><p>线上服务总是会出问题的，这与程序的正确性无关。</p><ul><li><p>限流：限制服务处理的最大 QPS，拒绝过多请求。</p></li><li><p>熔断：中断请求路径，增加冷却时间从而让故障实例尝试恢复。</p></li><li><p>过载保护：在负载高的实例中，主动拒绝一部分请求，防止实例被打挂。</p></li><li><p>降级：服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求。</p></li></ul><h2 id="4-字节跳动服务治理实践"><a href="#4-字节跳动服务治理实践" class="headerlink" title="4 字节跳动服务治理实践"></a>4 字节跳动服务治理实践</h2><h3 id="4-1-重试的意义"><a href="#4-1-重试的意义" class="headerlink" title="4.1 重试的意义"></a>4.1 重试的意义</h3><p>本地函数调用：通常没有重试意义。</p><p>远程函数调用：网络抖动、下游负载高、下游机器宕机… 重试是有意义的，可以避免偶发性的错误，提高 SLA（Service-Level Agreement）。</p><p><strong>意义</strong>：</p><ul><li>降低错误率<ul><li>假设单次请求的错误概率为0.01，那么连续两次错误概率则为0.0001。</li></ul></li><li>降低长尾延时<ul><li>对于偶尔耗时较长的请求，重试请求有机会提前返回。</li></ul></li><li>容忍暂时性错误<ul><li>某些时候系统会有暂时性异常（例如网络抖动），重试可以尽量规避。</li></ul></li><li>避开下游故障实例<ul><li>一个服务中可能会有少量实例故障（例如机器故障），重试其他实例可以成功。</li></ul></li></ul><h3 id="4-2-重试的难点"><a href="#4-2-重试的难点" class="headerlink" title="4.2 重试的难点"></a>4.2 重试的难点</h3><ul><li><p>幂等性：多次请求可能会造成数据不一致。</p></li><li><p>重试风暴：随着调用链路的增加，重试次数呈指数级上升。</p></li></ul><p><img src="/ByteDance-8/12.png" alt="重试风暴"></p><ul><li>超时设置：假设调用时间一共 1s，经过多少时间开始重试？</li></ul><h3 id="4-3-重试的策略"><a href="#4-3-重试的策略" class="headerlink" title="4.3 重试的策略"></a>4.3 重试的策略</h3><ul><li><p>限制重试比例：设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值。</p></li><li><p>防止链路重试：返回特殊的 status code，表示“请求失败，但别重试”。</p></li><li><p>Hedged Requests：对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应。</p></li></ul><p><img src="/ByteDance-8/13.png" alt="Hedged Requests"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 FastFabric: Scaling Hyperledger Fabric to 20,000 Transactions per Second</title>
    <link href="/Paper-Fabric-Fast/"/>
    <url>/Paper-Fabric-Fast/</url>
    
    <content type="html"><![CDATA[<p>本文重新构建了 Hyperledger Fabric，减少事务排序和验证期间的计算和 I&#x2F;O 开销，从而大大提高吞吐量，将交易吞吐量从每秒 3000 笔提高到 20000 笔。值得注意的是，本文的优化是即插即用的，不需要对 Fabric 进行任何接口更改。</p><span id="more"></span><h2 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h2><p>相比公链，许可链通常将共识和交易验证委托给选定的一组节点，从而减轻共识算法的负担。但即使在这种情况下，共识仍然是一个瓶颈。</p><p>本文中仔细研究了 Hyperledger Fabric 1.2 的设计，基于常见的系统设计技术设计并实现了几种体系结构优化，这些技术将系统 tps 提高了近 7 倍，从每秒 3000 提高到 20000，同时降低了块延迟。具体贡献如下：</p><ol><li><em>Separating metadata from data</em>：Fabric 中的共识层接收整个交易作为输入，但只需要 ID 来决定交易顺序。我们重新设计了 Fabric 的排序服务，使其仅使用交易 ID，从而大大提高了吞吐量。</li><li><em>Parallelism and caching</em>：交易验证的某些方面可以并行化，而其他地方可以从缓存交易数据中获益。我们重新设计了 Fabric 的交易验证服务，在 committers 中积极缓存未组装的块，同时并行化尽可能多的验证步骤，包括背书策略验证和语法验证。</li><li><em>Exploiting the memory hierarchy for fast data access on the critical path</em>：Fabric 保持全局状态的键值存储可以被轻量级的内存数据结构所取代，这些结构缺乏持久性保证，可以通过区块链本身来弥补。我们围绕轻量级哈希表重新设计了 Fabric 的数据管理层，该哈希表可以更快地访问关键交易验证路径上的数据，将不可变块的存储推迟到写优化的存储集群。</li><li><em>Resource separation</em>：提交者和背书者节点争夺资源。我们介绍了一种将这些角色转移到单独硬件的体系结构。</li></ol><h2 id="II-FABRIC-ARCHITECTURE"><a href="#II-FABRIC-ARCHITECTURE" class="headerlink" title="II. FABRIC ARCHITECTURE"></a>II. FABRIC ARCHITECTURE</h2><h3 id="A-Node-types"><a href="#A-Node-types" class="headerlink" title="A. Node types"></a>A. Node types</h3><p>客户端发起交易，即对区块链的读取和写入，这些交易被发送到 Fabric 节点。节点要么是 peers，要么是 orderers；一些 peers 也是 endorsers。所有 peers 将区块提交到区块链的本地副本，并将相应的更改应用于维护当前世界状态快照的 state database。背书节点可以根据链码中的业务规则来证明交易是有效的。排序节点只负责决定交易顺序，而不验证正确性或有效性。</p><h3 id="B-Transaction-flow"><a href="#B-Transaction-flow" class="headerlink" title="B. Transaction flow"></a>B. Transaction flow</h3><ol><li>客户将其交易发送给一定数量的背书节点。</li><li>每个背书节点在沙盒中执行事务，并计算相应的读写集以及访问的每个键值的版本号。每个背书节点还使用业务规则来验证交易的正确性。</li><li>客户端等待足够数量的背书，然后将这些响应发送给排序节点。</li><li>排序节点首先对传入交易的顺序达成共识，然后将消息队列划分为块。</li><li>块被传递给对等节点，然后由对等节点验证并提交它们。</li></ol><h3 id="C-Implementation-details"><a href="#C-Implementation-details" class="headerlink" title="C. Implementation details"></a>C. Implementation details</h3><ul><li><p><em>Orderer</em></p><p>  客户端收到背书节点响应后，会创建一个包含 header 和 payload 的交易提案，header 包含交易 ID 和通道 ID，payload 包含读写集和其对应的版本号，以及背书节点的签名集。客户端对交易提案签名，并发送给排序服务。</p><p>  排序服务的两个目标：(a) 对交易排序达成共识，(b) 出块并发送给节点。本文中 Fabric 使用基于 ZooKeeper 的 Apache Kafka 来实现崩溃容错共识。</p><p>  当排序节点收到交易提案时，它会检查客户端是否有权提交交易。如果通过，排序节点将交易提案发布到 Kafka cluster，其中每个 Fabric 通道都映射到一个 Kafka topic，以创建相应的不可变的交易序列顺序。然后，每个排序节点根据每个块允许的最大交易数或超时时间，将从 Kafka 接收的交易组装成块，签名并使用 gRPC 将块传递给节点。</p></li><li><p><em>Peer</em></p><p>  在接收到来自排序服务的消息时，对等节点首先对块的头和元数据进行解码，并检查其语法结构，然后验证创建此块的排序节点的签名。未通过这些测试的块将立即被丢弃。初始验证之后，区块被加入队列，从而保证其被添加到区块链中。之后块会依次经过两个验证步骤和一个提交步骤。</p><p>  在第一个验证步骤中，对块中的所有交易进行解码，检查它们的语法并验证它们的背书集。未通过的交易被标记为无效，但保留在块中。这一步使得恶意交易被排除。</p><p>  在第二个验证步骤中，节点确保有效交易间的相互作用不会导致无效的世界状态。回想一下，每一笔交易都携带一组需要从世界状态数据库读取的键（读集）和一组将写入数据库的键和值（写集），以及背书节点记录的版本号。在第二个验证步骤中，交易读写集中的每个键都必须具有相同的版本号。这样可以防止双重支付。</p><p>  在最后一步中，对等节点将块写入文件系统，该块现在包含交易的验证标志。根据应用程序的配置，键值（即世界状态）将持久化在 LevelDB 或 CouchDB 中。每个块及其交易的索引都存储在 LevelDB 中，以加快数据访问速度。</p></li></ul><h2 id="III-DESIGN"><a href="#III-DESIGN" class="headerlink" title="III. DESIGN"></a>III. DESIGN</h2><h3 id="A-Preliminaries"><a href="#A-Preliminaries" class="headerlink" title="A. Preliminaries"></a>A. Preliminaries</h3><p>使用拜占庭容错（BFT）共识算法是 HyperLedger 中的一个关键性能瓶颈。在我们的工作中，我们选择跳过这一明显的瓶颈，原因有三：</p><ul><li><p>在许可区块链中使用 BFT 协议并不像在无许可的系统中那么重要，因为所有参与者都是已知的，并被激励以诚实的方式保持系统运行。</p></li><li><p>BFT 共识正在被广泛研究，我们预计在未来一两年内会出现更高吞吐量的解决方案。</p></li><li><p>在实践中，Fabric 1.2 不使用 BFT 共识协议，而是依赖于 Kafka 进行交易排序，如前所述。</p></li></ul><h3 id="B-Orderer-improvement-I-Separate-transaction-header-from-payload"><a href="#B-Orderer-improvement-I-Separate-transaction-header-from-payload" class="headerlink" title="B. Orderer improvement I: Separate transaction header from payload"></a>B. Orderer improvement I: Separate transaction header from payload</h3><p>在 Fabric 1.2 中，使用 Apache Kafka 的排序节点将整个交易发送给 Kafka 进行排序。交易的长度可能是几千字节，这会导致高通信开销，从而影响整体性能。然而，在交易顺序上获得共识只需要交易 ID，因此我们可以通过只向 Kafka 发送交易 ID 来显著提高排序节点的吞吐量。具体来说，在从客户端接收到交易时，排序节点从 header 中提取交易 ID，并将该 ID 发布到 Kafka 集群。排序节点将相应的 payload 单独存储在本地数据结构中，当从 Kafka 收到 ID 时，交易将重新组装。</p><h3 id="C-Orderer-improvement-II-Message-pipelining"><a href="#C-Orderer-improvement-II-Message-pipelining" class="headerlink" title="C. Orderer improvement II: Message pipelining"></a>C. Orderer improvement II: Message pipelining</h3><p>在 Fabric 1.2 中，排序服务逐个处理来自客户端的传入交易。当交易到达时，识别其对应的通道，根据一组规则检查其有效性，最后将其转发到共识系统（Kafka），然后才能处理下一笔交易。我们实现了一种流水线机制，可以同时处理多个传入交易，即使它们来自使用相同 gRPC 连接的同一客户端。为此，我们维护了一个并行处理传入请求的线程池，每个传入请求有一个线程。线程调用 Kafka API 来发布交易 ID，并在成功时向客户端发送响应。</p><p><img src="/Paper-Fabric-Fast/1.png" alt="New orderer architecture"></p><h3 id="D-Peer-tasks"><a href="#D-Peer-tasks" class="headerlink" title="D. Peer tasks"></a>D. Peer tasks</h3><p>在接收到区块时，Fabric 节点按顺序执行以下任务：</p><ul><li>验证接收到的消息的合法性</li><li>验证区块中每个交易的区块头和每个背书签名</li><li>验证交易的读写集</li><li>在 LevelDB 或 CouchDB 中更新世界状态</li><li>将区块链日志存储在文件系统中，并在 LevelDB 中提供相应的索引</li></ul><p>我们的目标是在交易流的关键路径上最大限度地提高吞吐量。为此，我们进行了调用图分析，以确定性能瓶颈。<strong>首先</strong>，交易读写集的验证需要快速访问世界状态。因此，我们可以通过使用内存中的哈希表而不是数据库来加快这一过程。<strong>其次</strong>，交易流不需要区块链日志，因此我们可以推迟到交易流结束时将其存储到专用存储和数据分析服务器。<strong>第三</strong>，如果节点是背书节点，则需要处理新的交易提案。然而，提交者和背书者的角色是不同的，因此可以为每个任务分配不同的物理硬件。<strong>第四</strong>，传入的块和交易必须在节点进行验证和解析。最重要的是，通过交易写集对状态更改的验证必须按顺序进行，这会阻止所有其他任务。因此，尽可能加快这项操作是很重要的。<strong>最后</strong>，通过缓存块的 Protocol Buffers 解码的结果，可以获得显著的性能增益。</p><p><img src="/Paper-Fabric-Fast/2.png" alt="New peer architecture"></p><h3 id="E-Peer-improvement-I-Replacing-the-world-state-database-with-a-hash-table"><a href="#E-Peer-improvement-I-Replacing-the-world-state-database-with-a-hash-table" class="headerlink" title="E. Peer improvement I: Replacing the world state database with a hash table"></a>E. Peer improvement I: Replacing the world state database with a hash table</h3><p>我们认为，对于常见的情况，例如跟踪钱包或账本上的资产，世界状态相对较小。即使需要存储数十亿个键值，大多数服务器也可以很容易地将它们保存在内存中。因此，我们建议使用内存中的哈希表来存储世界状态，而不是 LevelDB&#x2F;CouchDB。这消除了在更新世界状态时对硬盘的访问，还消除了由于区块链本身的冗余保证而不必要的昂贵的数据库系统保证（即，ACID 属性），进一步提高了性能。当然，由于使用易失性存储器，这种替换易受节点故障的影响，因此必须通过稳定存储来增强内存中的哈希表。</p><h3 id="F-Peer-improvement-II-Store-blocks-using-a-peer-cluster"><a href="#F-Peer-improvement-II-Store-blocks-using-a-peer-cluster" class="headerlink" title="F. Peer improvement II: Store blocks using a peer cluster"></a>F. Peer improvement II: Store blocks using a peer cluster</h3><p>根据定义，区块是不可变的。这使它们非常适合追加式数据存储。通过将数据存储与节点的其余任务分离，我们可以设想许多类型的数据存储用于区块和世界状态备份，包括单个服务器将区块和世界状态备份存储在其文件系统中，就像 Fabric 目前所做的那样；也可以使用数据库或键值存储，例如 LevelDB 或 CouchDB。为了最大限度地扩展，我们建议使用分布式存储集群。此解决方案中每个存储服务器仅包含链的一部分，可以使用分布式数据处理工具，如 Hadoop MapReduce 或 Spark5。</p><h3 id="G-Peer-improvement-III-Separate-commitment-and-endorsement"><a href="#G-Peer-improvement-III-Separate-commitment-and-endorsement" class="headerlink" title="G. Peer improvement III: Separate commitment and endorsement"></a>G. Peer improvement III: Separate commitment and endorsement</h3><p>在 Fabric 1.2 中，背书节点也负责提交区块。背书是一个昂贵的操作，提交也是如此。虽然在背书节点集群上的并发事务处理会提高性能，但在每个新节点上重复提交的额外工作实际上抵消了这些好处。因此，我们建议拆分这些角色。</p><p>在我们的设计中，提交节点执行验证流程，然后将已验证的区块发送到一个背书节点集群，这些节点仅将更改应用于其世界状态而不进行验证。这一步骤允许我们释放节点上的资源。这样的背书节点集群可以通过只将节点的背书角色分离到专用硬件上以满足需求。该集群中的服务器并不相当于 Fabric 1.2 中完整的背书节点。</p><h3 id="H-Peer-improvement-IV-Parallelize-validation"><a href="#H-Peer-improvement-IV-Parallelize-validation" class="headerlink" title="H. Peer improvement IV: Parallelize validation"></a>H. Peer improvement IV: Parallelize validation</h3><p>区块和交易头验证都包括检查发送方的权限、背书策略和语法验证，具有高度可并行性。我们通过引入完整的验证流水线来扩展 Fabric 1.2 的并发性能。</p><p>具体而言，对于每个传入的区块，分配一个 go-routine 来引导其通过区块验证阶段。随后，这些 go-routines 中的每一个都利用 Fabric 1.2 中已经存在的用于交易验证的 go-routine 池。因此，在任何给定时间，多个区块及其交易都可以并行地进行有效性检查。最后，所有<strong>读写集合按正确顺序由单个 go-routine 顺序验证</strong>。这使我们能够充分利用多核服务器 CPU 的潜力。</p><h3 id="I-Peer-improvement-V-Cache-unmarshaled-blocks"><a href="#I-Peer-improvement-V-Cache-unmarshaled-blocks" class="headerlink" title="I. Peer improvement V: Cache unmarshaled blocks"></a>I. Peer improvement V: Cache unmarshaled blocks</h3><p>Fabric 在网络节点之间使用 gRPC 进行通信。为了准备数据进行传输，使用 Protocol Buffers 进行序列化。为了能够处理应用程序和软件随着时间的推移进行的升级，Fabric 的区块结构高度分层，每个层都分别进行序列化和反序列化。这导致大量内存被分配用于将字节数组转换为数据结构。此外，Fabric 1.2 不会在缓存中存储先前解析的数据，因此每当需要数据时就必须重新进行此操作。</p><p>为了优化这个问题，我们计划用一个临时的缓存来存放解析的数据。验证流水线中区块被存储在缓存中，并在需要时按块编号检索。一旦块的任何部分被解析，它就与块一起存储以供重用。我们将其实现为一个循环缓冲区，大小与验证流水线相同。每当提交一个块时，就可以接受一个新块到管道中，并自动覆盖已提交块的缓存位置。由于在提交后不需要缓存，并且保证新块仅在旧块离开管道后才到达，因此这是一个安全的操作。解组仅向缓存添加数据，它从不更改数据，所以在验证流水线中可以为所有 go-routines 提供无锁访问。在最坏的情况下，多个 go-routines 尝试访问相同的（但尚未解析的）数据，并且所有 go-routines 并行执行解析操作，缓存的最后写入获胜。这是没有问题的，因为大家执行结果都是相同的。</p><h2 id="IV-RESULTS"><a href="#IV-RESULTS" class="headerlink" title="IV. RESULTS"></a>IV. RESULTS</h2><p>实验配置略。</p><h3 id="A-Block-transfer-via-gRPC"><a href="#A-Block-transfer-via-gRPC" class="headerlink" title="A. Block transfer via gRPC"></a>A. Block transfer via gRPC</h3><p>我们预先创建了包含不同数量交易的有效块，通过 Fabric gRPC 接口将它们从一个 orderer 发送到 peer，然后立即丢弃它们。</p><p><img src="/Paper-Fabric-Fast/3.png" alt="Throughput via gRPC for different block sizes"></p><h3 id="B-Orderer-throughput-as-a-function-of-message-size"><a href="#B-Orderer-throughput-as-a-function-of-message-size" class="headerlink" title="B. Orderer throughput as a function of message size"></a>B. Orderer throughput as a function of message size</h3><p>在这个实验中，我们设置了多个客户端，这些客户端向排序节点发送交易，并监控发送 100000 个交易所需的时间。我们评估在 Fabric 1.2 中排序交易的速率，并将其与我们的改进进行比较：</p><ul><li><strong>Opt O-I</strong>: only Transaction ID is published to Kafka (Section III-B)</li><li><strong>Opt O-II</strong>: parallelized incoming transaction proposals from clients (Section III-C)</li></ul><p><img src="/Paper-Fabric-Fast/4.png" alt="Effect of payload size on orderer throughput"></p><h3 id="C-Peer-experiments"><a href="#C-Peer-experiments" class="headerlink" title="C. Peer experiments"></a>C. Peer experiments</h3><p>本节在单独节点上进行测试。我们准备好块，并将它们发送给节点，就像我们在第 IV-A 节的 gRPC 实验中所做的那样。然后，节点完全验证并提交块。</p><ul><li><strong>Opt P-I</strong>: LevelDB replaced by an in-memory hash table</li><li><strong>Opt P-II</strong>: Validation and commitment completely parallelized; block storage and endorsement offloaded to a separate storage server via remote gRPC call</li><li><strong>Opt P-III</strong>: All unmarshaled data cached and accessible to the entire validation&#x2F;commitment pipeline</li></ul><ol><li><em>Experiments with fixed block sizes</em>：单次运行 100000 个交易的验证和提交，重复 1000 次，每个区块包含 100 笔交易。</li></ol><p><img src="/Paper-Fabric-Fast/5.png" alt="Impact of our optimizations on peer block latency"></p><p><img src="/Paper-Fabric-Fast/6.png" alt="Impact of our optimizations on peer throughput"></p><ol start="2"><li><em>Parameter sensitivity</em>：测试改变两个参数对并行化性能的影响。</li></ol><ul><li>在验证流程中并行引导块的 go-routines 的数量</li><li>并行验证交易的 go-routines 的数量</li></ul><p>我们使用 semaphores 控制系统中 go-routines 的数量，同时允许多个块同时进入验证管道。这使我们能够通过两个独立的 go-routine pools 来控制块头验证和交易验证的并行度。</p><p><img src="/Paper-Fabric-Fast/7.png" alt=" Parameter sensitivity study for blocks containing 100 transactions and a server with 24 CPU cores. We scale the number of blocks that are validated in parallel and the number of transactions per block that are validated in parallel independently"></p><p>配置 24 ± 2 交易验证 go-routines，验证通道中有 30 ± 3 个区块，测试区块大小的影响。</p><p><img src="/Paper-Fabric-Fast/8.png" alt="Throughput dependence on block size for optimally tuned configuration"></p><h3 id="D-End-to-end-throughput"><a href="#D-End-to-end-throughput" class="headerlink" title="D. End-to-end throughput"></a>D. End-to-end throughput</h3><p>我们现在讨论通过组合所有优化实现的端到端吞吐量。O-II 与 P-III，与 Fabric 1.2 的测量结果对比。</p><p><img src="/Paper-Fabric-Fast/9.png" alt="Result"></p><h2 id="V-RELATED-WORK"><a href="#V-RELATED-WORK" class="headerlink" title="V. RELATED WORK"></a>V. RELATED WORK</h2><p>略</p><h2 id="VI-CONCLUSIONS"><a href="#VI-CONCLUSIONS" class="headerlink" title="VI. CONCLUSIONS"></a>VI. CONCLUSIONS</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(07)：分布式理论</title>
    <link href="/ByteDance-7/"/>
    <url>/ByteDance-7/</url>
    
    <content type="html"><![CDATA[<p>分布式理论 —— 现代架构的基石。</p><span id="more"></span><h2 id="1-分布式概述"><a href="#1-分布式概述" class="headerlink" title="1 分布式概述"></a>1 分布式概述</h2><ul><li><p>什么是分布式？</p><ul><li>分布式系统定义：跨多个节点的计算机程序的集合</li><li>使用分布式系统的五大优势：去中心化、低成本、弹性、资源共享、可靠性高</li><li>分布式系统的挑战：节点故障、不可靠的网络、异构的机器与硬件环境、安全</li></ul></li><li><p>常见的分布式系统</p><ul><li>分布式存储：GFS、Ceph、HDFS、Zookeeper</li><li>分布式数据库：Spanner、TiDB、HBase、MangoDB</li><li>分布式计算：Hadoop、YARN、Spark</li></ul></li></ul><h2 id="2-系统模型"><a href="#2-系统模型" class="headerlink" title="2 系统模型"></a>2 系统模型</h2><h3 id="2-1-故障模型"><a href="#2-1-故障模型" class="headerlink" title="2.1 故障模型"></a>2.1 故障模型</h3><ul><li><p>六种故障模型，从处理的难易程度分类</p><ul><li>Byzantine failure：节点可以任意篡改发送给其他节点的数据，是最难处理的故障</li><li>Authentication detectable byzantine failure (ADB)：节点可以篡改数据，但不能伪造其他节点的数据</li><li>Performance failure：节点未在特定时间段内收到数据，即时间太早或太晚</li><li>Omission failure：节点收到数据的时间无限晚，即收不到数据</li><li>Crash failure：节点停止响应，持续性的故障</li><li>Fail-stop failure：错误可检测，是最容易处理的故障</li></ul></li><li><p>故障模型举例</p></li></ul><p><img src="/ByteDance-7/1.png" alt="故障模型"></p><h3 id="2-2-拜占庭将军问题"><a href="#2-2-拜占庭将军问题" class="headerlink" title="2.2 拜占庭将军问题"></a>2.2 拜占庭将军问题</h3><ul><li><p>两将军问题</p><p>  定义：两支军队的将军只能派信使穿越敌方领土互相通信，以此约定进攻时间。该问题希望求解如何在两名将军派出的任何信使都可能被俘虏的情况下，就进攻时间达成共识。</p><p>  结论：两将军问题是被证实无解的电脑通信问题，两支军队理论上永远无法达成共识。</p><p>  TCP是两将军问题的一个工程解。</p></li><li><p>三将军问题：</p><p>  两个“忠将” A 和 B，一个“叛徒” C，互相传递消息，消息可能丢失，也可能被篡改，当有一个将军是“叛徒”（即出现拜占庭故障）时，整个系统无法达成一致。</p><p>  由于“叛徒” C 的存在，将军 A 和将军 B 获得不同的信息。这样将军 A 获得 2 票进攻 1 票撤退的信息，将军 B 获得 1 票进攻 2 票撤退的信息，产生了不一致。</p></li><li><p>四将军问题：</p><p>  将军 D 作为消息分发中枢，约定如果没收到消息则执行撤退。</p><p>  如果 D 为“叛徒”，ABC 无论收到任何消息，总能达成一致。D 为“忠将”，ABC 有 2 人将 D 的消息进行正确的传递，同样能保证最终决策符合大多数。</p><p>  进而能够证明，当有 3m+1 个将军，m 个“叛徒”时，可以进行 m 轮协商，最终达成一致。</p></li></ul><h3 id="2-3-共识和一致性"><a href="#2-3-共识和一致性" class="headerlink" title="2.3 共识和一致性"></a>2.3 共识和一致性</h3><p>不同客户端 A 和 B 看到客户端 C 写入，因为时机的不同，产生数据读取的偏差。</p><ul><li>Eventuallyconsistent（最终一致性）<br>  客户端 A 读到 x&#x3D;0，当客户端 C 正在写入时，客户端 A 和 B 可能读到 0 或者 1。但是当 C 写入完成后，A 和 B 最终能读到一致的数据。</li></ul><p><img src="/ByteDance-7/2.png" alt="读请求和写请求并发时可能读到旧值"></p><p>要保证所有客户端看到相同的值，需要多节点进行“协商”，达成共识，来保证线性一致性。</p><ul><li>Linearizability（线性一致性）<br>  当客户端 A 读到更新的版本 x&#x3D;1 后，及时将消息同步给其他客户端，这样其他客户端立即能获取到 x&#x3D;1。</li></ul><p><img src="/ByteDance-7/3.png" alt="一旦某个读获取到新值，所有客户端都必须返回新值"></p><p>一致性和可用性是对矛盾，如果要保证“线性”一致性，多个节点间势必需要进行协商，以寻求一致。这样增加了延迟，系统可用性便会受损。</p><h2 id="3-理论基础"><a href="#3-理论基础" class="headerlink" title="3 理论基础"></a>3 理论基础</h2><h3 id="3-1-CAP-理论"><a href="#3-1-CAP-理论" class="headerlink" title="3.1 CAP 理论"></a>3.1 CAP 理论</h3><p>一致性、可用性、分区容错性，三者无法同时达到</p><ul><li>C (Consistence)：一致性，指数据在多个副本之间能够保持一致的特性（严格的一致性）。</li><li>A (Availability)：可用性，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。</li><li>P (Partitioning)：分区容错性，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。</li></ul><p>CAP 诞生了<strong>三类系统</strong>：</p><ul><li>CA 系统：传统单机数据库的代表</li><li>AP 系统：放弃<strong>强</strong>一致性，保证高可用，不少 nosql 存储系统采用，注重用户体验</li><li>CP 系统：放弃可用性，保证数据一致性，注重系统安全</li></ul><h3 id="3-2-ACID-理论"><a href="#3-2-ACID-理论" class="headerlink" title="3.2 ACID 理论"></a>3.2 ACID 理论</h3><p>ACID 理论是针对 CA 系统而言的，通常在数据库中具有广泛意义。</p><p>事务是数据库系统中非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全都不执行。</p><p>数据库事务拥有<strong>四个特性</strong>：</p><ul><li>原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li><li>一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li><li>隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h3 id="3-3-BASE-理论"><a href="#3-3-BASE-理论" class="headerlink" title="3.3 BASE 理论"></a>3.3 BASE 理论</h3><p>BASE 理论是针对 AP 系统而言的，其来源于对大型互联网分布式实践的总结。</p><ul><li>Basically Available（基本可用）：假设系统出现了不可预知的故障，但还是能用。</li><li>Soft state（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性。</li><li>Eventually consistent（最终一致性）：数据最终一定能够达到一致的状态。</li></ul><h2 id="4-分布式事务"><a href="#4-分布式事务" class="headerlink" title="4 分布式事务"></a>4 分布式事务</h2><h3 id="4-1-二阶段提交（Two-phase-Commit）"><a href="#4-1-二阶段提交（Two-phase-Commit）" class="headerlink" title="4.1 二阶段提交（Two-phase Commit）"></a>4.1 二阶段提交（Two-phase Commit）</h3><p>为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种演算法。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者提交操作还是中止操作。</p><p><strong>三个假设</strong>：</p><ol><li>协调者和参与者进行通信</li><li>预写式日志被保持在可靠的存储设备上</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复</li></ol><p><img src="/ByteDance-7/4.png" alt="2PC"></p><ol><li><p>准备阶段（Prepare Phase）： 在该阶段，事务协调者向所有参与者发送准备请求，询问是否可以执行事务。参与者执行事务的操作，并将执行结果反馈给协调者。如果所有参与者都准备好执行事务，则进入提交阶段。如果有任何一个参与者无法准备好执行事务，则进入中止阶段。</p></li><li><p>提交阶段（Commit Phase）： 在该阶段，事务协调者向所有参与者发送提交请求，要求执行事务的提交操作。参与者执行事务的提交操作，并将执行结果反馈给协调者。如果所有参与者都成功提交事务，则整个事务提交成功。如果有任何一个参与者提交失败，则整个事务回滚。</p></li></ol><p><strong>两阶段提交需解决的问题</strong>：</p><ul><li>性能问题：需要多次网络通信，资源需要等待并锁定</li><li>新协调者：如何确定状态选出新协调者</li><li>Commit 阶段网络分区带来的数据不一致：非所有节点都收到 Commit 请求</li><li>第二阶段的提交阶段可能会出现阻塞，从而影响整个系统的性能</li></ul><h3 id="4-2-三阶段提交"><a href="#4-2-三阶段提交" class="headerlink" title="4.2 三阶段提交"></a>4.2 三阶段提交</h3><p>针对两阶段提交的补充，将两阶段提交中的 Prepare 阶段，拆成两部分：CanCommit 和 PreCommit</p><ul><li>CanCommit 阶段：询问是否可以执行</li><li>PreCommit 阶段：重新确认是否可以执行</li><li>DoCommit 阶段：向所有人提交事务</li></ul><p>三阶段提交协议通过将提交阶段分为两个阶段，解决了二阶段提交可能出现的长时间阻塞问题。当某个参与者在 PreCommit 阶段失败时，协调者可以在适当的时候发起回滚，而不必一直等待，从而避免了阻塞的情况。</p><h3 id="4-3-MVCC"><a href="#4-3-MVCC" class="headerlink" title="4.3 MVCC"></a>4.3 MVCC</h3><p>多版本并发控制的方法。维持一个数据的多个版本使读写操作没有冲突。所以既不会阻塞写，也不阻塞读。提高并发性能的同时也解决了脏读的问题。</p><ul><li>悲观锁：操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li><li>乐观锁：不会上锁，只是在执行更新时判断别人是否修改数据，只有冲突时才放弃操作。</li></ul><p>版本的选取：</p><ul><li>物理时钟：提供 TrueTime API，有 Master 节点维持一个绝对时间，保证各个服务器之间时钟误差控制在 ϵ 内，通常 ϵ &lt; 7ms。</li><li>逻辑时钟：中心化授时的方式——时间戳预言机（TSO），好处是无需硬件的支持。</li></ul><h2 id="5-共识协议"><a href="#5-共识协议" class="headerlink" title="5 共识协议"></a>5 共识协议</h2><h3 id="5-1-Quorum-NWR-模型"><a href="#5-1-Quorum-NWR-模型" class="headerlink" title="5.1 Quorum NWR 模型"></a>5.1 Quorum NWR 模型</h3><ul><li>N：在分布式存储系统中，有多少份备份数据。</li><li>W：代表一次成功的更新操作要求至少有 w 份数据写入成功。</li><li>R：代表一次成功的读数据操作要求至少有 R 份数据成功读取。</li></ul><p><strong>为了保证强一致性，需要保证 W + R &gt; N</strong></p><p>Quorum NWR 模型将 CAP 的选择交给用户，是一种简化版的一致性模型。</p><h3 id="5-2-RAFT-协议"><a href="#5-2-RAFT-协议" class="headerlink" title="5.2 RAFT 协议"></a>5.2 RAFT 协议</h3><p>Raft 协议是一种分布式一致性算法（共识算法），即使出现部分节点故障，网络延时等情况，也不影响各节点，进而提高系统的整体可用性。</p><p><img src="/ByteDance-7/5.png" alt="RAFT"></p><ul><li>Log（日志）：节点之间同步的信息，以只追加写的方式进行同步，解决了数据被覆盖的问题。</li><li>Term（任期号）：单调递增，每个 Term 内最多只有一个 Leader。</li><li>Committed：日志被复制到多数派节点，即可认为已经被提交。</li><li>Applied：日志被应用到本地状态机，即执行了log中命令，修改了内存状态。</li></ul><p><img src="/ByteDance-7/6.png" alt="状态转移"></p><ul><li>Leader - 领导者：Leader 负责处理所有的客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后，通知 Follower 提交日志。</li><li>Follower - 跟随者：接受并持久化 Leader 同步的日志，在 Leader 告知日志可以提交后，提交日志。</li><li>Candidate - 备选者：Leader 选举过程中的临时角色，向其他节点发送请求投票信息。</li></ul><p><strong>Leader 选举过程</strong>：</p><ol><li>初始全部为Follower</li><li>Current Term + 1</li><li>选举自己</li><li>向其它参与者发起 RequestVote 请求，retry 直到：<ul><li>收到多数派请求，成为 Leader，并发送心跳</li><li>收到其它 Leader 的请求，转为 Follower，更新自己的 Term</li><li>收到部分，但未达到多数派，选举超时，随机 timeout 开始下一轮</li></ul></li></ol><p><strong>切主</strong>：当Leader出现问题时，就需要进行重新选举</p><ol><li>Leader 发现失去 Follower 的响应，失去 Leader 身份</li><li>两个 Follower 之间一段时间未收到心跳，重新进行选举，选出新的 Leader，此时发生了切主</li><li>Leader 自杀重启，以 Follower 的身份加入进来</li></ol><h3 id="5-3-Paxos-协议"><a href="#5-3-Paxos-协议" class="headerlink" title="5.3 Paxos 协议"></a>5.3 Paxos 协议</h3><p><strong>Paxos 算法与 RAFT 算法区别</strong>：</p><ul><li><p>Multi-Paxos 可以并发修改日志，而 Raft 写日志操作必须是连续的</p></li><li><p>Multi-Paxos 可以随机选主，不必最新最全的节点当选 Leader</p></li><li><p>优势：写入并发性能高，所有节点都能写</p></li><li><p>劣势：没有一个节点有完整的最新的数据，恢复流程复杂，需要同步历史记录</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform</title>
    <link href="/Paper-Fabric-Optimizing/"/>
    <url>/Paper-Fabric-Optimizing/</url>
    
    <content type="html"><![CDATA[<p>这篇文章发现了 Fabric v1.0 的三个主要性能瓶颈：(1) 背书策略验证；(2) 块中交易的顺序策略验证；(3) CouchDB 的状态验证和提交。同时对上述问题进行了简单的优化，如加密组件中用于背书策略验证的主动缓存、并行背书策略验证、增强并测量了 CouchDB 的现有批量读&#x2F;写优化的效果。</p><span id="more"></span><h2 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h2><p>与公链相比，许可链每个参与者的身份都是已知的，并且经过加密身份验证，这样区块链就可以存储谁进行了哪些交易。这样的网络可以内置访问控制机制，以限制谁可以 (a) 读取和附加账本数据，(b) 发布交易，(c) 管理区块链网络的参与者。所以非常适用于要求身份验证的企业级应用程序。</p><p>Fabric 提供了许多可配置的参数（block size，endorsement policy，channels，state database），因此，建立高效区块链网络的主要挑战之一就是为这些参数找到合适的值。</p><p><strong>本文的三个主要贡献：</strong></p><ol><li>我们进行了 1000 多次实验，通过改变五个主要参数的赋值，对 Fabric 平台进行了全面的测试，并且提供了六条关于配置这些参数以获得最大性能的指导方针。</li><li>我们确定了三个主要的性能瓶颈：(i) 加密操作，(ii) 区块中的交易串行验证，(iii) 对 CouchDB 的多个 REST API 调用。</li><li>进行三种简单优化，在单通道环境下将整体性能提高 16 倍。代码见 <a href="https://github.com/thakkarparth007/fabric">https://github.com/thakkarparth007/fabric</a>。</li></ol><h2 id="II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS"><a href="#II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS" class="headerlink" title="II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS"></a>II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS</h2><h3 id="A-Key-Components-in-Fabric"><a href="#A-Key-Components-in-Fabric" class="headerlink" title="A. Key Components in Fabric"></a>A. Key Components in Fabric</h3><ul><li><p><strong>Peer</strong>：对等节点执行实现用户智能合约的链码，并且在文件系统中维护账本。节点被进一本分为<strong>背书节点</strong>（endorsing peer，具有链码逻辑）和<strong>提交节点</strong>（committing peer，没有链码逻辑）。对等节点在键值存储中将当前状态维护为 StateDB，以便链码可以使用数据库查询语言查询或修改状态。</p><p>  <em><strong>Endorsement Policies</strong></em>：指定一组节点来模拟执行交易，并对执行结果签名背书。</p><p>  <em><strong>System chaincodes</strong></em>：系统链码与普通用户链码具有相同的程序设计模型，并内置于对等节点可执行文件中，这与用户链码不同。</p><ul><li><strong>LSCC</strong>（life cycle system chaincode）用于安装&#x2F;实例化&#x2F;更新链码；</li><li><strong>ESCC</strong>（endorsement system chaincode）通过对响应进行数字签名来背书交易；</li><li><strong>VSCC</strong>（validation system chaincode）根据背书策略验证交易的背书签名集；</li><li><strong>CSCC</strong>（configuration system chaincode）管理通道配置。</li></ul><p>  <em><strong>Channel</strong></em>：Fabric 引入通道的概念————两个或多个对等节点之间通信的“专用”子网，以提供一定程度的隔离。</p></li><li><p><strong>Ordering Service</strong>：排序节点（OSN）参与共识协议并出块，然后通过 gossip 协议传递给对等节点。区块结构如下图所示：</p></li></ul><p><img src="/Paper-Fabric-Optimizing/1.png" alt="Block Structure in Hyperledger Fabric v1.0"></p><p>OSNs 将交易发布到 kafka 并利用其记录的有序和不可变性来生成唯一的有序区块。</p><ul><li><strong>Client</strong>：客户端应用负责将交易提案组装成上图的形式，然后将交易提案同时提交给一个或多个对等节点，以收集带有背书的提案响应，满足背书政策后再将其广播给排序者。</li></ul><h3 id="B-Transaction-Flow-in-Hyperledger-Fabric"><a href="#B-Transaction-Flow-in-Hyperledger-Fabric" class="headerlink" title="B. Transaction Flow in Hyperledger Fabric"></a>B. Transaction Flow in Hyperledger Fabric</h3><p><img src="/Paper-Fabric-Optimizing/2.png" alt="Transaction Flow"></p><ol><li><p><strong>Endorsement Phase</strong><br> 客户端根据背书政策发送交易。背书节点收到客户端发来的交易，首先验证提交者有调用交易的权限；其次执行链码并产生 response value，read-set 和 write-set，读集读取当前的区块链状态，写集仅修改一个私有的工作区，即未提交到账本；然后背书节点调用 ESCC 签署背书并回复客户端；最后客户端验证提案响应。</p></li><li><p><strong>Ordering Phase</strong><br> 客户端将交易（read-write sets，endorsing peer signatures，Channel ID）包装好发给排序节点。排序服务并不检查交易内容，只按照通道分别排序并出块。给块签名后使用 gossip 传递给节点。</p></li><li><p><strong>Validation Phase</strong><br> 所有节点都会收到区块，首先检查排序者的签名，有效块被解码，并且块中的所有交易在执行 MVCC 验证之前首先经过 VSCC 验证。</p><ul><li>VSCC Validation：根据为链码指定的背书策略评估交易中的背书。如果不满足背书策略，则该交易被标记为无效。</li><li>MVCC Validation：Multi-Version Concurrency Control <strong>顺序</strong>检查有效交易（VSCC 标记）在背书阶段读取键值的版本与提交时本地账本中的当前状态是否相同，类似于为并发控制所做的读写冲突检查。</li></ul></li><li><p><strong>Ledger Update Phase</strong><br> StateDB 使用有效事务（MVCC 验证所标记）的写集进行更新。</p></li></ol><h3 id="C-Configuration-Parameters"><a href="#C-Configuration-Parameters" class="headerlink" title="C. Configuration Parameters"></a>C. Configuration Parameters</h3><ol><li>Block Size</li><li>Endorsement Policy</li><li>Channel</li><li>Resource Allocation</li><li>Ledger Database</li></ol><h2 id="III-PROBLEM-STATEMENT"><a href="#III-PROBLEM-STATEMENT" class="headerlink" title="III. PROBLEM STATEMENT"></a>III. PROBLEM STATEMENT</h2><p>本文工作的两个主要目标：</p><ol><li>Performance Benchmarking.</li><li>Optimization.</li></ol><h2 id="IV-EXPERIMENTAL-METHODOLOGY"><a href="#IV-EXPERIMENTAL-METHODOLOGY" class="headerlink" title="IV. EXPERIMENTAL METHODOLOGY"></a>IV. EXPERIMENTAL METHODOLOGY</h2><p>两个性能指标：<strong>Throughput</strong>（交易提交到账本的速率）和 <strong>Latency</strong>（从客户端发送提案到交易上链的时间）。</p><p>延时主要由以下部分组成：</p><ul><li>Endorsement latency：客户端收集提案响应以及背书所花的时间。</li><li>Broadcast latency：客户端传播交易到排序节点和排序节点验证客户端的时间。</li><li>Commit latency：节点验证和提交交易的时间。</li><li>Ordering latency：交易排序所用的时间（本文未讨论）。</li></ul><p>本文又定义了三个区块级别的延时：</p><ul><li>VSCC validation latency：验证一个区块所有交易背书的签名集的时间。</li><li>MVCC validation latency：采用多版本并发控制验证一个区块所有交易的时间。</li><li>Ledger update latency：根据一个区块有效交易的写集改变数据库状态的时间。</li></ul><p>使用 <a href="https://github.com/thakkarparth007/fabric-load-gen">load generator</a> 生成交易，<a href="https://github.com/cendhu/fetch-block">fetch-block</a> 测试。</p><h3 id="A-Setup-and-Workloads"><a href="#A-Setup-and-Workloads" class="headerlink" title="A. Setup and Workloads"></a>A. Setup and Workloads</h3><p><img src="/Paper-Fabric-Optimizing/3.png" alt="Experimental Setup"></p><p>4 个组织，每个组织 2 个背书节点，1 个排序节点（硬件配置略）。</p><h2 id="V-EXPERIMENTAL-RESULTS"><a href="#V-EXPERIMENTAL-RESULTS" class="headerlink" title="V. EXPERIMENTAL RESULTS"></a>V. EXPERIMENTAL RESULTS</h2><p><img src="/Paper-Fabric-Optimizing/4.png" alt="默认配置"></p><h3 id="A-Impact-of-Transaction-Arrival-Rate-and-Block-Size"><a href="#A-Impact-of-Transaction-Arrival-Rate-and-Block-Size" class="headerlink" title="A. Impact of Transaction Arrival Rate and Block Size"></a>A. Impact of Transaction Arrival Rate and Block Size</h3><p><img src="/Paper-Fabric-Optimizing/5.png" alt="Impact of the block size and transaction arrival rate on performance"></p><ul><li><p><strong>Observation 1</strong>：throughput 随交易到达率线性增长，直到 140 tps 左右饱和，在饱和点附近延时显著增长。这是因为验证阶段 VSCC 队列中等待的有序交易数量显著增长，影响了提交延迟。进一步提高交易到达率并不会影响背书延时和广播延时，仅影响提交延时，这是因为 VSCC 利用单个 vCPU，新的交易提案使用了对等节点上的其他 vCPU 进行模拟和背书。所以只有验证阶段会成为性能瓶颈。</p></li><li><p><strong>Observation 2</strong>：交易到达率低于饱和点时，区块越大延时越高。原因是随着块大小的增加，排序服务的块创建时间增加，因此平均而言，交易在排序节点等待更长的时间。</p></li><li><p><strong>Observation 3</strong>：交易到达率高于饱和点时，区块越大延时越低。这是因为验证和提交一个大小为 n 的块所花费的时间总是小于验证和提交 m 个大小为 n&#x2F;m 的块所花的时间。</p></li><li><p><strong>Observation 4</strong>：当区块大小低于某个阈值时，延迟随着到达速率的增加而减少；高于阈值时，延迟随着到达率的增加而增加。对于较小的区块和较高的到达速率，块的创建速度更快，减少交易在排序节点等待的时间。对于较大的区块，随着到达率的增加，块中的事务数量增加，验证和提交阶段所花费的时间也增加了。</p></li><li><p><strong>Observation 5</strong>：即使在 throughput 达到峰值时，资源利用率也非常低。原因是在块的 VSCC 验证阶段执行的 CPU 密集型任务一次只处理一个事务。由于这种串行执行，只使用了一个 vCPU。</p></li><li><p><strong>Guideline 1</strong>：当交易到达率预计低于饱和点时，为了实现应用程序更低的延迟，始终使用更小的块。在这种情况下，吞吐量将与到达速率相匹配。</p></li><li><p><strong>Guideline 2</strong>：当交易到达率预计较高时，为了实现更高的吞吐量和更低的延迟，使用更大的块。</p></li><li><p><strong>Action Item 1</strong>：CPU 资源利用不足，潜在的优化是在 VSCC 验证阶段一次处理多个事务。</p></li></ul><h3 id="B-Impact-of-Endorsement-Policy"><a href="#B-Impact-of-Endorsement-Policy" class="headerlink" title="B. Impact of Endorsement Policy"></a>B. Impact of Endorsement Policy</h3><p><img src="/Paper-Fabric-Optimizing/6.png" alt="Impact of different endorsement policies"></p><p>研究不同的背书策略对性能影响，其中 a b c d 是四个不同的组织。</p><p><img src="/Paper-Fabric-Optimizing/7.png" alt="VSCC latency, and resource utilization for various endorsement policies (arrival rate = 125)"></p><ul><li><p><strong>Observation 6</strong>：多个子策略和多个加密签名验证的组合影响了性能（CPU 利用率和 VSCC 延迟）。1 和 4 背书策略没有子策略，2 和 3 AND&#x2F;OR 策略实现的吞吐量分别比其他策略低 7% 和 20%。</p></li><li><p><strong>Guideline 3</strong>：使用较少数量的子策略和签名来制定策略实现更高性能。</p></li><li><p><strong>Action Item 2</strong>：由于加密操作是 CPU 密集型的，我们可以通过维护反序列化身份及其 MSP 信息的缓存来避免某些重复操作。身份是长期存在的，并且维护单独的证书吊销列表（CRL）。</p></li></ul><h3 id="C-Impact-of-Channels-and-Resource-Allocation"><a href="#C-Impact-of-Channels-and-Resource-Allocation" class="headerlink" title="C. Impact of Channels and Resource Allocation"></a>C. Impact of Channels and Resource Allocation</h3><p>我们将不同信道数量的到达率分为两类：<strong>non-overloaded</strong>（延迟在 [0.4-1s]）和 <strong>overloaded</strong>（延迟范围 [30-40s]）。</p><p>Number of Channels: 1, 2, 4, 8, 16.<br>Tx. Arrival Rate: 125 to 250 tps with a step of 25.</p><p><img src="/Paper-Fabric-Optimizing/8.png" alt="Impact of the number of channels on performance"></p><ul><li><strong>Observation 7</strong>：随着通道数量的增加，吞吐量增加，延迟减少，CPU等资源利用率也有所提高。这是因为每个通道都独立于其他通道，并维护自己的区块链。因此，多个块（每个通道一个）的验证阶段和最终账本更新并行执行，这增加了 CPU 利用率，从而提高了吞吐量。</li></ul><p><img src="/Paper-Fabric-Optimizing/9.png" alt="Impact of the number of vCPU on throughput &amp; various latencies with 4 channels (arrival rate = 350 tps) and 16 channels (arrival rate = 850 tps)"></p><ul><li><strong>Observation 8</strong>：在中等负载下，当分配的 vCPU 数量小于通道数时，性能下降。由于 CPU 资源的大量竞争，平均背书和提交延迟都呈爆炸式增长（分别从 37ms 到 21s 和 640ms 到 49s）。</li></ul><p><img src="/Paper-Fabric-Optimizing/10.png" alt="Impact of heterogeneous setup"></p><ul><li><p><strong>Observation 9</strong>：在中等负载下，即使分配给 8 个对等点中的 2 个对等点的 vCPU 数量小于通道数，性能也会下降。原因有两个，一是来自功能较弱的对等节点的背书请求超时，二是专门针对读写事务的 MVCC 冲突。</p></li><li><p><strong>Guideline 4</strong>：为了实现更高的吞吐量和更低的延迟，最好为每个通道分配至少一个 vCPU。为了优化 vCPU 分配，我们需要确定每个通道的预期负载，并相应地分配足够的 vCPU。</p></li><li><p><strong>Guideline 5</strong>：为了实现更高的吞吐量和更低的延迟，最好避免异构对等节点，因为系统性能将由功能较弱的对等节点决定。</p></li><li><p><strong>Action Item 3</strong>：可以改进通道内和通道间的交易处理，以更好地利用额外的 CPU 能力。</p></li></ul><h3 id="D-Impact-of-Ledger-Database"><a href="#D-Impact-of-Ledger-Database" class="headerlink" title="D. Impact of Ledger Database"></a>D. Impact of Ledger Database</h3><p><img src="/Paper-Fabric-Optimizing/11.png" alt="Impact of state database"></p><ul><li><strong>Observation 10</strong>：以 GoLevelDB 作为 Fabric 的状态数据库，事务吞吐量是 CouchDB 的 3 倍。CouchDB 和 GoLevelDB 之间存在显著性能差异的原因是，后者是一个对等节点进程的嵌入式数据库，而前者是通过安全的 HTTP 使用 REST APIs 访问的。因此 CouchDB 的背书延迟、VSCC 延迟、MVCC 延迟和账本更新延迟更高。</li></ul><p><img src="/Paper-Fabric-Optimizing/12.png" alt="Impact of database (arrival rate = 30 tps)"></p><ul><li><p><strong>Observation 11</strong>：对于 CouchDB，背书延迟和账本更新延迟随着每笔交易写入次数的增加而增加。</p></li><li><p><strong>Observation 12</strong>：只有随着每个交易的读操作次数的增加，MVCC 延迟才会增加。</p></li><li><p><strong>Guideline 6</strong>：对于状态数据库来说，GoLevelDB 是一个性能更好的选项。如果对只读事务的富查询支持很重要，那么 CouchDB 是一个更好的选择。</p></li><li><p><strong>Action Item 4</strong>：CouchDB 支持批量读写操作，而不需要额外的事务语义。可以使用批量操作缩短锁的持续时间并提高性能。</p></li><li><p><strong>Action Item 5</strong>：在没有快照隔离级别的情况下，使用 GoLevelDB 和 CouchDB 等数据库会导致背书和账本更新阶段的整个数据库锁定。因此，我们未来的工作是研究如何移除锁或使用支持快照隔离的数据库，如 PostgreSQL。</p></li></ul><h3 id="E-Scalability-and-Fault-Tolerant"><a href="#E-Scalability-and-Fault-Tolerant" class="headerlink" title="E. Scalability and Fault Tolerant"></a>E. Scalability and Fault Tolerant</h3><p>在 Fabric 中，可扩展性可以根据通道数量、加入通道的组织数量以及每个组织的对等节点数量来衡量。从资源消耗的角度来看，背书策略的复杂性控制着网络的可扩展性。即使有大量的组织或节点，如果背书策略只需要少数组织签名，那么性能也不会受到影响。</p><p>节点故障在分布式系统中很常见，因此研究 Fabric 的容错能力很重要。在我们早期的研究中，我们观察到节点故障不会影响性能（在非过载情况下），因为客户端可以从其他可用节点收集背书。在负载较高的情况下，节点在故障后重新加入，并由于丢失块而同步账本，这有很大的延迟。这是因为尽管重新加入的节点处的块处理速率处于峰值，但是其他节点继续以相同的峰值处理速率添加新块。</p><h2 id="VI-OPTIMIZATIONS-STUDIED"><a href="#VI-OPTIMIZATIONS-STUDIED" class="headerlink" title="VI. OPTIMIZATIONS STUDIED"></a>VI. OPTIMIZATIONS STUDIED</h2><p>三个简单优化方案和它们结合起来的效果。</p><h3 id="A-MSP-Cache"><a href="#A-MSP-Cache" class="headerlink" title="A. MSP Cache"></a>A. MSP Cache</h3><p>由于加密操作非常占用 CPU，在本节中，我们研究了在加密模块中的以下两个操作中使用缓存的效率：</p><ol><li>身份的反序列化</li><li>组织 MSP 的身份验证</li></ol><p>为了避免每次都对序列化的身份标识进行反序列化，我们使用以序列化形式为键的哈希映射来缓存反序列化的身份。类似地，为了避免每次使用多个 MSP 验证一个身份，我们使用了一个哈希表，其中身份作为键，值是该身份所属的相应 MSP。</p><p><img src="/Paper-Fabric-Optimizing/13.png" alt="Impact of MSP cache"></p><p>与普通对等节点相比，由于 MSP 缓存，吞吐量平均增加了 3 倍。</p><h3 id="B-Parallel-VSCC-Validation-of-a-Block"><a href="#B-Parallel-VSCC-Validation-of-a-Block" class="headerlink" title="B. Parallel VSCC Validation of a Block"></a>B. Parallel VSCC Validation of a Block</h3><p>并行验证多个交易的背书，以利用闲置的 CPU 并提高整体性能。为了实现这一点，我们在对等节点启动时为每个通道创建了可配置数量的工作线程。每个工作线程根据其背书策略验证一个交易的背书签名集。</p><p><img src="/Paper-Fabric-Optimizing/14.png" alt="Impact of parallel VSCC validation on multichannel setup"></p><p>对于每个通道，我们分配了与块大小相等的工作线程。在一个通道的非过载情况下，对于 30 的块大小，吞吐量从 130 tps 提升到 800 tps（提高了6.3倍），对于 300 的块大小提升到 980 tps（7.5倍）。块内交易的并行 VSCC 验证显著提高了单个通道的性能。但是随着通道数量的增加，改善的百分比下降。这是因为默认情况下，多个通道会导致块（而不是交易）的并行验证，因此只有少量可用的 vCPU 可用于并行 VSCC。</p><h3 id="C-Bulk-Read-x2F-Write-During-MVCC-Validation-amp-Commit"><a href="#C-Bulk-Read-x2F-Write-During-MVCC-Validation-amp-Commit" class="headerlink" title="C. Bulk Read&#x2F;Write During MVCC Validation &amp; Commit"></a>C. Bulk Read&#x2F;Write During MVCC Validation &amp; Commit</h3><p>在使用 CouchDB 作为状态数据库进行 MVCC 验证时，对于块中的每个交易读集中的每个键，使用安全的 HTTPS 协议进行 GET REST API 调用来检索最后提交的版本号。在提交阶段，对于块中的每个有效交易写集中的每个键，使用 GET REST API 调用来检索修订号。最后，对于写集中的每个条目，使用 PUT REST API 调用来提交记录。由于这些多个 REST API 调用，性能显著下降。</p><p>为了减少 REST API 调用的数量，CouchDB 建议使用批量操作。因此，我们使用 Fabric 中现有的 BatchRetrieval API，通过每个块的单个 GET REST API 调用，将多个键的版本和修订号批量加载到缓存中。为了增强账本更新过程，我们使用 BatchUpdate API 来提交一批记录，每个块调用一个 PUT REST API。此外，我们在 VSCC 中引入了一个缓存，以减少对 CouchDB 的调用，从而获得每个交易的背书策略。</p><p><img src="/Paper-Fabric-Optimizing/15.png" alt="Impact of bulk read during the MVCC validation and ledger update on the performance"></p><p>要与上文非批量读写进行比较，对于单次写入的事务，性能从 50 tps 显著提高到 115 tps（2.3 倍）。对于多次写入（3-w 和 5-w），吞吐量从 26 tps 增加到 100 tps（3-w 为 3.8倍），从 18 tps 提高到 90 tps（5-w 为 5 倍）。我们注意到读写事务也有类似的改进。</p><h3 id="D-Combinations-of-Optimizations"><a href="#D-Combinations-of-Optimizations" class="headerlink" title="D. Combinations of Optimizations"></a>D. Combinations of Optimizations</h3><p><img src="/Paper-Fabric-Optimizing/16.png" alt="Configuration"></p><p><img src="/Paper-Fabric-Optimizing/17.png" alt="Impact of all the three optimizations on the performance with different block sizes"></p><p><img src="/Paper-Fabric-Optimizing/18.png" alt="Impact of all the three optimizations on the performance with a simple endorsement policy and different number of channels"></p><h2 id="VII-RELATED-WORK"><a href="#VII-RELATED-WORK" class="headerlink" title="VII. RELATED WORK"></a>VII. RELATED WORK</h2><p>略</p><h2 id="VIII-CONCLUSION-amp-FUTURE-WORK"><a href="#VIII-CONCLUSION-amp-FUTURE-WORK" class="headerlink" title="VIII. CONCLUSION &amp; FUTURE WORK"></a>VIII. CONCLUSION &amp; FUTURE WORK</h2><p>略</p><h2 id="IX-ACKNOWLEDGEMENTS"><a href="#IX-ACKNOWLEDGEMENTS" class="headerlink" title="IX. ACKNOWLEDGEMENTS"></a>IX. ACKNOWLEDGEMENTS</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(06)：架构初探</title>
    <link href="/ByteDance-6/"/>
    <url>/ByteDance-6/</url>
    
    <content type="html"><![CDATA[<p>本文简单介绍关于架构的知识。</p><span id="more"></span><h2 id="1-什么是架构"><a href="#1-什么是架构" class="headerlink" title="1 什么是架构"></a>1 什么是架构</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Q：如何给架构下定义？</strong></p><p>A：架构，又称软件架构：</p><ul><li>是有关软件整体结构与组件的抽象描述。</li><li>用于指导软件系统各个方面的设计。</li></ul><p>实现一个软件有很多种方法，架构在<strong>方法选择</strong>上起着至关重要的指导作用。</p><p><strong>Q：架构的重要性？</strong></p><p>A：拿盖房子来做举例子。</p><p>我们都知道，地基对于一栋楼房的主要性，架构对于一个软件的重要性也是类似的：</p><ul><li>架构没设计好，软件容易崩，用户体验上不去。最终要么重构，要么放弃。</li><li>架构设计好了，软件的稳定性上去了，用户体验高了，口碑一点点就打造出来了。</li><li>良好的架构基础，也为软件的未来发展提供了更多的可能。为用户赋能，实现自身价值。</li></ul><h3 id="1-2-单机架构"><a href="#1-2-单机架构" class="headerlink" title="1.2 单机架构"></a>1.2 单机架构</h3><p>All in one，所有的东西都在一个进程里，部署在一个机器上。</p><p><img src="/ByteDance-6/1.png" alt="单机"></p><p>优点：</p><ul><li>简单</li></ul><p>缺点：</p><ul><li>运维需要停服，用户体验较差</li><li>承载能力有限（c10k 问题）</li></ul><h3 id="1-3-单体架构"><a href="#1-3-单体架构" class="headerlink" title="1.3 单体架构"></a>1.3 单体架构</h3><p>在单机架构的基础上，将进程部署到多个机器上。</p><p><img src="/ByteDance-6/2.png" alt="单体"></p><p>优点：</p><ul><li>具备水平扩容能力</li><li>运维不需要停服</li></ul><p>缺点：</p><ul><li>后端进程职责太多，越来越臃肿</li><li>爆炸半径较大，进程中一个很小的模块出现问题，都可能导致整个进程崩溃</li></ul><h3 id="1-4-垂直应用架构"><a href="#1-4-垂直应用架构" class="headerlink" title="1.4 垂直应用架构"></a>1.4 垂直应用架构</h3><p>在单机架构基础上，将进程按照某种依据切分开。比如，A 软件和 B 软件的后端原先采用单机架构部署，那就是一个进程部署在多个机器上；如果用垂直应用架构，可以将 A 和 B 的后端拆分为 A、B 两个进程，然后再按照单体模式的思路，部署在多个机器上。</p><p><img src="/ByteDance-6/3.png" alt="垂直"></p><p>优点：</p><ul><li>一定程度上减少了后端进程职责</li><li>一定程度上缩小爆炸半径</li></ul><p>缺点：</p><ul><li>没有根本解决单体架构的问题</li></ul><h3 id="1-5-SOA"><a href="#1-5-SOA" class="headerlink" title="1.5 SOA"></a>1.5 SOA</h3><p>SOA（Service-Oriented Architecture，面向服务架构）中，服务为一等公民，将进程按照不同的功能单元进行抽象，拆分为”服务“。有了服务之后，SOA 还为服务之间的通信定义了标准，保证各个服务之间通讯体验的一致性。</p><p><img src="/ByteDance-6/4.png" alt="SOA"></p><p>优点：</p><ul><li>各服务的职责更清晰</li><li>运维粒度减小到服务，爆炸半径可控</li></ul><p>缺点：</p><ul><li>ESB (企业服务总线) 往往需要一整套解决方案</li></ul><h3 id="1-6-微服务"><a href="#1-6-微服务" class="headerlink" title="1.6 微服务"></a>1.6 微服务</h3><p>在 SOA 架构中，ESB 起到了至关重要的作用。但从架构拓扑来看，它更像是一个集中式的模块。有一个 SOA 去中心化演进的分支，最终的形态便是微服务。</p><p><img src="/ByteDance-6/5.png" alt="微服务"></p><p>优点：</p><ul><li>兼具 SOA 解决的问题</li><li>服务间的通信更敏捷、灵活</li></ul><p>缺点：</p><ul><li>运维成本</li></ul><h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h3><ul><li><p>架构演进的初衷：满足软件迭代诉求，提高迭代效率</p></li><li><p>架构演进的思路：垂直切分——分布式，水平切分——分层&#x2F;模块化</p></li></ul><h2 id="2-企业级后端架构剖析"><a href="#2-企业级后端架构剖析" class="headerlink" title="2 企业级后端架构剖析"></a>2 企业级后端架构剖析</h2><h3 id="2-1-云计算"><a href="#2-1-云计算" class="headerlink" title="2.1 云计算"></a>2.1 云计算</h3><p>是指通过软件自动化管理，提供计算资源的服务网络，是现代互联网大规模数据分析和存储的基石。</p><p><strong>云计算基础：</strong></p><ul><li><p>虚拟化技术</p><ul><li>硬件层面（VM 虚拟机）- KVM&#x2F;Xen&#x2F;VMware</li><li>操作系统层面（Container 容器）- LCX&#x2F;Docker&#x2F;Kata Container</li><li>网络层面 - Linux Bridge&#x2F;Open v Switch</li></ul></li><li><p>编排方案</p><ul><li>VM - OpenStack&#x2F;VMWare Workstation</li><li>Container - Kubernetes&#x2F;Docker Swarm</li></ul></li></ul><p><strong>云计算架构：</strong></p><ul><li><p>云服务</p><ul><li>IaaS - Infrastructure as a Service，云基础设施，对底层硬件资源池的抽象</li><li>PaaS - Platform as a Service，基于资源池抽象，对上层提供的弹性资源平台</li><li>SaaS - Software as a Service，基于弹性资源平台构建的云服务</li><li>FaaS - Function as a Service，更轻量级的函数服务。好比 LeetCode 等 OJ，刷题时只需要实现函数，不需要关注输入输出流</li></ul></li><li><p>云部署模式</p><ul><li>私有云 - 企业自用</li><li>公有云 - AWS&#x2F;Azure&#x2F;Google Cloud&#x2F;Huawei</li><li>混合云</li></ul></li></ul><h3 id="2-2-云原生"><a href="#2-2-云原生" class="headerlink" title="2.2 云原生"></a>2.2 云原生</h3><p>云原生，实际是云原生计算的简称，它是云计算发展到现在的一种形态。</p><p><img src="/ByteDance-6/6.png" alt="云原生"></p><p>云原生技术为组织（公司）在公有云、自由云、混合云等新型的动态环境中，构建和运行可弹性拓展的应用提供了可能。 它的代表技术：</p><ul><li>弹性资源</li><li>微服务架构</li><li>DevOps</li><li>服务网格</li></ul><h4 id="2-2-1-弹性资源"><a href="#2-2-1-弹性资源" class="headerlink" title="2.2.1 弹性资源"></a>2.2.1 弹性资源</h4><p>基于虚拟化技术，提供的可以快速扩缩容的能力。可以分为<strong>弹性计算资源</strong>和<strong>弹性存储资源</strong>两个方面。</p><ul><li><p><strong>弹性计算资源：</strong></p><ul><li><p>计算资源调度</p><ul><li>在线计算 - 互联网后端服务</li><li>离线计算 - 大数据分析。Map-Reduce&#x2F;Spark&#x2F;Flinnk</li></ul></li><li><p>消息队列</p><ul><li>在线队列 - 削峰、解耦</li><li>离线队列 - 结合数据分析的一整套方案，如 ELK</li></ul></li></ul></li><li><p><strong>弹性存储资源：</strong></p><ul><li><p>经典存储</p><ul><li>对象存储 - 视频、图片等。结合 CDN 等技术，可以为应用提供丰富的多媒体能力</li><li>大数据存储 - 应用日志、用户数据等。结合数据挖掘、机器学习等技术，提高应用的体验</li></ul></li><li><p>关系型数据库</p></li><li><p>元数据</p><ul><li>服务发现</li></ul></li><li><p>NoSQL</p><ul><li>KV 存储 - Redis</li><li>文档存储 - Mongo</li></ul></li></ul></li></ul><p>在云原生的大背景下，不论是计算资源还是存储资源，他们都像是服务一样供用户使用。</p><h4 id="2-2-2-DevOps"><a href="#2-2-2-DevOps" class="headerlink" title="2.2.2 DevOps"></a>2.2.2 DevOps</h4><p>DevOps 是云原生时代软件交付的利器，贯穿整个软件开发周期。结合自动化流程，提高软件开发、交付效率。</p><p><img src="/ByteDance-6/7.png" alt="DevOps"></p><h4 id="2-2-3-微服务架构"><a href="#2-2-3-微服务架构" class="headerlink" title="2.2.3 微服务架构"></a>2.2.3 微服务架构</h4><p>微服务架构下，服务之间的通讯标准是基于协议而不是 ESB 的。</p><ul><li>HTTP - H1&#x2F;H2</li><li>RPC - Apache Thrift&#x2F;gRPC</li></ul><p><img src="/ByteDance-6/8.png" alt="微服务"></p><p>如何在 HTTP 和 RPC 之间选择？</p><ul><li>性能 - RPC 协议往往具备较好的压缩率，性能较高。如 Thrift, Protocol Buffers</li><li>服务治理 - RPC 中间件往往集成了丰富的服务治理能力。如 熔断、降级、超时等</li><li>可解释性 - HTTP 通信的协议往往首选 JSON，可解释性、可调试性更好</li></ul><h4 id="2-2-4-服务网格"><a href="#2-2-4-服务网格" class="headerlink" title="2.2.4 服务网格"></a>2.2.4 服务网格</h4><ul><li>微服务之间通讯的中间层</li><li>一个高性能网络代理</li><li>将流量层面的逻辑与业务进程解耦</li></ul><p><img src="/ByteDance-6/9.png" alt="Service Mesh"></p><p>没有什么是加一层代理解决不了的问题，服务网格相比较于 RPC&#x2F;HTTP 框架：</p><ul><li>实现了异构系统治理的统一化</li><li>服务网格的数据平面代理与业务进程采取进程间通信的模式，使得流量相关的逻辑（包含治理）与业务进程解耦，生命周期也更容易管理</li></ul><h2 id="3-企业级后端架构的挑战"><a href="#3-企业级后端架构的挑战" class="headerlink" title="3 企业级后端架构的挑战"></a>3 企业级后端架构的挑战</h2><ul><li><p>基础设施层面：</p><p>  Q：我们总说，云是弹性的，也就是说，在用户的角度，云提供的资源是无限的。然而，云背后的物理资源是有限的。在企业级后端架构里，云如何解决近乎无限的弹性资源和有限的物理资源之间的矛盾？</p><p>  Q：闲时的资源就这么空着吗？如何提高资源利用率，提高物理资源的价值转换率？</p></li><li><p>用户层面：</p><p>  Q：上了云原生微服务后，服务之间的通信开销较大，应该如何做成本优化？</p><p>  Q：微服务看起来没有那么美好，抖动导致的运维成本较高，如何解决？</p><p>  Q：异构的物理环境应该对用户是透明的，如何屏蔽这些细节？</p></li></ul><h3 id="3-1-离在线资源并池"><a href="#3-1-离在线资源并池" class="headerlink" title="3.1 离在线资源并池"></a>3.1 离在线资源并池</h3><p>考虑到在线业务的潮汐性，物理资源的用量不是一成不变的。离在线资源并池，可以：</p><ul><li>提高物理资源利用率</li><li>提供更多的弹性资源</li></ul><p><img src="/ByteDance-6/10.png" alt="离在线资源并池"></p><h3 id="3-2-自动扩缩容"><a href="#3-2-自动扩缩容" class="headerlink" title="3.2 自动扩缩容"></a>3.2 自动扩缩容</h3><p>利用在线业务潮汐性自动扩缩容。</p><h3 id="3-3-微服务亲合性部署"><a href="#3-3-微服务亲合性部署" class="headerlink" title="3.3 微服务亲合性部署"></a>3.3 微服务亲合性部署</h3><p>微服务之间的通信成本较高，是否可以：</p><ul><li>形态上是微服务架构</li><li>通信上是单体架构</li></ul><p>亲合性部署，通过将微服务调用形态与资源调度系统结合，将一些调用关系紧密、通信量大的服务部署在同一个机器上，并且使用 IPC 代替 RPC 的方式，降低网络通信带来的开销。</p><p><img src="/ByteDance-6/11.png" alt="微服务亲合性部署"></p><ul><li>将满足亲合性条件的容器调度到一台宿主机</li><li>微服务中间件与服务网格通过共享内存通信</li><li>服务网格控制面实施灵活、动态的流量调度</li></ul><h3 id="3-4-流量治理"><a href="#3-4-流量治理" class="headerlink" title="3.4 流量治理"></a>3.4 流量治理</h3><p>核心收益：</p><ul><li>提高微服务调用容错性</li><li>容灾</li><li>进一步提高开发效率，DevOps 发挥到极致</li></ul><p>解决思路：基于微服务中间件 &amp; 服务网格的流量治理</p><ul><li>熔断、重试</li><li>单元化</li><li>复杂环境（功能、预览）的流量调度</li></ul><h2 id="4-后端架构实战"><a href="#4-后端架构实战" class="headerlink" title="4 后端架构实战"></a>4 后端架构实战</h2><p><img src="/ByteDance-6/12.png"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 03. 链表</title>
    <link href="/Algorithm-list/"/>
    <url>/Algorithm-list/</url>
    
    <content type="html"><![CDATA[<p>链表相关题目。</p><span id="more"></span><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h2><h3 id="1-1-类型"><a href="#1-1-类型" class="headerlink" title="1.1 类型"></a>1.1 类型</h3><ul><li><strong>单链表</strong></li></ul><p><img src="/Algorithm-list/1.png"></p><ul><li><strong>双链表</strong></li></ul><p><img src="/Algorithm-list/2.png"></p><ul><li><strong>循环链表</strong></li></ul><p><img src="/Algorithm-list/3.png"></p><h3 id="1-2-存储方式"><a href="#1-2-存储方式" class="headerlink" title="1.2 存储方式"></a>1.2 存储方式</h3><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><h3 id="1-3-操作"><a href="#1-3-操作" class="headerlink" title="1.3 操作"></a>1.3 操作</h3><ul><li><strong>定义</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;<br>    Val  <span class="hljs-type">int</span><br>    Next *ListNode<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>删除</strong></li></ul><p><img src="/Algorithm-list/4.png"></p><p>建议使用虚拟头节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElements</span><span class="hljs-params">(head *ListNode, val <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dmHead := &amp;ListNode&#123;&#125;<br>    dmHead.Next = head<br>    cur, pre := head, dmHead<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> cur.Val == val &#123;<br>            pre.Next = cur.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre = pre.Next<br>        &#125;<br>        cur = cur.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dmHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>添加</strong></li></ul><p><img src="/Algorithm-list/5.png"></p><h3 id="1-4-性能分析"><a href="#1-4-性能分析" class="headerlink" title="1.4 性能分析"></a>1.4 性能分析</h3><p><img src="/Algorithm-list/6.png"></p><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2 题目"></a>2 题目</h2><h3 id="2-1-两两交换"><a href="#2-1-两两交换" class="headerlink" title="2.1 两两交换"></a>2.1 <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换</a></h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    dmHead := &amp;ListNode&#123;Next: head&#125;<br>    pre, cur := dmHead, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next.Next<br>        pre.Next = cur.Next<br>        cur.Next.Next = cur<br>        cur.Next = next<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dmHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-删除结点"><a href="#2-2-删除结点" class="headerlink" title="2.2 删除结点"></a>2.2 <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除结点</a></h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br>    dmHead := &amp;ListNode&#123;Next: head&#125;<br>    pre, cur := dmHead, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> count != n &#123;<br>            count++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre = pre.Next<br>        &#125;<br>        cur = cur.Next<br>    &#125;<br>    pre.Next = pre.Next.Next<br>    <span class="hljs-keyword">return</span> dmHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-相交链表"><a href="#2-3-相交链表" class="headerlink" title="2.3 相交链表"></a>2.3 <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></h3><p>给你两个单链表的头节点 headA 和 headB，请你找出并返回两个单链表相交的起始节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode1</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    vis := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> tmp := headA; tmp != <span class="hljs-literal">nil</span>; tmp = tmp.Next &#123;<br>        vis[tmp] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> tmp := headB; tmp != <span class="hljs-literal">nil</span>; tmp = tmp.Next &#123;<br>        <span class="hljs-keyword">if</span> vis[tmp] &#123;<br>            <span class="hljs-keyword">return</span> tmp<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode2</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    curA := headA<br>    curB := headB<br>    lenA, lenB := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 求 A，B 的长度</span><br>    <span class="hljs-keyword">for</span> curA != <span class="hljs-literal">nil</span> &#123;<br>        curA = curA.Next<br>        lenA++<br>    &#125;<br>    <span class="hljs-keyword">for</span> curB != <span class="hljs-literal">nil</span> &#123;<br>        curB = curB.Next<br>        lenB++<br>    &#125;<br>    <span class="hljs-keyword">var</span> step <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> fast, slow *ListNode<br>    <span class="hljs-comment">// 求长度差，并且让更长的链表先走相差的长度</span><br>    <span class="hljs-keyword">if</span> lenA &gt; lenB &#123;<br>        step = lenA - lenB<br>        fast, slow = headA, headB<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        step = lenB - lenA<br>        fast, slow = headB, headA<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; step; i++ &#123;<br>        fast = fast.Next<br>    &#125;<br>    <span class="hljs-comment">// 遍历两个链表遇到相同则跳出遍历</span><br>    <span class="hljs-keyword">for</span> fast != slow &#123;<br>        fast = fast.Next<br>        slow = slow.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> fast<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-环形链表-II"><a href="#2-4-环形链表-II" class="headerlink" title="2.4 环形链表 II"></a>2.4 <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a></h3><p>判断链表中是否有环，返回链表开始入环的第一个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>        <span class="hljs-keyword">if</span> slow == fast &#123;<br>            <span class="hljs-keyword">for</span> slow != head &#123;<br>                slow = slow.Next<br>                head = head.Next<br>            &#125;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-反转链表"><a href="#2-5-反转链表" class="headerlink" title="2.5 反转链表"></a>2.5 <a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre *ListNode<br>    cur := head<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br></code></pre></td></tr></table></figure><p>注意申明 pre 的时候不可以用 <code>pre := &amp;ListNode&#123;&#125;</code>，否则其值是 0 而不是 nil。</p><h3 id="2-6-LRU-缓存"><a href="#2-6-LRU-缓存" class="headerlink" title="2.6 LRU 缓存"></a>2.6 <a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a></h3><p>哈希表 + 双向链表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    cp, size <span class="hljs-type">int</span><br>    rec <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Node<br>    head, tail *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    Key, Val <span class="hljs-type">int</span><br>    Pre, Next *Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    r := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Node)<br>    h, t := &amp;Node&#123;&#125;, &amp;Node&#123;&#125;<br>    h.Next = t<br>    t.Pre = h<br>    newLRU := LRUCache &#123;cp: capacity, size: <span class="hljs-number">0</span>, rec: r, head: h, tail: t&#125;<br>    <span class="hljs-keyword">return</span> newLRU<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    node, exist := this.rec[key]<br>    <span class="hljs-keyword">if</span> exist &#123;<br>        this.removeNode(node)<br>        this.addToHead(node)<br>        <span class="hljs-keyword">return</span> node.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>    node, exist := this.rec[key]<br>    <span class="hljs-keyword">if</span> exist &#123;<br>        this.rec[key].Val = value<br>        this.removeNode(node)<br>        this.addToHead(node)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node = &amp;Node&#123;Key: key, Val: value&#125;<br>        this.rec[key] = node<br>        <span class="hljs-keyword">if</span> this.size == this.cp &#123;<br>            <span class="hljs-built_in">delete</span>(this.rec, this.tail.Pre.Key)<br>            this.removeTail()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            this.size++<br>        &#125;<br>        this.addToHead(node)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> addToHead(node *Node) &#123;<br>    nx := this.head.Next<br>    this.head.Next = node<br>    node.Next = nx<br>    nx.Pre = node<br>    node.Pre = this.head<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeNode(node *Node) &#123;<br>    pr, nx := node.Pre, node.Next<br>    pr.Next = nx<br>    nx.Pre = pr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeTail() &#123;<br>    this.removeNode(this.tail.Pre)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(05)：规则引擎</title>
    <link href="/ByteDance-5/"/>
    <url>/ByteDance-5/</url>
    
    <content type="html"><![CDATA[<p>本文介绍规则引擎。</p><p>项目代码：<a href="https://github.com/qimengxingyuan/young_engine.git">https://github.com/qimengxingyuan/young_engine.git</a></p><span id="more"></span><h2 id="1-规则引擎"><a href="#1-规则引擎" class="headerlink" title="1 规则引擎"></a>1 规则引擎</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>规则引擎是一种嵌入在应用服务中的组件，可以将灵活多变的业务决策从服务代码中分离出来。</p><p>通过使用预定义的语义模块来编写业务逻辑规则。在执行时接受数据输入、解释业务规则，并做出决策。规则引擎能大大提高系统的灵活性和扩展性。</p><p><img src="/ByteDance-5/1.png" alt="old"></p><p>解决开发人员重复编码问题，业务决策与服务本身解耦，提高服务的可维护性。</p><p><img src="/ByteDance-5/2.png" alt="new"></p><h3 id="1-1-1-组成部分"><a href="#1-1-1-组成部分" class="headerlink" title="1.1.1 组成部分"></a>1.1.1 组成部分</h3><ul><li>数据输入</li><li>规则理解</li><li>规则执行</li></ul><h2 id="2-编译原理基本概念"><a href="#2-编译原理基本概念" class="headerlink" title="2 编译原理基本概念"></a>2 编译原理基本概念</h2><h3 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2.1 编译"></a>2.1 编译</h3><p>编译的过程就是 把某种语言的源程序，<strong>在不改变语义的条件下</strong>，转换成另一种语言程序(目标语言程序)。</p><p><img src="/ByteDance-5/3.jpg" alt="编译"></p><ul><li>如果源代码编译后要在操作系统上运行，那目标代码就是汇编&#x2F;机器代码。</li><li>如果编译后是在虚拟机里执行，那目标代码就可以不是汇编代码，而是一种解释器可以理解的中间形式的代码即可。</li></ul><p>有的语言提前把代码一次性转换完毕，这种就是编译型语言，用的转换工具就叫编译器，比如 C、C++、Go。一次编译可重复执行。</p><p>有的语言则可以一边执行一边转化，用到哪里了就转哪里，这种就是解释性语言，用的转化工具叫虚拟机或者解释器，比如 java、python、javascript。</p><ul><li>Java 既有编译又有解释。但是编译并没有直接编译成机器码，而是编译成字节码，然后再放到虚拟机中执行。</li><li>Python 执行过程也是经过两个阶段，先编译成字节码 .pyc 再放到虚拟机中去执行。</li></ul><h3 id="2-2-词法分析（Lexical-Analysis）"><a href="#2-2-词法分析（Lexical-Analysis）" class="headerlink" title="2.2 词法分析（Lexical Analysis）"></a>2.2 词法分析（Lexical Analysis）</h3><p>把源代码字符串转换为词法单元（Token）。</p><p><img src="/ByteDance-5/4.png" alt="Lexical Analysis"></p><h3 id="2-3-语法分析（Syntax-Analysis）"><a href="#2-3-语法分析（Syntax-Analysis）" class="headerlink" title="2.3 语法分析（Syntax Analysis）"></a>2.3 语法分析（Syntax Analysis）</h3><p>词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构。这棵树叫做<strong>抽象语法树</strong>（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点。</p><ul><li><p><strong>上下文无关语法</strong>（Context-Free Grammar）</p><p>  语言句子无需考虑上下文，就可以判断正确性。</p><p>  巴科斯范式（BNF）是描述上下文无关理论的一种具体方法，通过 BNF 可以实现上下文无关文法的具体化、公式化、科学化，是实现代码解析的必要条件。</p></li><li><p><strong>递归下降算法</strong>（Recursive Descent Parsing）</p><p>  递归下降算法就是自顶向下构造语法树。</p><p>  不断对 Token 进行语法展开，展开过程可能会遇到递归的情况。</p></li></ul><h2 id="3-设计规则引擎"><a href="#3-设计规则引擎" class="headerlink" title="3 设计规则引擎"></a>3 设计规则引擎</h2><p>详见<a href="https://github.com/qimengxingyuan/young_engine.git">项目代码</a>。</p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 02. 数组</title>
    <link href="/Algorithm-array/"/>
    <url>/Algorithm-array/</url>
    
    <content type="html"><![CDATA[<p>数组相关题目。</p><span id="more"></span><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1 二分查找"></a>1 二分查找</h2><h3 id="1-1-二分法"><a href="#1-1-二分法" class="headerlink" title="1.1 二分法"></a>1.1 <a href="https://leetcode.cn/problems/binary-search/">二分法</a></h3><p>这道题目的前提是数组为<strong>有序数组</strong>，同时题目还强调数组中<strong>无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p>写二分法，区间的定义一般为两种，左闭右闭即 <code>[left, right]</code>，或者左闭右开即 <code>[left, right)</code>。</p><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是 <code>[left, right]</code>：</p><ul><li><code>for left &lt;= right</code> 要使用 <code>&lt;=</code> ，因为 <code>left == right</code> 是有意义的</li><li><code>if nums[middle] &gt; target</code> <code>right</code> 要赋值为 <code>middle - 1</code>，因为当前这个 <code>nums[middle]</code> 一定不是 target</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i &lt;= j &#123;<br>        m := i + (j-i)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target &#123;<br>            i = m + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[m] &gt; target &#123;<br>            j = m - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> m<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = len-<span class="hljs-number">1</span>; i &lt;= j; ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + (j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[k] == target) &#123;<br>                <span class="hljs-keyword">return</span> k;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k] &lt; target) &#123;<br>                i = k + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j = k - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>暴力解法时间复杂度：O(n)</li><li>二分法时间复杂度：O(logn)</li></ul><h3 id="1-2-查找元素"><a href="#1-2-查找元素" class="headerlink" title="1.2 查找元素"></a>1.2 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">查找元素</a></h3><p>在排序数组中查找元素的第一个和最后一个位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    l, r := getLeft(nums, target), getRight(nums, target)<br>    <span class="hljs-keyword">if</span> l == <span class="hljs-number">-2</span> || r == <span class="hljs-number">-2</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> r - l &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;l+<span class="hljs-number">1</span>, r<span class="hljs-number">-1</span>&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeft</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">-2</span><br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i &lt;= j &#123;<br>        m := i + (j-i)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target &#123;<br>            i = m + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = m - <span class="hljs-number">1</span><br>            res = j<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRight</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">-2</span><br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i &lt;= j &#123;<br>        m := i + (j-i)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &gt; target &#123;<br>            j = m - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = m + <span class="hljs-number">1</span><br>            res = i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2 快慢指针"></a>2 快慢指针</h2><h3 id="2-1-移除元素"><a href="#2-1-移除元素" class="headerlink" title="2.1 移除元素"></a>2.1 <a href="https://leetcode.cn/problems/remove-element/">移除元素</a></h3><p>给你一个数组 nums 和一个值 val，你需要<strong>原地</strong>移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。这个题目暴力解法就是两层 for 循环，一个 for 循环遍历数组元素，第二个 for 循环更新数组。</p><p>使用快慢指针可以在一个 for 循环下完成两个 for 循环的工作：</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新新数组下标的位置</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, val <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow, fast := <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> fast &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != val &#123;<br>            nums[slow] = nums[fast]<br>            slow++<br>        &#125; <br>        fast++<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>暴力解法时间复杂度：O(n^2)</li><li>双指针时间复杂度：O(n)</li></ul><h2 id="3-双指针法"><a href="#3-双指针法" class="headerlink" title="3 双指针法"></a>3 双指针法</h2><h3 id="3-1-有序数组的平方"><a href="#3-1-有序数组的平方" class="headerlink" title="3.1 有序数组的平方"></a>3.1 <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方</a></h3><p>给你一个按<strong>非递减顺序</strong>排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p>数组<strong>有序</strong>可以考虑用双指针：</p><ol><li><p>定义一个新数组 result，和 A 数组一样的大小，让 k 指向 result 数组终止位置。</p></li><li><p>如果 <code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么 <code>result[k] = A[j] * A[j]</code>，<code>j--</code>。</p></li><li><p>如果 <code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么 <code>result[k] = A[i] * A[i]</code>，<code>i++</code>。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedSquares</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    pos := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i &lt;= j; &#123;<br>        <span class="hljs-keyword">if</span> nums[i] * nums[i] &gt; nums[j] * nums[j] &#123;<br>            res[pos] = nums[i] * nums[i]<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[pos] = nums[j] * nums[j]<br>            j--<br>        &#125;<br>        pos--<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-比较含退格的字符串"><a href="#3-2-比较含退格的字符串" class="headerlink" title="3.2 比较含退格的字符串"></a>3.2 <a href="https://leetcode.cn/problems/backspace-string-compare/">比较含退格的字符串</a></h3><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。<code>#</code> 代表退格字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    skipS, skipT := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    i, j := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(t)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>                skipS++<br>                i--<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> skipS &gt; <span class="hljs-number">0</span> &#123;<br>                skipS--<br>                i--<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> t[j] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>                skipT++<br>                j--<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> skipT &gt; <span class="hljs-number">0</span> &#123;<br>                skipT--<br>                j--<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> s[i] != t[j] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        i--<br>        j--<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>普通方法是用栈模拟操作，空间复杂度为 O(m + n)。可以使用从后向前的双指针来优化。</p><h2 id="4-滑动窗口"><a href="#4-滑动窗口" class="headerlink" title="4 滑动窗口"></a>4 滑动窗口</h2><h3 id="4-1-长度最小的子数组"><a href="#4-1-长度最小的子数组" class="headerlink" title="4.1 长度最小的子数组"></a>4.1 <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></h3><p>给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其总和大于等于 target 的长度最小的子数组并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>实现滑动窗口，主要确定如下三点：</p><ol><li>窗口内是什么？</li><li>如何移动窗口的起始位置？（本题使用 for 循环一次移动多位）</li><li>如何移动窗口的结束位置？（本题一次移动一位）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(target <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span><br>    l, r, sum := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> r &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        sum += nums[r]<br>        <span class="hljs-keyword">for</span> sum &gt;= target &#123;<br>            <span class="hljs-keyword">if</span> res &gt; (r - l + <span class="hljs-number">1</span>) &#123;<br>                res = r - l + <span class="hljs-number">1</span><br>            &#125;<br>            sum -= nums[l]<br>            l++<br>        &#125; <br>        r++<br>    &#125;<br>    <span class="hljs-keyword">if</span> res == <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>暴力解法时间复杂度：O(n^2)</li><li>滑动窗口时间复杂度：O(n)</li></ul><h2 id="5-模拟过程"><a href="#5-模拟过程" class="headerlink" title="5 模拟过程"></a>5 模拟过程</h2><h3 id="5-1-螺旋矩阵-II"><a href="#5-1-螺旋矩阵-II" class="headerlink" title="5.1 螺旋矩阵 II"></a>5.1 <a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a></h3><p>给你一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateMatrix</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    top, bottom := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span><br>    left, right := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span><br>    num := <span class="hljs-number">1</span><br>    tar := n * n<br>    matrix := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        matrix[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> num &lt;= tar &#123;<br>        <span class="hljs-keyword">for</span> i := left; i &lt;= right; i++ &#123;<br>            matrix[top][i] = num<br>            num++<br>        &#125;<br>        top++<br>        <span class="hljs-keyword">for</span> i := top; i &lt;= bottom; i++ &#123;<br>            matrix[i][right] = num<br>            num++<br>        &#125;<br>        right--<br>        <span class="hljs-keyword">for</span> i := right; i &gt;= left; i-- &#123;<br>            matrix[bottom][i] = num<br>            num++<br>        &#125;<br>        bottom--<br>        <span class="hljs-keyword">for</span> i := bottom; i &gt;= top; i-- &#123;<br>            matrix[i][left] = num<br>            num++<br>        &#125;<br>        left++<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-查找算法"><a href="#6-查找算法" class="headerlink" title="6 查找算法"></a>6 查找算法</h2><h3 id="6-1-寻找文件副本"><a href="#6-1-寻找文件副本" class="headerlink" title="6.1 寻找文件副本"></a>6.1 <a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">寻找文件副本</a></h3><p>设备中存有 n 个文件，文件 id 记于数组 documents。若文件 id 相同，则定义为该文件存在副本。请返回任一存在副本的文件 id。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatDocument</span><span class="hljs-params">(documents []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(documents); &#123;<br>        <span class="hljs-keyword">if</span> documents[i] == i &#123;<br>            i++<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> documents[i] == documents[documents[i]] &#123;<br>            <span class="hljs-keyword">return</span> documents[i]<br>        &#125;<br>        documents[i], documents[documents[i]] = documents[documents[i]], documents[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于此题的特殊限制，可以使用数组下标作为 map。</p>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(04)：框架三件套</title>
    <link href="/ByteDance-4/"/>
    <url>/ByteDance-4/</url>
    
    <content type="html"><![CDATA[<p>本文介绍 Gorm、Kitex、Hertz 三件套。</p><span id="more"></span><h2 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h2><p>Gorm 是面向 Golang 语言的一种 <strong>ORM（Object Relational Mapping，对象关系映射）框架</strong>，支持多种数据库的接入，例如 MySQL，PostgreSQL，SQLite，SQL Server，Clickhouse。此框架弱化了开发者对于 SQL 语言的掌握程度，使用提供的 API 进行底层数据库的访问。</p><p>快速开始：<a href="https://gorm.cn/zh_CN/docs/index.html">https://gorm.cn/zh_CN/docs/index.html</a><br>框架地址：<a href="https://github.com/go-gorm/gorm">https://github.com/go-gorm/gorm</a></p><ul><li><p><strong>基本使用</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br><span class="hljs-string">&quot;gorm.io/driver/sqlite&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Code  <span class="hljs-type">string</span><br>    Price <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 连接数据库</span><br>    db, err := gorm.Open(sqlite.Open(<span class="hljs-string">&quot;test.db&quot;</span>), &amp;gorm.Config&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>    &#125;   <br><br>    <span class="hljs-comment">// 迁移 schema</span><br>    db.AutoMigrate(&amp;Product&#123;&#125;)<br><br>    <span class="hljs-comment">// Create</span><br>    db.Create(&amp;Product&#123;Code: <span class="hljs-string">&quot;D42&quot;</span>, Price: <span class="hljs-number">100</span>&#125;)<br><br>    <span class="hljs-comment">// Read</span><br>    <span class="hljs-keyword">var</span> product Product<br>    db.First(&amp;product, <span class="hljs-number">1</span>) <span class="hljs-comment">// 根据整形主键查找</span><br>    db.First(&amp;product, <span class="hljs-string">&quot;code = ?&quot;</span>, <span class="hljs-string">&quot;D42&quot;</span>) <span class="hljs-comment">// 查找 code 字段值为 D42 的记录</span><br><br>    <span class="hljs-comment">// Update - 将 product 的 price 更新为 200</span><br>    db.Model(&amp;product).Update(<span class="hljs-string">&quot;Price&quot;</span>, <span class="hljs-number">200</span>)<br>    <span class="hljs-comment">// Update - 更新多个字段</span><br>    db.Model(&amp;product).Updates(Product&#123;Price: <span class="hljs-number">200</span>, Code: <span class="hljs-string">&quot;F42&quot;</span>&#125;) <span class="hljs-comment">// 仅更新非零值字段</span><br>    db.Model(&amp;product).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Price&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-string">&quot;F42&quot;</span>&#125;)<br><br>    <span class="hljs-comment">// Delete - 删除 product</span><br>    db.Delete(&amp;product, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>连接数据库</strong></p><p>  GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>    <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span><br>    dsn := <span class="hljs-string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Kitex"><a href="#Kitex" class="headerlink" title="Kitex"></a>Kitex</h2><p>Kitex[kaɪt’eks] 字节跳动内部的 Golang 微服务 <strong>RPC（Remote Procedure Call）框架</strong>，具有高性能、强可扩展的特点，在字节内部已广泛使用。</p><p>快速开始：<a href="https://www.cloudwego.io/zh/docs/kitex/getting-started">https://www.cloudwego.io/zh/docs/kitex/getting-started</a><br>框架地址：<a href="https://github.com/cloudwego/kitex">https://github.com/cloudwego/kitex</a></p><ul><li><p><strong>定义 IDL</strong></p><p>  如果我们要进行 RPC，就需要知道对方的接口是什么，需要传什么参数，同时也需要知道返回值是什么样的，就好比两个人之间交流，需要保证在说的是同一个语言、同一件事。 这时候，就需要通过 IDL（Interface Definition Language）来约定双方的协议，就像在写代码的时候需要调用某个函数，我们需要知道函数签名一样。</p>  <figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-keyword">namespace</span> go api<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Request</span> </span>&#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-type">string</span> message<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Response</span> </span>&#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-type">string</span> message<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    Response echo(<span class="hljs-number">1</span>: Request req)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编写 echo 服务逻辑</strong></p><p>  服务默认监听 8888 端口。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;example/kitex_gen/api&quot;</span><br>)<br><br><span class="hljs-comment">// EchoImpl implements the last service interface defined in the IDL.</span><br><span class="hljs-keyword">type</span> EchoImpl <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Echo implements the EchoImpl interface.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *EchoImpl)</span></span> Echo(ctx context.Context, req *api.Request) (resp *api.Response, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Your code here...</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>创建 client</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;example/kitex_gen/api/echo&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/cloudwego/kitex/client&quot;</span><br>...<br>c, err := echo.NewClient(<span class="hljs-string">&quot;example&quot;</span>, client.WithHostPorts(<span class="hljs-string">&quot;0.0.0.0:8888&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>  上述代码中，echo.NewClient 用于创建 client，其第一个参数为调用的服务名，第二个参数为 options，用于传入参数，此处的 client.WithHostPorts 用于指定服务端的地址。</p></li><li><p><strong>发起调用</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;example/kitex_gen/api&quot;</span><br>...<br>req := &amp;api.Request&#123;Message: <span class="hljs-string">&quot;my request&quot;</span>&#125;<br>resp, err := c.Echo(context.Background(), req, callopt.WithRPCTimeout(<span class="hljs-number">3</span>*time.Second))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br>log.Println(resp)<br></code></pre></td></tr></table></figure><p>  上述代码中，我们首先创建了一个请求 req , 然后通过 c.Echo 发起了调用。</p></li></ul><h2 id="Hertz"><a href="#Hertz" class="headerlink" title="Hertz"></a>Hertz</h2><p>Hertz[həːts] 是一个 Golang 微服务 <strong>HTTP 框架</strong>，在设计之初参考了其他开源框架 fasthttp、gin、echo 的优势，并结合字节跳动内部的需求，使其具有高易用性、高性能、高扩展性等特点。</p><p>快速开始：<a href="https://www.cloudwego.io/zh/docs/hertz/getting-started">https://www.cloudwego.io/zh/docs/hertz/getting-started</a><br>框架地址：<a href="https://github.com/cloudwego/hertz">https://github.com/cloudwego/hertz</a></p><ul><li><p><strong>基本使用</strong></p><p>  实现服务监听 8080 端口并注册一个 GET 方法的路由函数。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/app&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/app/server&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/common/utils&quot;</span><br>    <span class="hljs-string">&quot;github.com/cloudwego/hertz/pkg/protocol/consts&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    h := server.Default(server.WithHostPorts(<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>))<br><br>    h.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c context.Context, ctx *app.RequestContext)</span></span> &#123;<br>        ctx.JSON(consts.StatusOK, utils.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>&#125;)<br>    &#125;)<br><br>    h.Spin()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(03)：内存管理</title>
    <link href="/ByteDance-3/"/>
    <url>/ByteDance-3/</url>
    
    <content type="html"><![CDATA[<p>本文是关于自动内存管理和 Go 内存管理及优化的笔记。</p><span id="more"></span><h2 id="1-Go-垃圾回收"><a href="#1-Go-垃圾回收" class="headerlink" title="1 Go 垃圾回收"></a>1 Go 垃圾回收</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p><strong>垃圾回收</strong>：GC 是一种自动内存管理的机制。避免手动内存管理，专注于实现业务逻辑，并保证内存使用的正确性和安全性：double-free problem，use-after-free problem。</p><p>通常，垃圾回收器的执行过程被划分为两个半独立的组件：</p><ul><li>赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</li><li>回收器（Collector）：负责执行垃圾回收的代码。</li></ul><p><strong>三个任务</strong>：</p><ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul><p><strong>Mutator</strong>: 业务线程，分配新对象，修改对象指向关系<br><strong>Collector</strong>: GC 线程，找到存活对象，回收死亡对象的内存空间<br><strong>Serial GC</strong>: 只有一个 collector<br><strong>Parallel GC</strong>: 并行 GC，支持多个 collectors 同时回收的 GC 算法<br><strong>Concurrent GC</strong>: 并发 GC，支持 mutator(s) 和 collector(s) 同时执行的 GC 算法</p><p><img src="/ByteDance-3/1.png" alt="GC"></p><h3 id="1-2-追踪垃圾回收"><a href="#1-2-追踪垃圾回收" class="headerlink" title="1.2 追踪垃圾回收"></a>1.2 追踪垃圾回收</h3><ol><li><p><strong>标记根对象</strong>（GC roots）：</p><ul><li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li><li>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</li><li>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li></ul></li><li><p><strong>标记</strong>：三色标记法</p><p> <img src="/ByteDance-3/10.png"></p><ol><li>首先把所有的对象都放到白色的集合中</li><li>从根节点（例如程序的全局变量、栈中的变量和寄存器中的指针）开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中</li><li>遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中</li><li>循环步骤 3，直到灰色集合中没有对象</li><li>步骤 4 结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收</li></ol></li><li><p><strong>清理</strong>：回收所有不可达对象占据的内存空间</p><ul><li><strong>Copying GC</strong>: 将存活对象从一块内存空间复制到<strong>另外一块内存空间</strong>，原先的空间可以直接进行对象分配<br> <img src="/ByteDance-3/3.png" alt="Copying GC"></li><li><strong>Mark-sweep GC</strong>: 将死亡对象所在内存块标记为可分配，使用 free list 管理可分配的空间<br> <img src="/ByteDance-3/4.png" alt="Mark-sweep GC"></li><li><strong>Mark-compact GC</strong>: 将存活对象复制到同一块内存区域的开头<br> <img src="/ByteDance-3/5.png" alt="Mark-compact GC"></li></ul></li><li><p><strong>STW</strong></p><p> STW 可以是 Stop the World 的缩写，也可以是 Start the World 的缩写。通常意义上指代从 Stop the World 这一动作发生时到 Start the World 这一动作发生时这一段时间间隔，即万物静止。STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。STW 如今已经优化到了半毫秒级别以下。</p></li></ol><p><strong>并发标记清除法</strong>：难点在于用户态代码在回收过程中会并发地更新对象图，从而造成赋值器和回收器可能对对象图的结构产生不同的认知。</p><p><img src="/ByteDance-3/2.png"></p><p><strong>写屏障</strong>：写屏障是一个在并发垃圾回收器中才会出现的概念，垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象。</p><p>可以证明，当以下两个条件<strong>同时满足</strong>时会破坏垃圾回收器的正确性：</p><ul><li><strong>条件 1</strong>: 赋值器修改对象图，导致某一黑色对象引用白色对象；</li><li><strong>条件 2</strong>: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。</li></ul><p>我们不妨将三色不变性所定义的波面根据这两个条件进行削弱：</p><ul><li>当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为强三色不变性（strong tricolor invariant）</li><li>当赋值器令黑色对象引用白色对象时（满足条件 1 时）的情况称为弱三色不变性（weak tricolor invariant）</li></ul><p>赋值器的写屏障作为一种同步机制，使赋值器在进行指针写操作时，能够“通知”回收器，进而不会破坏弱三色不变性。</p><ul><li><p>灰色赋值器的 Dijkstra 插入屏障的基本思想是避免满足条件 1：为了防止黑色对象指向白色对象，应该假设 <code>*slot</code> 可能会变为黑色，为了确保 <code>ptr</code> 不会在被赋值到 <code>*slot</code> 前变为白色，<code>shade(ptr)</code> 会先将指针 <code>ptr</code> 标记为灰色，进而避免了条件 1。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 灰色赋值器 Dijkstra 插入屏障</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DijkstraWritePointer</span><span class="hljs-params">(slot *unsafe.Pointer, ptr unsafe.Pointer)</span></span> &#123;<br>    shade(ptr)<br>    *slot = ptr<br>&#125;<br></code></pre></td></tr></table></figure><p>  Dijkstra 插入屏障的好处在于可以立刻开始并发标记。但存在两个缺点：</p><ol><li>由于 Dijkstra 插入屏障的“保守”，在一次回收过程中可能会残留一部分对象没有回收成功，只有在下一个回收过程中才会被回收；</li><li>在标记阶段中，每次进行指针赋值操作时，都需要引入写屏障，这无疑会增加大量性能开销；为了避免造成性能问题，Go 团队在最终实现时，没有为所有栈上的指针写操作，启用写屏障，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了灰色赋值器，将会需要标记终止阶段 STW 时对这些栈进行重新扫描。</li></ol></li><li><p>另一种比较经典的写屏障是黑色赋值器的 Yuasa 删除屏障。其基本思想是避免满足条件 2：为了防止丢失从灰色对象到白色对象的路径，应该假设 <code>*slot</code> 可能会变为黑色，为了确保 <code>ptr</code> 不会在被赋值到 <code>*slot</code> 前变为白色，<code>shade(*slot)</code> 会先将 <code>*slot</code> 标记为灰色，进而该写操作总是创造了一条灰色到灰色或者灰色到白色对象的路径，进而避免了条件 2。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 黑色赋值器 Yuasa 屏障</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">YuasaWritePointer</span><span class="hljs-params">(slot *unsafe.Pointer, ptr unsafe.Pointer)</span></span> &#123;<br>    shade(*slot)<br>    *slot = ptr<br>&#125;<br></code></pre></td></tr></table></figure><p>  Yuasa 删除屏障的优势在于不需要标记结束阶段的重新扫描，结束时候能够准确的回收所有需要回收的白色对象。缺陷是 Yuasa 删除屏障会拦截写操作，进而导致波面的退后，产生“冗余”的扫描.</p></li></ul><p>Go 在 1.8 的时候为了简化 GC 的流程，同时减少标记终止阶段的重扫成本，将 Dijkstra 插入屏障和 Yuasa 删除屏障进行混合，形成混合写屏障。该屏障提出时的基本思想是：对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。</p><h3 id="1-3-分代-GC"><a href="#1-3-分代-GC" class="headerlink" title="1.3 分代 GC"></a>1.3 分代 GC</h3><p>分代假说：most objects die young，很多对象在分配出来后很快就不再使用了</p><ul><li><p>年轻代（Young generation）</p><ul><li>常规的对象分配</li><li>由于存活对象少，可以采用 copying collection</li><li>GC 吞吐率很高</li></ul></li><li><p>老年代（Old generation）</p><ul><li>对象趋于一直活着，反复复制开销大</li><li>可以采用 mark-sweep collection</li></ul></li></ul><h3 id="1-4-引用计数"><a href="#1-4-引用计数" class="headerlink" title="1.4 引用计数"></a>1.4 引用计数</h3><p>每个对象都有一个与之关联的引用数目</p><p>对象存活的条件：<strong>当且仅当引用数大于 0</strong></p><ul><li><p>优点：</p><ul><li>内存管理的操作被平摊到程序运行中：指针传递的过程中进行引用计数的增减</li><li>不需要了解 runtime 的细节：因为不需要标记 GC roots，因此不需要知道哪里是全局变量、线程栈等</li></ul></li><li><p>缺点：</p><ul><li>开销大，因为对象可能会被多线程访问，对引用计数的修改需要<strong>原子操作</strong>保证原子性和可见性</li><li>无法回收环形数据结构</li><li>每个对象都引入额外存储空间存储引用计数</li><li>虽然引用计数的操作被平摊到程序运行过程中，但是回收大的数据结构依然可能引发暂停</li></ul></li></ul><h2 id="2-Go-内存管理"><a href="#2-Go-内存管理" class="headerlink" title="2 Go 内存管理"></a>2 Go 内存管理</h2><h3 id="2-1-分块"><a href="#2-1-分块" class="headerlink" title="2.1 分块"></a>2.1 分块</h3><p>为对象在 heap 上分配内存，提前将<strong>内存分块</strong></p><ul><li>调用系统调用 mmap() 向 OS 申请一大块内存，例如 4 MB</li><li>先将内存划分成大块，例如 8 KB，称作 mspan</li><li>再将大块继续划分成<strong>特定大小</strong>的小块，例如 8 B、16 B、24 B，用于对象分配</li><li>noscan mspan: 分配不包含指针的对象 —— GC 不需要扫描</li><li>scan mspan: 分配包含指针的对象 —— GC 需要扫描</li></ul><h3 id="2-2-缓存"><a href="#2-2-缓存" class="headerlink" title="2.2 缓存"></a>2.2 缓存</h3><p>Go 内存管理构成了多级缓存机制，从 OS 分配得的内存被内存管理回收后，也不会立刻归还给 OS，而是在 Go runtime 内部先缓存起来，从而避免频繁向 OS 申请内存。</p><p><img src="/ByteDance-3/6.png" alt="多级缓存"></p><ul><li>每个 p 包含一个 mcache 用于快速分配，用于为绑定于 p 上的 g 分配对象</li><li>mcache 管理一组 mspan</li><li>当 mchache 中的 mspan 分配完毕，向 mcentral 申请带有未分配块的 mspan</li><li>当 mspan 中没有分配的对象，mspan 会缓存在 mcentral 中，而不是立即释放并归还给 OS</li></ul><h3 id="2-3-GMP"><a href="#2-3-GMP" class="headerlink" title="2.3 GMP"></a>2.3 GMP</h3><p><img src="/ByteDance-3/9.png"></p><ul><li>G：goroutine</li><li>M：machine（机器线程）</li><li>P：processor（调度器）</li></ul><p><img src="/ByteDance-3/9.gif"></p><ul><li>每个 P 和一个 M 绑定，M 是真正的执行 P 中 goroutine 的实体</li><li>P 维护了一个 goroutine 的队列，P 的本地队列为空时，就从全局队列里去取</li><li>M 想要运行 G，就得先获取 P，然后从 P 的本地队列获取 G</li></ul><p>工作窃取：当 P 上的一个 G 执行结束后，它会去本地队列获取下一个 G 来执行，如果本地队列空了，此时全局队列也空了，它就会随机选择另一个 P “偷”过来一半的 G。</p><p><strong>模型优点：</strong></p><ul><li>复⽤线程：避免频繁的创建销毁线程</li><li>多核并行</li></ul><h3 id="2-4-优化方案"><a href="#2-4-优化方案" class="headerlink" title="2.4 优化方案"></a>2.4 优化方案</h3><p><strong>Go 内存管理的问题</strong>：对象分配是非常高频的操作，每秒分配 GB 级别的内存；Go 的内存分配流程很长，占用很多 CPU</p><p><strong>字节跳动的优化方案</strong>：Balanced GC</p><p>核心：将 noscan 对象在 per-g allocation buffer (GAB) 上分配，并使用移动对象 GC 管理这部分内存，提高对象分配和回收效率。</p><p><img src="/ByteDance-3/7.png" alt="GAB"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> top + size &lt;= end &#123;<br>    addr := top<br>    top += size<br>    <span class="hljs-keyword">return</span> addr<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 g 会绑定一个较大的 allocation buffer (例如 1 KB) 用来分配小于 128 B 的 noscan 小对象</li><li>分配对象时，根据对象大小移动 top 指针并返回，快速完成一次对象分配</li><li>同原先调用 mallocgc() 进行对象分配的方式相比，balanced GC 缩短了对象分配的路径，减少了对象分配执行的指令数目，降低 CPU 使用</li></ul><p>从 Go runtime 内存管理模块的角度看，一个 allocation buffer 其实是一个大对象。本质上 Balanced GC 是将多次小对象的分配合并成一次大对象的分配。因此，当 GAB 中哪怕只有一个小对象存活时，Go runtime 也会认为整个大对象（即 GAB）存活。为此，balanced GC 会根据 GC 策略，将 GAB 中存活的对象移动到另外的 GAB 中，从而压缩并清理 GAB 的内存空间，原先的 GAB 空间由于不再有存活对象，可以全部释放。</p><p><img src="/ByteDance-3/8.png" alt="用 copying GC 管理小对象"></p><p>Balanced GC 只负责 noscan 对象的分配和移动，对象的标记和回收依然依赖 Go GC 本身，并和 Go GC 保持兼容。</p><h2 id="3-Go-逃逸分析"><a href="#3-Go-逃逸分析" class="headerlink" title="3 Go 逃逸分析"></a>3 Go 逃逸分析</h2><p>在程序中，每个函数块都会有自己的内存区域用来存自己的局部变量、返回地址、返回值之类的数据，这一块内存区域有特定的结构，寻址起来十分迅速，开销很少。这一块内存地址称为栈。栈是线程级别的，大小在创建的时候已经确定。但有时候变量会逃逸到堆上，当局部变量通过堆分配和回收时，就叫内存逃逸。</p><ul><li>堆是一块没有特定结构，也没有固定大小的内存区域，可以根据需要进行调整</li><li>全局变量，内存占用较大的局部变量，函数调用结束后不能立刻回收的局部变量都会存在堆里面</li><li>变量在堆上的分配和回收都比在栈上开销大的多</li><li>对于 Go 这种带 GC 的语言来说，会增加 GC 压力，同时也容易造成内存碎片</li></ul><p>Go 语言逃逸分析最基本的原则是：<strong>如果一个函数返回对一个变量的引用，那么它就会发生逃逸</strong>。</p><p>简单来说，编译器会分析代码的特征和代码生命周期，Go 中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少 gc 的压力，提高程序的运行速度。</p><ul><li>如果函数外部对指针没有引用，则优先放到栈中</li><li>如果函数外部对指针存在引用，则必定放到堆中</li><li>当函数内分配一个较大对象时，则优先放到堆中</li><li>编译阶段无法确定的参数，会逃逸到堆上</li></ul><p>查看逃逸分析的结果：<code>go build -gcflags &#39;-m -l&#39; main.go</code>。</p><h3 id="3-1-什么情况会发生内存逃逸"><a href="#3-1-什么情况会发生内存逃逸" class="headerlink" title="3.1 什么情况会发生内存逃逸"></a>3.1 什么情况会发生内存逃逸</h3><ul><li>向 channel 发送指针数据。因为在编译时，不知道 channel 中的数据会被哪个 goroutine 接收，因此编译器没法知道变量什么时候才会被释放，因此只能放入堆中</li><li>方法内把局部变量指针返回。局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出</li><li>在 slice 或 map 中存储指针。比如 []*string，其后面的数组可能是在栈上分配的，但其引用的值还是在堆上</li><li>切片扩容后长度太大，导致栈空间不足，逃逸到堆上</li><li>在 interface 类型上调用方法时会把 interface 变量使用堆分配，因为方法的真正实现只能在运行时知道</li></ul><h3 id="3-2-如何解决内存逃逸"><a href="#3-2-如何解决内存逃逸" class="headerlink" title="3.2 如何解决内存逃逸"></a>3.2 如何解决内存逃逸</h3><ul><li>对于小型的数据，使用传值而不是传指针，避免内存逃逸</li><li>避免使用长度不固定的 slice 切片，在编译期无法确定切片长度，只能将切片使用堆分配</li><li>interface 调用方法会发生内存逃逸，谨慎使用</li><li>指向栈对象上的指针不能被存储到堆中</li><li>指向栈对象上的指针不能超过该栈对象的声明周期</li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(02)：性能调优</title>
    <link href="/ByteDance-2/"/>
    <url>/ByteDance-2/</url>
    
    <content type="html"><![CDATA[<p>请参考：<a href="https://github.com/RaymondCode/go-practice">性能优化建议代码</a>，<a href="https://github.com/wolfogre/go-pprof-practice">pprof 示例代码</a></p><span id="more"></span><h2 id="1-性能优化建议"><a href="#1-性能优化建议" class="headerlink" title="1 性能优化建议"></a>1 性能优化建议</h2><h3 id="1-1-Slice"><a href="#1-1-Slice" class="headerlink" title="1.1 Slice"></a>1.1 Slice</h3><p><strong>预分配内存</strong>：使用 <code>make()</code> 初始化切片时提供容量信息。</p><ul><li><p>切片本质是一个数组片段的描述，包括：</p><ul><li>数组指针</li><li>片段的长度</li><li>片段的容量</li></ul></li><li><p>切片操作并不复制切片指向的元素</p></li><li><p>创建一个新的切片会复用原来切片的底层数组</p></li><li><p>切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景：</p><ul><li>当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间</li><li>当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组（此时切片地址发生改变）</li></ul></li></ul><p><img src="/ByteDance-2/2.png" alt="append"></p><p>因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NoPreAlloc</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> &#123;<br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++ &#123;<br>data = <span class="hljs-built_in">append</span>(data, k)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PreAlloc</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> &#123;<br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, size)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; size; k++ &#123;<br>data = <span class="hljs-built_in">append</span>(data, k)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-2/1.png" alt="result"></p><p>此外，在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。</p><p><strong>另一个陷阱</strong>：大内存得不到释放。</p><p>在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。</p><p>推荐的做法：<strong>使用 copy 替代 re-slice</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// slice.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLastBySlice</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLastByCopy</span><span class="hljs-params">(origin []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">copy</span>(result, origin[<span class="hljs-built_in">len</span>(origin)<span class="hljs-number">-2</span>:])<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">// slice_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testGetLast</span><span class="hljs-params">(t *testing.T, f <span class="hljs-keyword">func</span>([]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span>) &#123;<br>result := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++ &#123;<br>origin := generateWithCap(<span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-comment">// 1M</span><br>result = <span class="hljs-built_in">append</span>(result, f(origin))<br>&#125;<br>printMem(t)<br>_ = result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLastBySlice</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>testGetLast(t, GetLastBySlice)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLastByCopy</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>testGetLast(t, GetLastByCopy)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-2/3.png" alt="result"></p><h3 id="1-2-Map"><a href="#1-2-Map" class="headerlink" title="1.2 Map"></a>1.2 Map</h3><p><strong>预分配内存</strong></p><ul><li>不断向 map 中添加元素的操作会触发 map 的扩容</li><li>根据实际需求提前预估好需要的空间</li><li>提前分配好空间可以减少内存拷贝和 Rehash 的消耗</li></ul><h3 id="1-3-字符串处理"><a href="#1-3-字符串处理" class="headerlink" title="1.3 字符串处理"></a>1.3 字符串处理</h3><p>使用 strings.Builder 代替 “+”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Plus</span><span class="hljs-params">(n <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>s := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>s += str<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StrBuilder</span><span class="hljs-params">(n <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> builder strings.Builder<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>builder.WriteString(str)<br>&#125;<br><span class="hljs-keyword">return</span> builder.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ByteBuffer</span><span class="hljs-params">(n <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>buf := <span class="hljs-built_in">new</span>(bytes.Buffer)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>buf.WriteString(str)<br>&#125;<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-2/4.png" alt="分别传入(1000, &quot;string&quot;)"></p><ul><li>字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 “+” 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和</li><li>strings.Builder，bytes.Buffer 的内存是以倍数申请的</li><li>strings.Builder 和 bytes.Buffer 底层都是 []byte 数组，bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回</li></ul><h3 id="1-4-空结构体"><a href="#1-4-空结构体" class="headerlink" title="1.4 空结构体"></a>1.4 空结构体</h3><p><strong>使用空结构体节省内存</strong></p><ul><li>空结构体不占据内存空间，可作为占位符使用。比如实现简单的 Set：Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。对于集合场景，只需要用到 map 的键而不需要值。</li></ul><h2 id="2-性能调优实战"><a href="#2-性能调优实战" class="headerlink" title="2 性能调优实战"></a>2 性能调优实战</h2><h3 id="2-1-分析工具"><a href="#2-1-分析工具" class="headerlink" title="2.1 分析工具"></a>2.1 分析工具</h3><p><img src="/ByteDance-2/5.png" alt="pprof"></p><h3 id="2-2-搭建项目"><a href="#2-2-搭建项目" class="headerlink" title="2.2 搭建项目"></a>2.2 搭建项目</h3><p><a href="https://blog.wolfogre.com/posts/go-ppof-practice/">参考教程</a><br>项目提前埋入了一些炸弹代码，产生可观测的性能问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span>  <span class="hljs-comment">// 自动注册 pprof 的 handler 到 http server</span><br>    <span class="hljs-comment">// ...</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.LstdFlags)<br>log.SetOutput(os.Stdout)<br><br>runtime.GOMAXPROCS(<span class="hljs-number">1</span>)                   <span class="hljs-comment">// 限制 CPU 使用数</span><br>runtime.SetMutexProfileFraction(<span class="hljs-number">1</span>)      <span class="hljs-comment">// 开启锁调用跟踪</span><br>runtime.SetBlockProfileRate(<span class="hljs-number">1</span>)          <span class="hljs-comment">// 开启阻塞调用跟踪</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 启动 http server</span><br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:6060&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> animal.AllAnimals &#123;<br>v.Live()<br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-浏览器查看指标"><a href="#2-3-浏览器查看指标" class="headerlink" title="2.3 浏览器查看指标"></a>2.3 浏览器查看指标</h3><p><img src="/ByteDance-2/6.png" alt="debug"></p><ul><li>CPU</li></ul><p><img src="/ByteDance-2/7.png" alt="CPU"></p><ul><li><code>go tool pprof &quot;http://127.0.0.1:6060/debug/pprof/profile?seconds=10&quot;</code></li><li><code>topN</code> 查看占用资源最多的函数</li><li><code>list</code> 根据指定的正则表达式查找代码行</li><li><code>web</code> 调用关系可视化</li></ul><p><img src="/ByteDance-2/8.png" alt="排查过程"></p><ul><li>heap-堆内存</li><li>goroutine-协程</li><li>mutex-锁</li><li>block-阻塞</li></ul>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 以太坊区块结构</title>
    <link href="/Research-Block/"/>
    <url>/Research-Block/</url>
    
    <content type="html"><![CDATA[<p>此篇文章用以太坊为例，研究一下一个区块里面到底有什么，以及以太坊中的数据是怎么存储的。</p><span id="more"></span><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><p>一个区块由两部分组成：</p><ul><li>区块头（Header）</li><li>区块体（Body）</li></ul><p><img src="/Research-Block/1.png" alt="Block"></p><p>轻节点只会存储 Header。</p><p>区块中的三棵树：</p><ul><li><p><strong>状态树</strong>：状态树是全局的、不断更新的，它的 key 为 keccak256(ethereumAddress)，value 为 rlp(ethereumAccount)。其中 ethereumAddress 表示以太坊账户地址；ethereumAccount 表示以太坊账户，包含四个字段：nonce，balance，storageRoot，codeHash。如果 storageRoot 和 codeHash 不为空，则为合约账户，其中 codeHash 对应合约代码的哈希，storageRoot 对应另一棵树的树根，这棵树我们称为<strong>存储树</strong>。存储树存储了合约的所有状态数据，每个合约有单独的存储树。</p></li><li><p><strong>交易树</strong>：每个区块都有一棵独立的交易树，对应区块头里的交易根。交易树的 key（路径）为 rlp(transactionIndex)，value 为交易序列化后的值。其中 transactionIndex 表示交易在该区块中的下标。</p></li><li><p><strong>回执树</strong>：每个交易对应一个交易回执，交易回执记录了交易执行结果，包括执行状态、Gas 消耗、事件日志等。每个区块有自己的回执树，对应了区块头里的回执根。与交易树类似，key 为 rlp(transactionIndex)，value 为交易回执序列化后的值。</p></li></ul><p><img src="/Research-Block/2.png" alt="Trie"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>以太坊中的账户状态是用什么数据结构存储的呢？</p><p>有关这个问题<a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=16">肖臻老师的公开课</a>有非常详细的解释。这里直接说结论：<strong>Merkle Patricia Trie（MPT）</strong></p><p><img src="/Research-Block/3.png" alt="World State Trie"></p><p>右上角为简化的 key-value 定义。我们可以看到图中有 2 个拓展节点，2 个分支节点，4 个叶子节点。在最下面的两个叶子节点中，prefix 3 的右边有个格子，有个箭头从 7 指向这个格子，表示 3 和 7 两个 nibble 组成一个字节存储。当一个节点被另一个节点在内部指向时（比如上图中的分支节点内部指向了叶子节点），父节点会存储 H(rlp.encode(x))。</p><p>其中 H(y) &#x3D; keccak256(y) if len(y) &gt;&#x3D; 32 else y，rlp.encode 为 RLP 编码函数。</p><p>由于 MPT 树是确定性的，所以如果两棵树存储了完全相同的数据，那么这两棵树的节点将完全相同，包括根节点。假设在某一时刻，当其中一个合约修改了某个变量的数据，使得它与另一个合约的数据不同时，会生成一个新的节点，并从新节点开始由下往上直到根节点，整个路径的节点值都会更新，新生成的节点会存储到硬盘，但旧的节点不会从硬盘删除。</p><p><img src="/Research-Block/4.png" alt="update data"></p><h2 id="StateDB"><a href="#StateDB" class="headerlink" title="StateDB"></a>StateDB</h2><p>在以太坊中，StateDB 是一个用于管理账户状态数据的内存数据库，它的数据存储在节点的内存中，并且随着区块链的不断增长而不断变化。但是，为了确保数据的可靠性和持久性，StateDB 数据需要被定期持久化到磁盘中。</p><p>为了实现数据的持久化，以太坊节点使用了 LevelDB 这样的键值对存储引擎。当 StateDB 中的数据发生变化时，节点会将这些变化记录在 LevelDB 中，以便在下次启动时从磁盘中重新加载数据。</p><p>需要注意的是，由于 LevelDB 是一种磁盘存储引擎，相比于内存数据库，它的读写速度要慢很多。因此，在以太坊节点中，StateDB 通常被用作内存数据库，而 LevelDB 则用于实现数据的持久化。这种方式可以同时满足节点的高性能和数据的可靠性要求。</p><h2 id="block-go-源码"><a href="#block-go-源码" class="headerlink" title="block.go 源码"></a>block.go 源码</h2><p>研究那么多不如来看一看区块结构的源码：go-ethereum&#x2F;core&#x2F;types&#x2F;block.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Header represents a block header in the Ethereum blockchain.</span><br><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>ParentHash  common.Hash    <span class="hljs-comment">// 父区块的哈希</span><br>    UncleHash   common.Hash    <span class="hljs-comment">// 所有叔块的哈希（Block.uncles）</span><br>    Coinbase    common.Address <span class="hljs-comment">// 接受出块奖励的地址，矿工出块时在这个字段填入自己的地址</span><br>    Root        common.Hash    <span class="hljs-comment">// 此区块包含的所有交易完成后，state 对象的哈希值</span><br>    TxHash      common.Hash    <span class="hljs-comment">// 此区块包含的所有交易的哈希（Block.transactions）</span><br>    ReceiptHash common.Hash    <span class="hljs-comment">// 此区块所有交易完成后所产生的所有收据的哈希</span><br>    Bloom       Bloom          <span class="hljs-comment">// 用来快速判断一个参数 Log 对象是否存在于一组已知的 Log 集合中</span><br>    Difficulty  *big.Int       <span class="hljs-comment">// 此区块的难度值</span><br>    Number      *big.Int       <span class="hljs-comment">// 此区块的高度</span><br>    GasLimit    <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 此区块所有交易消耗的 gas 值的上限</span><br>    GasUsed     <span class="hljs-type">uint64</span>         <span class="hljs-comment">// 此区块所有交易消耗的 gas 的实际值</span><br>    Time        *big.Int       <span class="hljs-comment">// 区块时间戳</span><br>    Extra       []<span class="hljs-type">byte</span>         <span class="hljs-comment">// 区块的额外数据</span><br>    MixDigest   common.Hash    <span class="hljs-comment">// 以太坊 hashimoto 算法产生的哈希</span><br>    Nonce       BlockNonce     <span class="hljs-comment">// 通过此字段产生符合 Difficulty 值要求的区块哈希</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Body <span class="hljs-keyword">struct</span> &#123;<br>Transactions []*Transaction<br>Uncles       []*Header<br>&#125;<br><br><span class="hljs-comment">// Block represents an entire block in the Ethereum blockchain.</span><br><span class="hljs-keyword">type</span> Block <span class="hljs-keyword">struct</span> &#123;<br>header       *Header<br>uncles       []*Header<br>transactions Transactions<br><br><span class="hljs-comment">// caches</span><br>hash atomic.Value<br>size atomic.Value<br><br><span class="hljs-comment">// 从创世块开始，到当前区块截止，累积的所有区块 Difficulty 之和</span><br>td *big.Int<br><br><span class="hljs-comment">// These fields are used by package eth to track</span><br><span class="hljs-comment">// inter-peer block relay.</span><br>ReceivedAt   time.Time<br>ReceivedFrom <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见一个区块携带的数据主要是：<strong>Header 中的信息 + 叔块们的头部信息 + 块中包含的所有交易信息</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Git</title>
    <link href="/Note-Git/"/>
    <url>/Note-Git/</url>
    
    <content type="html"><![CDATA[<p>Git is very good!</p><span id="more"></span><h2 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1 工作流程"></a>1 工作流程</h2><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><p><img src="/Note-Git/1.png" alt="工作流程"></p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2 基本概念"></a>2 基本概念</h2><ul><li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li><li><strong>暂存区</strong>：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库</strong>：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</li><li><strong>远程版本库</strong>：一般指的是 Git 服务器上所对应的仓库，如 github 仓库。</li></ul><p><img src="/Note-Git/2.jpg" alt="关系"></p><h2 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3 基本操作"></a>3 基本操作</h2><ul><li><code>git init</code>：初始化仓库</li><li><code>git config</code>：配置开发者用户名和邮箱</li><li><code>git clone</code>：从 git 服务器拉取代码</li><li><code>git status</code>：查看文件变动状态</li><li><code>git add .</code>：添加文件到暂存区</li><li><code>git commit</code>：提交文件变动到版本库</li><li><code>git push</code>：将本地的代码改动推送到服务器</li><li><code>git pull</code>：将服务器上的最新代码拉取到本地</li><li><code>git log</code>：查看版本提交记录</li><li><code>git tag</code>：为项目标记里程碑</li><li><code>git reset</code>：回退版本</li><li><code>.gitignore</code>：设置哪些内容不需要推送到服务器，这是一个配置文件</li></ul><p>具体参数可参考<a href="https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA">这篇文章</a></p><h2 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4 分支管理"></a>4 分支管理</h2><ul><li>分支（Branch）：分支是为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改。</li><li>主分支（Master&#x2F;Main）：前面提到过 master 是 Git 为我们自动创建的第一个分支，也叫主分支，其它分支开发完成后都要合并到 master。</li><li>HEAD：指向的就是当前分支的最新提交。</li></ul><p><img src="/Note-Git/3.png" alt="Branch"></p><ul><li><code>git branch</code>：创建、重命名、查看、删除项目分支</li><li><code>git checkout</code>：切换分支</li><li><code>git merge</code>：合并分支</li></ul><h2 id="5-Github"><a href="#5-Github" class="headerlink" title="5 Github"></a>5 Github</h2><p>如果你想通过 Git 分享你的代码或者与其他开发人员合作。你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p>本例使用了 Github 作为远程仓库，可以阅读 <a href="https://www.runoob.com/w3cnote/git-guide.html">Github 简明教程</a>。</p><p><img src="/Note-Git/4.png" alt="Github"></p><ul><li><code>git fetch</code>：从远程仓库下载新分支与数据</li><li><code>git merge</code>：从远端仓库提取数据并尝试合并到当前分支</li></ul><p><img src="/Note-Git/5.png" alt="提取"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Docker</title>
    <link href="/Note-Docker/"/>
    <url>/Note-Docker/</url>
    
    <content type="html"><![CDATA[<p>Docker 容器将软件以及它运行安装所需的一切文件（代码、运行时库、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，Write once, run anywhere，而 Docker 是 Build once，run anywhere。</p><span id="more"></span><h2 id="1-Docker-基本概念"><a href="#1-Docker-基本概念" class="headerlink" title="1 Docker 基本概念"></a>1 Docker 基本概念</h2><p>在没有使用 Docker 时，我们开发完毕一个项目，需要打成 war 包或 jar 包。然后，在服务器上进行各种环境的安装、配置以及应用程序维护，比如：JDK、Tomcat、数据库等。而且，上述的配置在开发环境、测试服务器、生产服务器（通常会有很多个），都需要进行一遍同样的操作，工作量相当繁重。</p><p>在使用了 Docker 之后，我们可以自己创建一个空的镜像从头构建，也可以使用公共仓库中已经构建好的镜像，直接使用。当需要在不同环境中进行部署时，直接使用构建好的镜像即可。</p><p><img src="/Note-Docker/3.png" alt="Docker 优势"></p><h3 id="1-1-基本组成"><a href="#1-1-基本组成" class="headerlink" title="1.1 基本组成"></a>1.1 基本组成</h3><p><img src="/Note-Docker/1.png" alt="Docker 架构"></p><ul><li><p><strong>镜像（Image）</strong>：相当于是一个 root 文件系统。Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</p></li><li><p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></li><li><p><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</p></li><li><p><strong>客户端（Client）</strong>：Docker 客户端通过命令行或者其他工具使用 <a href="https://docs.docker.com/develop/sdk/">Docker SDK</a> 与 Docker 的守护进程通信。</p></li><li><p><strong>主机（Host）</strong>：一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</p></li></ul><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><h3 id="1-2-Docker-Compose"><a href="#1-2-Docker-Compose" class="headerlink" title="1.2 Docker-Compose"></a>1.2 Docker-Compose</h3><p>通过 Docker-Compose ，不需要使用 shell 脚本来启动容器，而使用 YAML 文件来配置应用程序需要的所有服务，然后使用一个命令根据 YAML 的文件配置创建并启动所有服务。</p><h3 id="1-3-网络"><a href="#1-3-网络" class="headerlink" title="1.3 网络"></a>1.3 网络</h3><p>当你安装 Docker 时，它会自动创建三个网络：</p><ul><li>bridge：创建容器默认连接到此网络，此模式会为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0 虚拟网桥，通过 docker0 网桥以及 Iptables nat 表配置与宿主机通信。</li><li>none：该模式关闭了容器的网络功能。</li><li>host：容器和宿主机共享 Network namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</li></ul><p>建议使用自定义的网桥来控制哪些容器可以相互通信，还可以自动 DNS 解析容器名称到 IP 地址。</p><h2 id="2-Docker-容器与虚拟机"><a href="#2-Docker-容器与虚拟机" class="headerlink" title="2 Docker 容器与虚拟机"></a>2 Docker 容器与虚拟机</h2><p>创建虚拟机时，会将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存。而 Docker 有着比虚拟机更少的抽象层，不需要实现硬件资源虚拟化，运行在 Docker 容器上的程序直接使用实际物理机的硬件资源。Docker 利用的是宿主机的内核，而不需要 Guest OS。</p><p><img src="/Note-Docker/2.png" alt="容器与虚拟机"></p><p>传统的虚拟机是在宿主机之上，又添加了一个新的操作系统，这就导致了虚拟机的臃肿，不适合迁移。而 Docker 是直接寄存在宿主机上，完全就会避免大部分虚拟机带来的困扰。</p><p>Docker 是一个黑盒的进程，区别于传统的进程，Docker 可以独立出一个自己的空间，不会使得在 Docker 中的行为以及变量溢出到宿主机上。</p><h2 id="3-Docker-镜像"><a href="#3-Docker-镜像" class="headerlink" title="3 Docker 镜像"></a>3 Docker 镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行某个软件所需的所有内容，包括<strong>代码、运行时库、环境变量和配置文件</strong>。</p><h3 id="3-1-构建镜像"><a href="#3-1-构建镜像" class="headerlink" title="3.1 构建镜像"></a>3.1 构建镜像</h3><p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或添加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层：</p><p><img src="/Note-Docker/5.png"></p><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部。这一层就是我们通常说的容器层，容器之下的都叫镜像层。</p><p>自己构建镜像时首先需要写一个 dockerfile 文件：</p><ol><li>编写一个 dockerfile 文件</li><li>docker build 构建称为一个镜像</li><li>docker run 运行镜像</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span>                <span class="hljs-comment"># 基础镜像，一切从这里开始构建</span><br><span class="hljs-keyword">MAINTAINER</span>          <span class="hljs-comment"># 镜像是谁写的，姓名+邮箱</span><br><span class="hljs-keyword">RUN</span><span class="language-bash">                 <span class="hljs-comment"># 镜像构建的时候需要运行的命令</span></span><br><span class="hljs-keyword">ADD</span><span class="language-bash">                 <span class="hljs-comment"># 添加内容</span></span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash">             <span class="hljs-comment"># 镜像的工作目录</span></span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash">              <span class="hljs-comment"># 挂载的目录</span></span><br><span class="hljs-keyword">EXPOSE</span>              <span class="hljs-comment"># 保留端口配置</span><br><span class="hljs-keyword">CMD</span><span class="language-bash">                 <span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span></span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash">          <span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span><br><span class="hljs-keyword">ONBUILD</span>             <span class="hljs-comment"># 当构建一个被继承 dockerfile 这个时候就会运行 ONBUILD 的指令，触发指令</span><br><span class="hljs-keyword">COPY</span><span class="language-bash">                <span class="hljs-comment"># 类似 ADD，将我们文件拷贝到镜像中</span></span><br><span class="hljs-keyword">ENV</span>                 <span class="hljs-comment"># 构建的时候设置环境变量</span><br></code></pre></td></tr></table></figure><h3 id="3-2-镜像加速"><a href="#3-2-镜像加速" class="headerlink" title="3.2 镜像加速"></a>3.2 镜像加速</h3><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务：</p><ul><li>科大镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></li><li>网易：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></li><li>阿里云：https:&#x2F;&#x2F;&lt;你的ID&gt;.mirror.aliyuncs.com（<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像获取地址</a>）</li><li>七牛云加速器：<a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></li></ul><p>对于使用 systemd 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;<br></code></pre></td></tr></table></figure><p>之后重新启动服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ sudo systemctl daemon-reload<br>$ sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>检查是否生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker info<br>Registry Mirrors:<br>    https://reg-mirror.qiniu.com<br></code></pre></td></tr></table></figure><h2 id="4-Docker-常用命令"><a href="#4-Docker-常用命令" class="headerlink" title="4 Docker 常用命令"></a>4 Docker 常用命令</h2><p><img src="/Note-Docker/4.png"></p><ol><li><p>当前系统 Docker 信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker<br>$ docker info<br>$ docker version<br></code></pre></td></tr></table></figure></li><li><p>容器使用</p><ul><li><p><strong>获取镜像</strong><br>  如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker pull ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>启动容器</strong><br>  以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker run -it ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>  参数说明：<br>  <code>-i</code>：交互式操作。<br>  <code>-t</code>：终端。<br>  <code>ubuntu</code>：ubuntu 镜像。<br>  <code>/bin/bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</p><p>  退出终端：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Linux"># exit<br></code></pre></td></tr></table></figure></li><li><p><strong>查看所有容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker ps -a<br></code></pre></td></tr></table></figure><p>  查看当前有哪些容器正在运行</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker ps<br></code></pre></td></tr></table></figure></li><li><p><strong>启动、停止、重启容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker start container_id<br>$ docker stop container_id<br>$ docker restart container_id<br>$ docker kill container_id<br></code></pre></td></tr></table></figure></li><li><p><strong>后台运行</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker run -itd --name ubuntu-test ubuntu /bin/bash<br></code></pre></td></tr></table></figure></li><li><p><strong>进入容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker attach container_id<br># 进入容器正在执行的终端，如果从这个终端退出，会导致容器的停止<br><br>$ docker exec -it container_id /bin/bash<br># 进入当前容器后开启一个新的终端，如果从这个终端退出，容器不会停止<br></code></pre></td></tr></table></figure></li><li><p><strong>删除容器</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker rm -f container_id<br></code></pre></td></tr></table></figure></li></ul></li><li><p>镜像使用</p><ul><li><p><strong>查看宿主机上的镜像</strong><br>   Docker 镜像保存在 &#x2F; var&#x2F;lib&#x2F;docker 目录下</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker images<br></code></pre></td></tr></table></figure></li><li><p><strong>拉取新的镜像</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker pull image_name:tag<br></code></pre></td></tr></table></figure></li><li><p><strong>删除镜像</strong></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">$ docker rmi hello-world<br></code></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://www.runoob.com/docker/docker-hello-world.html">更多命令</a></p></li></ol><h2 id="5-个人疑问"><a href="#5-个人疑问" class="headerlink" title="5 个人疑问"></a>5 个人疑问</h2><p><strong>Linux docker 宿主机是否可以运行 Windows 容器？</strong></p><ul><li>Windows docker 宿主机可以运行 Windows 和 Linux 容器。</li><li>Linux docker 宿主机只能运行 Linux 容器。</li><li>Windows 宿主机可以运行 Linux 容器的原因是： Windows 在后台创建了一个 Linux 子系统，因此 Linux 容器仍在 Linux 上运行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Hyperledger Fabric: A Distributed Operating System for Permissioned Blockchains</title>
    <link href="/Paper-Fabric/"/>
    <url>/Paper-Fabric/</url>
    
    <content type="html"><![CDATA[<p>Fabric 是一个模块化、可扩展的开源系统，用于部署和操作<strong>许可区块链</strong>，也是 Linux 基金会托管的超级账本项目之一。它支持<strong>模块化共识协议</strong>，允许系统根据特定用例和信任模型进行定制。在某些流行的部署配置中， Fabric 实现了每秒 3500 TPS，具有 sub-second 的延迟，可扩展到 100 多个对等节点。</p><span id="more"></span><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>区块链相较于传统的 SMR（state-machine replication，状态机复制）存在拜占庭式缺陷：</p><ol><li>不只一个，而是许多分布式应用程序同时运行</li><li>应用程序可以由任何人动态部署</li><li>应用程序代码是不可信的，甚至可能是恶意的</li></ol><p>许多现有区块链实施的是 <strong>order-execute</strong> 结构，它的局限性在于要求所有对等方执行每个交易，并且所有交易都是确定的。</p><ul><li>共识在平台内是硬编码的，这与没有一刀切的（BFT）共识协议的公认理解相矛盾</li><li>交易验证的信任模型由共识协议决定，不能适应智能合约的要求</li><li>智能合约必须以固定的、非标准的或特定领域的语言编写，这会阻碍广泛的应用，并可能导致编程错误</li><li>所有对等方对所有交易的顺序执行限制了性能，需要采取复杂的措施防止来自不可信合约的拒绝服务攻击</li><li>交易必须是确定性的，这在编程上很难保证</li><li>每个智能合约都在所有对等方上运行，这与保密性不符，并禁止向一部分对等方传播合约代码和状态</li></ul><p>Fabric 可以克服这些局限性。</p><p>Fabric 使用 <strong>execute-order-validate</strong> 结构，将交易分为三个步骤，可以在系统中不同的实体中运行：</p><ol><li><strong>executing</strong> 交易并检查其正确性，从而 <strong>endorsing</strong> 交易（对应于其他区块链中的“交易验证”）</li><li>通过共识协议进行 <strong>ordering</strong>，而不考虑交易语义</li><li>根据特定于应用程序的信任假设进行 <strong>validation</strong>，这防止了并发导致的竞争</li></ol><p>该设计结合了两种复制方案：<strong>passive</strong>（当一个事务提交时，领导者副本将该事务的数据变更广播给所有跟随者副本，跟随者按照顺序应用这些变更）和 <strong>active</strong>（每个副本独立执行相同的确定性交易代码）</p><ul><li>首先 Fabric 使用 passive replication，每个事务仅由一个对等方的子集执行和背书，这允许<strong>并行执行</strong>。背书政策规定了哪些对等方或其中多少对等方需要为智能合约提供担保。</li><li>其次 Fabric 结合 active replication，每个对等方单独执行的确定性验证步骤中，交易对账本状态的影响只有在总顺序达成共识后才能写入。状态更新的排序被委托给一个模块化组件以实现共识，该组件是无状态的，并且在逻辑上与执行交易和维护账本的对等方分离。由于共识是模块化的，因此它的实现可以根据特定部署的信任假设进行调整。</li></ul><p>Fabric 中包含了以下组件：</p><ul><li><strong>ordering service</strong> 以原子方式向对等方广播状态更新，并就事务顺序建立共识。</li><li><strong>membership service provider</strong> 负责将对等方与加密身份相关联。它保持了 Fabric 的许可性。</li><li>可选的 <strong>peer-to-peer gossip service</strong> 通过 ordering service 向所有对等节点传播块的输出。</li><li>Fabric 中的 <strong>smart contracts</strong> 在容器环境中运行以隔离。它们可以用标准编程语言编写，但不能直接访问帐本状态。</li><li>每个对等方在本地维护 <strong>ledger</strong>，并将其作为键值存储中最新状态的快照。</li></ul><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2 BACKGROUND"></a>2 BACKGROUND</h2><h3 id="2-1-Order-Execute-Architecture-for-Blockchains"><a href="#2-1-Order-Execute-Architecture-for-Blockchains" class="headerlink" title="2.1 Order-Execute Architecture for Blockchains"></a>2.1 Order-Execute Architecture for Blockchains</h3><p><img src="/Paper-Fabric/1.png" alt="Order-execute architecture in replicated services."></p><h3 id="2-2-Limitations-of-Order-Execute"><a href="#2-2-Limitations-of-Order-Execute" class="headerlink" title="2.2 Limitations of Order-Execute"></a>2.2 Limitations of Order-Execute</h3><ul><li>Sequential execution：成为性能瓶颈</li><li>Non-deterministic code：导致分叉</li><li>Confidentiality of execution：保密开销巨大</li></ul><h3 id="2-3-Further-Limitations-of-Existing-Architectures"><a href="#2-3-Further-Limitations-of-Existing-Architectures" class="headerlink" title="2.3 Further Limitations of Existing Architectures"></a>2.3 Further Limitations of Existing Architectures</h3><ul><li>Fixed trust model：应用程序级别的信任不应固定为协议级别的信任</li><li>Hard-coded consensus：应使用不同共识协议适应不同的环境</li></ul><h3 id="2-4-Experience-with-Order-Execute-Blockchain"><a href="#2-4-Experience-with-Order-Execute-Blockchain" class="headerlink" title="2.4 Experience with Order-Execute Blockchain"></a>2.4 Experience with Order-Execute Blockchain</h3><p>区块链系统的关键属性，即一致性、安全性和性能，不得依赖于其用户的知识和善意，因为区块链在不受信任的环境中运行。</p><h2 id="3-ARCHITECTURE"><a href="#3-ARCHITECTURE" class="headerlink" title="3 ARCHITECTURE"></a>3 ARCHITECTURE</h2><h3 id="3-1-Fabric-Overview"><a href="#3-1-Fabric-Overview" class="headerlink" title="3.1 Fabric Overview"></a>3.1 Fabric Overview</h3><p><img src="/Paper-Fabric/2.png" alt="Execute-order-validate architecture of Fabric"></p><p>Fabric 的分布式应用程序由两部分组成：</p><ul><li><strong>chaincode</strong>：一个智能合约，在执行阶段运行，可以使用通用编程语言（Golang、Java 等）</li><li><strong>endorsement policy</strong>：一个背书策略，在验证阶段被评估，只有特定的管理员可以修改</li></ul><p>客户端向背书策略指定的节点发送交易，然后由节点执行每个交易，并记录其输出，这一步骤也称为 endorsement。执行完成后，交易进入排序阶段，通过可插拔的共识协议对这些交易排序（并非交易输入，而是对交易输出排序，并结合状态依赖），然后向所有节点广播。然后，每个节点根据背书策略验证背书交易的状态变化，并验证交易的一致性。在此期间 Fabric 使用了主动和被动复制的混合策略。</p><p>三个角色：</p><p><img src="/Paper-Fabric/3.png" alt="MSP: membership service provider"></p><ul><li><strong>Clients</strong>：提交、广播交易</li><li><strong>Peers</strong>：执行（并不执行所有交易，只有被指定为 endorsers 时执行）、验证交易，维护区块链</li><li><strong>Orderers</strong> (OSN，Ordering Service Nodes)：给所有交易排序</li></ul><p>交易流：</p><p><img src="/Paper-Fabric/4.png" alt="Fabric high level transaction flow"></p><h3 id="3-2-Execution-Phase"><a href="#3-2-Execution-Phase" class="headerlink" title="3.2 Execution Phase"></a>3.2 Execution Phase</h3><p>在执行阶段，客户端签署交易提案（proposal）并发送给背书策略中指定的背书人。背书人根据本地区块链状态模拟执行提案，此时的执行结果并不会与其他节点同步，也不会写入账本中。链码创建的状态仅限于该链码，不能由其他链码直接访问。给定适当的许可，链码可以调用另一个链码来访问同一通道内的状态。</p><p>每一个背书人在模拟执行的时候会生成一个 writeset（模拟执行产生的状态更新，即修改的键和值）和一个 readset（表示提案模拟执行的版本依赖，即模拟过程中所有的键和它的版本号）。模拟结束后，背书人对一条名为背书（endorsement）的消息进行加密签名，该消息包含 writeset 和 readset（以及交易 ID、背书人 ID 和背书人签名等元数据），并在提案响应中将其发送回客户端。客户端收集这些 endorsement 直到满足背书策略的要求，同时所有背书人要产生相同的执行结果（即，相同的 writeset 和 readset）。然后客户端会将交易发送给排序服务。</p><p>这种在排序之前的执行可以容忍非确定性链码，执行结果的不一致会导致它无法收集足够数量的背书。同时背书人若怀疑受到 DoS 攻击，可以根据本地协议单方面终止执行交易。</p><h3 id="3-3-Ordering-Phase"><a href="#3-3-Ordering-Phase" class="headerlink" title="3.3 Ordering Phase"></a>3.3 Ordering Phase</h3><p>当客户端收集到足够的背书时，它组装一个交易并将其提交给排序服务，该交易包含链码操作和参数、交易元数据和一组背书。排序阶段为每个通道（channel，不同的区块链系统可以连接至同一个排序服务，每一个区块链系统都叫做一个通道）提交的交易分别进行总排序。此外，排序服务将多个交易打包成块，并输出块的哈希序列。</p><p>排序服务的节点不维护区块链的状态，也不验证或执行交易。这种架构是 Fabric 的一个关键的特征，使 Fabric 成为第一个将共识与执行和验证完全分离的区块链系统。同时不需要排序服务来防止交易重复，因为在验证阶段节点在读写检查中过滤了重复的交易。</p><h3 id="3-4-Validation-Phase"><a href="#3-4-Validation-Phase" class="headerlink" title="3.4 Validation Phase"></a>3.4 Validation Phase</h3><p>区块直接由排序服务或者 gossip 发送给节点，然后进入验证阶段：</p><ol><li>对区块内的所有交易并行进行背书策略评估。评估是所谓的验证系统链码（VSCC）的任务，如果背书不满足，则交易被标记为无效，其影响将被忽略。</li><li>对区块内的所有交易按序进行读写冲突检查。对于每一笔交易，它都会将 readset 字段中的键与节点本地存储的账本当前状态的键进行比较，并确保它们相同。如果版本不匹配，则转换标记为无效，并忽略其影响。</li><li>最后对账本进行更新，区块被附加到本地存储的账本，区块链状态被更新。当将块添加到账本时，前两个步骤中的有效性检查结果也将以位掩码的形式持久化，该位掩码表示块内有效的交易。这有助于以后恢复状态。此外，所有状态更新都是将写集中的键值对写入本地状态。</li></ol><p>Fabric 帐本中也包括无效的交易，因为排序服务在形成区块时与链码状态无关。在某些需要在后续审计期间跟踪无效交易的用例中需要此功能，与以太坊（只包含有效交易）等其他区块链形成对比。</p><h3 id="3-5-Trust-and-Fault-Model"><a href="#3-5-Trust-and-Fault-Model" class="headerlink" title="3.5 Trust and Fault Model"></a>3.5 Trust and Fault Model</h3><p>所有客户端都是潜在的恶意或者拜占庭节点；节点被分为不同的组织，组织内节点相互信任，但不信任组织外的某一节点；排序服务认为所有客户端和节点都可能是拜占庭的。</p><p>Fabric 将应用程序的信任模型与共识的信任模型解耦。分布式应用程序可以定义自己的信任假设，这些假设通过背书策略传递，并且独立于由排序服务实现的共识假设。</p><h2 id="4-FABRIC-COMPONENTS"><a href="#4-FABRIC-COMPONENTS" class="headerlink" title="4 FABRIC COMPONENTS"></a>4 FABRIC COMPONENTS</h2><p>Fabric 是用 Go 语言编写的，并采用 gRPC 框架在节点之间传输信息。</p><p><img src="/Paper-Fabric/5.png" alt="Fabric 节点的组成"></p><h3 id="4-1-Membership-Service"><a href="#4-1-Membership-Service" class="headerlink" title="4.1 Membership Service"></a>4.1 Membership Service</h3><p>The membership service provider (MSP) 维护着系统内所有节点（clients，peers，OSNs）的身份信息，并负责颁发用来认证和授权的凭据。因为 Fabric 是许可链，节点之间的所有交互都是通过经过身份验证的消息进行的，通常会使用数字签名。用于节点密钥管理和注册的工具也是 MSP 的一部分。</p><h3 id="4-2-Ordering-Service"><a href="#4-2-Ordering-Service" class="headerlink" title="4.2 Ordering Service"></a>4.2 Ordering Service</h3><p>排序服务管理着多个通道，对于每个通道它提供以下服务：</p><ol><li>用于交易排序的原子广播（Atomic broadcast），实现 broadcast 和 deliver 调用</li><li>在成员广播配置更新交易时，修改通道的配置</li><li>访问控制（可选），限制向指定客户端和节点广播交易和接收区块</li></ol><p>OSN 直接将新接收的交易注入原子广播（例如 Kafka 代理，OSNs 作为节点和 Kafka 之间的代理）。OSNs 将从原子广播接收的交易批处理并形成块。一旦满足以下三个条件之一，即成块：</p><ol><li>该块包含指定的最大交易数</li><li>块已达到最大大小（字节）</li><li>从接收到新块的第一个交易起已经过去了一段时间</li></ol><p><strong>该批处理过程是确定性的，因此在所有节点上产生相同的块</strong>（这是由原子广播的特性决定的）。前两点会形成相同区块很容易理解，为了满足第三个条件，节点在收到区块第一个交易时会启动一个计时器，如果到达设定时间还没有成块，节点就会在通道中广播一条 time-to-cut 交易表明要成块的区块号。</p><p>排序服务的实现：</p><ul><li><p><strong>Raft</strong>（推荐）</p><p>  作为 v1.4.1 的新特性，Raft 是一种基于 etcd 中 Raft 协议实现的崩溃容错（Crash Fault Tolerant，CFT）排序服务。Raft 遵循“领导者跟随者”模型，这个模型中，在每个通道上选举领导者节点，其决策被跟随者复制。Raft 排序服务会比基于 Kafka 的排序服务更容易设置和管理，它的设计允许不同的组织为分布式排序服务贡献节点。</p></li><li><p><strong>Kafka</strong>（在 v2.0 中被弃用）</p><p>  和基于 Raft 的排序类似，Apache Kafka 是一个 CFT 的实现，它使用“领导者和跟随者”节点配置。Kafka 利用一个 ZooKeeper 进行管理。基于 Kafka 的排序服务从 Fabric v1.0 开始就可以使用，但许多用户可能会发现管理 Kafka 集群的额外管理开销令人生畏或不受欢迎。</p></li><li><p><strong>Solo</strong>（在 v2.0 中被弃用）</p><p>  排序服务的 Solo 实现仅仅是为了测试，并且只包含了一个单一的排序节点。它已经被弃用了，可能会在将来的版本中被完全移除。</p></li></ul><h3 id="4-3-Peer-Gossip"><a href="#4-3-Peer-Gossip" class="headerlink" title="4.3 Peer Gossip"></a>4.3 Peer Gossip</h3><p>将执行、排序和验证阶段分离的一个优点是它们可以独立扩展。由于大多数共识算法（在 CFT 和 BFT 模型中）都有带宽限制，排序服务的吞吐量会受到其节点的网络容量的限制。研究表明共识性能不能通过增加节点数量来增强，这样做吞吐量反而会降低。然而，由于排序和验证是分离的，因此在排序阶段之后，可以将执行结果广播给所有节点进行验证；以及向新加入的节点和长期断开连接的节点的状态同步，这正是 gossip 部分的目标。</p><p>Gossip 的通信层基于 gRPC，并利用 TLS 相互认证，其组件维护系统中最新的在线成员视图。</p><p>Fabric gossip 使用两个阶段进行信息传播：</p><ul><li>push：每个节点从成员视图中随机选取一组活跃的邻居节点，并向它们转发消息</li><li>pull：每个节点周期性地访问一组随机选择的节点并请求丢失的消息。</li></ul><p>为了减少从排序节点向网络发送块的负载，该协议还选择一个领导节点从排序服务中 pull 区块并发起 gossip。</p><h3 id="4-4-Ledger"><a href="#4-4-Ledger" class="headerlink" title="4.4 Ledger"></a>4.4 Ledger</h3><p>Ledger 由一个 block store 和一个 peer transaction manager 组成：</p><ul><li>Ledger block store：由一组仅添加的文件组成，同时维护一些索引，用于随机访问块或块中的交易。</li><li>Peer transaction manager（PTM）：在版本化的键值储存中维护最新状态（key，val，ver）</li></ul><p>对于交易验证，PTM 顺序验证块中的所有交易。这将检查一个交易是否与之前的任何交易冲突（当前块或更早的块中）。对于 readset 中的任何键，如果 readset 中记录的版本与最新状态下的版本不同（假设所有之前的有效交易都已提交），则 PTM 将该交易标记为无效。PTM 会计算并保存一个 savepoint，表示成功应用的最大块数，用于崩溃中恢复时从持久化块中恢复索引和最新状态。</p><h3 id="4-5-Chaincode-Execution"><a href="#4-5-Chaincode-Execution" class="headerlink" title="4.5 Chaincode Execution"></a>4.5 Chaincode Execution</h3><p>链码的执行环境与节点低耦合，它支持用于添加新的链码编程语言的插件，目前支持 Go、Java 和 Node。</p><p>每个用户级或应用程序链码都在 Docker 容器的一个单独进程中运行，这将链码彼此隔离，并与节点隔离。而系统链码直接在节点进程中运行，可以实现 Fabric 所需的特定功能，并且可以在用户链码之间的隔离过于严格的情况下使用。</p><h3 id="4-6-Configuration-and-System-Chaincodes"><a href="#4-6-Configuration-and-System-Chaincodes" class="headerlink" title="4.6 Configuration and System Chaincodes"></a>4.6 Configuration and System Chaincodes</h3><p>Fabric 可以通过 channel configuration 和 system chaincodes 来定制结构。每个通道形成一个逻辑区块链，通道的配置保存在特殊 configuration blocks（genesis block）的元数据中。通道配置包括：</p><ol><li>确定参与节点的 MSPs</li><li>OSNs 的网络地址</li><li>实现共识和排序服务的共享配置（例如 batch size 和 timeouts）</li><li>制定访问排序服务的操作（broadcast 和 deliver）</li><li>制定修改通道配置的规则</li></ol><h2 id="5-EVALUATION"><a href="#5-EVALUATION" class="headerlink" title="5 EVALUATION"></a>5 EVALUATION</h2><p>此节介绍一些初步的性能数据和影响因素。引入 Fabric Coin（Fabcoin，UTXO cryptocurrencies）用于性能测试和比较。</p><h2 id="6-APPLICATIONS-AND-USE-CASES"><a href="#6-APPLICATIONS-AND-USE-CASES" class="headerlink" title="6 APPLICATIONS AND USE CASES"></a>6 APPLICATIONS AND USE CASES</h2><p>略</p><h2 id="7-RELATED-WORK"><a href="#7-RELATED-WORK" class="headerlink" title="7 RELATED WORK"></a>7 RELATED WORK</h2><p>略</p><h2 id="8-CONCLUSION"><a href="#8-CONCLUSION" class="headerlink" title="8 CONCLUSION"></a>8 CONCLUSION</h2><p>未来的改进工作：</p><ol><li>探索基准测试和优化实现性能</li><li>可扩展到大型部署</li><li>一致性保证和更通用的数据模型</li><li>通过不同的共识协议保证其他弹性</li><li>通过加密技术对交易和账本数据进行隐私和保密</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记(01)：Go 语言</title>
    <link href="/ByteDance-1/"/>
    <url>/ByteDance-1/</url>
    
    <content type="html"><![CDATA[<p>示例代码在我的 Github 上：<a href="https://github.com/qanlyma/go-by-example">基础代码</a>，<a href="https://github.com/qanlyma/go-project-example/tree/V0">进阶代码</a></p><span id="more"></span><h2 id="1-Go-语言基础"><a href="#1-Go-语言基础" class="headerlink" title="1 Go 语言基础"></a>1 Go 语言基础</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>在早期 CPU 都是以单核的形式顺序执行机器指令。Go 语言的祖先 C 语言正是这种顺序编程语言的代表。顺序编程语言中的顺序是指：所有的指令都是以串行的方式执行，在相同的时刻有且仅有一个 CPU 在顺序执行程序的指令。</p><p>随着处理器技术的发展，单核时代以提升处理器频率来提高运行效率的方式遇到了瓶颈，单核 CPU 发展的停滞，给多核 CPU 的发展带来了机遇。相应地，编程语言也开始逐步向并行化的方向发展。</p><p>Go 语言正是在多核和网络化的时代背景下诞生的原生支持并发的编程语言。Go 语言从底层原生支持并发，无须第三方库，开发人员可以很轻松地在编写程序时决定怎么使用 CPU 资源。</p><p>Go 语言的并发是基于 goroutine 的，goroutine 类似于线程但并非线程。可以将 goroutine 理解为一种虚拟线程。Go 语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。</p><p>多个 goroutine 中，Go 语言使用通道（channel）进行通信，通道是一种内置的数据结构，可以让用户在不同的 goroutine 之间同步发送具有类型的消息。这让编程模型更倾向于在 goroutine 之间发送消息，而不是让多个 goroutine 争夺同一个数据的使用权。程序可以将需要并发的环节设计为生产者模式和消费者的模式，将数据放入通道，通道另外一端的代码将这些数据进行并发计算并返回结果。</p><p><strong>特点</strong>：</p><ul><li>高性能、高并发</li><li>语法简单、学习曲线平滑</li><li>丰富的标准库</li><li>完善的工具链</li><li>静态链接</li><li>快速编译</li><li>跨平台</li><li>垃圾回收</li></ul><h3 id="1-2-容器"><a href="#1-2-容器" class="headerlink" title="1.2 容器"></a>1.2 容器</h3><h4 id="1-2-1-array"><a href="#1-2-1-array" class="headerlink" title="1.2.1 array"></a>1.2.1 array</h4><p>数组是一段固定长度的<strong>连续内存区域</strong>。在 Go 语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化，因此在 Go 语言中很少直接使用数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 数组变量名 [元素数量]Type<br></code></pre></td></tr></table></figure><p>也可以是多维数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> array_name [size1][size2]...[sizen] array_type<br></code></pre></td></tr></table></figure><h4 id="1-2-2-slice"><a href="#1-2-2-slice" class="headerlink" title="1.2.2 slice"></a>1.2.2 slice</h4><p>切片（slice）是对数组的一个连续片段的引用（左闭右开），所以切片是一个引用类型。Go 语言中切片的内部结构包含地址（指针）、大小和容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime/slice.go</span><br><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer <span class="hljs-comment">// 元素指针</span><br><span class="hljs-built_in">len</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 长度 </span><br><span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice[开始位置 : 结束位置]<br></code></pre></td></tr></table></figure><ul><li>取出的元素数量为：结束位置 - 开始位置；</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)-1] 获取；</li><li>当缺省开始位置时，表示从连续区域开头到结束位置；</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li><li>两者同时缺省时，与切片本身等效；</li><li>两者同时为 0 时，等效于空切片，一般用于<strong>切片复位</strong>。</li></ul><p>切片类型也可以被声明:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name1 []Type <span class="hljs-comment">// nil 切片</span><br><br>name2 := <span class="hljs-built_in">make</span>([]Type, size, <span class="hljs-built_in">cap</span>) <span class="hljs-comment">// 空切片</span><br></code></pre></td></tr></table></figure><p><strong>使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</strong></p><p><strong>nil 切片与空切片：</strong></p><ul><li><p>nil 切片：指针并不指向底层的数组，而是指向一个没有实际意义的地址；<br>  len &#x3D; 0 且 cap &#x3D; 0；<code>var s []int</code></p></li><li><p>空切片：指针指向底层数组的地址；len &#x3D; 0，容量由指向的底层数组决定；<br>  <code>s1 := []int&#123;&#125;</code> 或 <code>s2 := make([]int, 0)</code></p></li><li><p>nil 切片和空切片的区别主要在于指向的地址不同。</p></li></ul><p>多维切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-1/12.png"></p><p>注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>s1 := slice[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>s2 := s1[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]<br><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">100</span>)<br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">200</span>)<br><br>s1[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span><br><br>fmt.Println(s1)<span class="hljs-comment">// [2 3 20]</span><br>fmt.Println(s2)<span class="hljs-comment">// [4 5 6 7 100 200]</span><br>fmt.Println(slice)<span class="hljs-comment">// [0 1 2 3 20 5 6 7 100 9]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程如下：</p><p><img src="/ByteDance-1/14.png"><br><img src="/ByteDance-1/15.png"><br><img src="/ByteDance-1/16.png"></p><p>s2 扩容之后更换了底层数组，所以不再受 s1 影响了。</p><p><img src="/ByteDance-1/17.png"></p><p><strong>扩容规则（1.18 版本之后）：</strong></p><ul><li>当原 slice 容量小于 256 的时候，新 slice 容量为原来的 2 倍</li><li>原 slice 容量超过 256，新 slice 容量 newcap &#x3D; oldcap + (oldcap+3*256)&#x2F;4</li><li>由于内存对齐，新 slice 的容量要大于等于按照前半部分生成的 newcap</li></ul><p><strong>参数传递：</strong></p><p>当 slice 作为函数参数时，就是一个普通的结构体。若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。</p><ul><li>通过类似 <code>s[i] = 10</code> 这种操作可以改变 slice 底层数组元素值</li><li>在函数中使用 <code>s = append(s, 100)</code> 是无法改变外层 slice 的</li></ul><h4 id="1-2-3-map"><a href="#1-2-3-map" class="headerlink" title="1.2.3 map"></a>1.2.3 map</h4><p>Go 语言中 map 是一种特殊的数据结构，一种元素对（pair）的<strong>无序</strong>集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构。</p><p>在 Go 的内部实现中，map 是通过哈希表来实现的。哈希表用一个哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index）。这样，开销主要在哈希函数的计算以及数组的常数访问时间。哈希查找表一般会存在“碰撞”的问题，就是说不同的 key 被哈希到了同一个 bucket。一般有两种应对方法：<strong>链表法</strong>和<strong>开放地址法</strong>。链表法将一个 bucket 实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表。开放地址法则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。Go 使用前者解决哈希碰撞问题。</p><p>在源码中，表示 map 的结构体是 hmap，它是 hashmap 的缩写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>count     <span class="hljs-type">int</span><span class="hljs-comment">// 元素个数，调用 len(map) 时，直接返回此值</span><br>flags     <span class="hljs-type">uint8</span><br>B         <span class="hljs-type">uint8</span><span class="hljs-comment">// buckets 的对数 log_2</span><br>noverflow <span class="hljs-type">uint16</span><span class="hljs-comment">// overflow 的 bucket 近似数</span><br>hash0     <span class="hljs-type">uint32</span><span class="hljs-comment">// 计算 key 的哈希的时候会传入哈希函数</span><br><br>    <span class="hljs-comment">// 指向 buckets 数组，大小为 2^B</span><br>    <span class="hljs-comment">// 如果元素个数为 0，就为 nil</span><br>buckets    unsafe.Pointer<br><span class="hljs-comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span><br><span class="hljs-comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span><br>oldbuckets unsafe.Pointer<br><br>nevacuate  <span class="hljs-type">uintptr</span><span class="hljs-comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span><br>extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure><p>B 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value，buckets 是一个指针，最终它指向的是一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p><img src="/ByteDance-1/20.png"></p><ul><li><p>当我们插入一个键值对时，首先会根据键的哈希值计算出对应的桶的索引。然后，如果该桶为空，直接将键值对放入其中；如果不为空，则需要遍历链表，查找是否已经存在相同的键。如果存在相同的键，那么会更新对应的值；如果不存在相同的键，会将新的键值对添加到链表的末尾。</p></li><li><p>当我们查询一个键的值时，也是通过计算哈希值找到对应的桶，然后遍历链表查找是否存在相同的键。如果找到了相同的键，就返回对应的值；如果遍历完链表仍然没有找到相同的键，就表示该键不存在。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mapname <span class="hljs-keyword">map</span>[keytype]valuetype<span class="hljs-comment">// 若只有此行，添加元素会 panic</span><br>mapname = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keytype]valuetype)<br></code></pre></td></tr></table></figure><p>使用 delete() 内建函数从 map 中删除一组键值对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(<span class="hljs-keyword">map</span>, 键)<br></code></pre></td></tr></table></figure><p>Go 语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go 语言中的并行垃圾回收效率比写一个清空函数要高效的多。</p><p>当 map 和 slice 作为函数参数时，在函数参数内部对 map 的操作会影响 map 自身；而对 slice 却不会。</p><p>主要原因：一个是指针（*hmap），一个是结构体（slice）。Go 语言中的函数传参都是值传递，在函数内部，参数会被 copy 到本地。<code>*hmap</code> 指针 copy 完之后，仍然指向同一个 map，因此函数内部对 map 的操作会影响实参。而 slice 被 copy 后，会成为一个新的 slice，对它进行的操作不会影响到实参。</p><p><strong>扩容过程</strong>：</p><p>使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐塞满，查找、插入、删除 key 的效率也会越来越低。最理想的情况是一个 bucket 只装一个 key，这样，就能达到 O(1) 的效率，但这样空间消耗太大，用空间换时间的代价太高。</p><p>Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体的 key，这实际上又用了时间换空间。这样做要有一个度，不然所有的 key 都落在了同一个 bucket 里，直接退化成了链表，各种操作的效率直接降为 O(n)，是不行的。</p><p>因此，需要有一个指标来衡量前面描述的情况，这就是装载因子：<code>loadFactor := count / (2^B)</code>。count 就是 map 的元素个数，2^B 表示 bucket 数量。</p><p>触发扩容的条件：</p><ul><li>装载因子超过阈值，源码里定义的阈值是 6.5。</li><li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;&#x3D; 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li></ul><p>由于 map 扩容需要将原有的 key&#x2F;value 重新搬迁到新的内存地址，如果有大量的 key&#x2F;value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。每次操作一个旧桶的时，将旧数据驱逐到新桶，读取时不进行驱逐，只判断读取新桶还是旧桶。</p><h4 id="1-2-4-list"><a href="#1-2-4-list" class="headerlink" title="1.2.4 list"></a>1.2.4 list</h4><p>列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。</p><p>在 Go 语言中，列表使用 <code>container/list</code> 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">list1 := list.New()<br><br><span class="hljs-keyword">var</span> list2 list.List<br></code></pre></td></tr></table></figure><h4 id="1-2-5-nil"><a href="#1-2-5-nil" class="headerlink" title="1.2.5 nil"></a>1.2.5 nil</h4><p>在 Go 语言中，布尔类型的零值（初始值）为 <code>false</code>，数值类型的零值为 <code>0</code>，字符串类型的零值为空字符串 <code>&quot;&quot;</code>，而指针、切片、映射、通道、函数和接口的零值则是 <code>nil</code>。</p><p><strong>不同类型的 nil 是不能比较的</strong>，不同类型的 nil 值占用的内存大小可能是不一样的。</p><h3 id="1-3-基础语法"><a href="#1-3-基础语法" class="headerlink" title="1.3 基础语法"></a>1.3 基础语法</h3><p>Golang 的安装和基础使用，可以参考<a href="https://www.runoob.com/go/go-tutorial.html">菜鸟教程</a>。</p><p>补充几点：</p><ol><li>错误处理</li></ol><p><img src="/ByteDance-1/1.png"></p><ol start="2"><li>字符串操作</li></ol><p><img src="/ByteDance-1/2.png"></p><ol start="3"><li>字符串格式化</li></ol><p><img src="/ByteDance-1/3.png"></p><ol start="4"><li><p>JSON 处理</p><p> 对于一个已有的结构体，只要保证每个字段的第一个字母是大写（公开字段），就可以用 JSON.Marshal 序列化成一个 JSON 字符串。</p></li></ol><p><img src="/ByteDance-1/4.png"></p><ol start="5"><li>时间处理</li></ol><p><img src="/ByteDance-1/5.png"></p><ol start="6"><li>数字解析</li></ol><p><img src="/ByteDance-1/6.png"></p><ol start="7"><li>进程信息</li></ol><p><img src="/ByteDance-1/7.png"></p><h3 id="1-4-关键字和标识符"><a href="#1-4-关键字和标识符" class="headerlink" title="1.4 关键字和标识符"></a>1.4 关键字和标识符</h3><p>Go 语言中的关键字一共有 25 个：</p><p><img src="/ByteDance-1/11.png"></p><p>预定义标识符一共有 36 个：</p><p><img src="/ByteDance-1/13.png"></p><h2 id="2-Go-语言进阶"><a href="#2-Go-语言进阶" class="headerlink" title="2 Go 语言进阶"></a>2 Go 语言进阶</h2><h3 id="2-1-Goroutine"><a href="#2-1-Goroutine" class="headerlink" title="2.1 Goroutine"></a>2.1 Goroutine</h3><ul><li><strong>线程</strong>：程序执行的最小单元，是由寄存器集合和堆栈组成，线程是进程中的一个实体，可共享同一进程中所拥有的全部资源。</li><li><strong>协程</strong>：goroutine 是一种比线程更加轻量级的存在。一个进程可以有多个线程，一个线程可以有多个协程。</li></ul><p><strong>区别：</strong></p><ul><li><p><strong>内存占用</strong></p><p>  创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。</p></li><li><p><strong>创建和销毀</strong></p><p>  Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</p></li><li><p><strong>切换</strong></p><p>  当 threads 切换时，需要保存各种寄存器，以便将来恢复；而 goroutines 切换只需保存三个寄存器：Program Counter，Stack Pointer，BP。goroutines 切换成本比 threads 要小得多。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello goroutine : &quot;</span> + fmt.Sprint(i))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloGoRoutine</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br>hello(j)<br>&#125;(i)<br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-CSP"><a href="#2-2-CSP" class="headerlink" title="2.2 CSP"></a>2.2 CSP</h3><p>Communicating Sequential Processes 提倡<strong>通过通信共享内存</strong>而不是通过共享内存而实现通信。</p><p><img src="/ByteDance-1/8.png" alt="CSP"></p><h3 id="2-3-Channel"><a href="#2-3-Channel" class="headerlink" title="2.3 Channel"></a>2.3 Channel</h3><ul><li>无缓冲通道：<code>make(chan int)</code></li><li>有缓冲通道：<code>make(chan int, 2)</code></li></ul><p>应用：停止信号、任务定时、解耦生产方和消费方、控制并发数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CalSquare</span><span class="hljs-params">()</span></span> &#123;<br>src := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>dest := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(src)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>src &lt;- i<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(dest)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> src &#123;<br>dest &lt;- i * i<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dest &#123;<br><span class="hljs-built_in">println</span>(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>nil channel</th><th>closed channel</th><th>not nil, not closed channel</th></tr></thead><tbody><tr><td>close</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>读 &lt;- ch</td><td>阻塞</td><td>读到对应类型的零值</td><td>阻塞或正常读取数据</td></tr><tr><td>写 ch &lt;-</td><td>阻塞</td><td>panic</td><td>阻塞或正常写入数据</td></tr></tbody></table><h5 id="Q：Channel-可能会引发-goroutine-泄漏"><a href="#Q：Channel-可能会引发-goroutine-泄漏" class="headerlink" title="Q：Channel 可能会引发 goroutine 泄漏"></a>Q：Channel 可能会引发 goroutine 泄漏</h5><p>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。</p><h5 id="Q：select-语句如何处理多个通道操作"><a href="#Q：select-语句如何处理多个通道操作" class="headerlink" title="Q：select 语句如何处理多个通道操作"></a>Q：select 语句如何处理多个通道操作</h5><ol><li><p>非阻塞通道操作，通过在 default 分支中处理没有准备好执行的操作，可以避免阻塞。</p></li><li><p>超时处理，通过结合 time.After 函数，可以在指定时间内等待通道操作，如果超时则执行其他逻辑。</p></li><li><p>多通道监听，等待任意一个通道准备好执行操作，这在处理多个并发任务时非常有用。</p></li><li><p>优雅关闭，通过监听一个关闭通道，可以在接收到关闭信号时优雅地退出循环或处理未完成的任务。</p></li><li><p>优先级选择，虽然 select 语句默认是随机选择已经准备好的通道操作，但可以通过在 default 分支中处理特定逻辑来实现某种形式的优先级选择。</p></li></ol><h3 id="2-4-Lock-并发安全"><a href="#2-4-Lock-并发安全" class="headerlink" title="2.4 Lock 并发安全"></a>2.4 Lock 并发安全</h3><p>Go 语言的锁：</p><ul><li>互斥锁 <code>Mutex</code></li><li>读写锁 <code>RWMutex</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x    <span class="hljs-type">int64</span><br>lock sync.Mutex <span class="hljs-comment">// 互斥锁</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithLock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;<br>lock.Lock()<br>x += <span class="hljs-number">1</span><br>lock.Unlock()<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithoutLock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;<br>x += <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">()</span></span> &#123;<br>x = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> addWithoutLock()<br>&#125;<br>time.Sleep(time.Second)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WithoutLock:&quot;</span>, x)<br>x = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> addWithLock()<br>&#125;<br>time.Sleep(time.Second)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WithLock:&quot;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-WaitGroup"><a href="#2-5-WaitGroup" class="headerlink" title="2.5 WaitGroup"></a>2.5 WaitGroup</h3><p>计数器：开启协程 +1；执行结束 -1；主协程阻塞直到计数器为 0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ManyGoWait</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">5</span>)                   <span class="hljs-comment">// 计数器 +5</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()     <span class="hljs-comment">// 计数器 -1</span><br>hello(j)<br>&#125;(i)<br>&#125;<br>wg.Wait()                   <span class="hljs-comment">// 阻塞直到计数器为 0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-指针"><a href="#2-6-指针" class="headerlink" title="2.6 指针"></a>2.6 指针</h3><p>Go 语言为程序员提供了控制数据结构指针的能力，但是并不能进行指针运算。Go 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式。</p><h4 id="2-6-1-基础概念"><a href="#2-6-1-基础概念" class="headerlink" title="2.6.1 基础概念"></a>2.6.1 基础概念</h4><p>指针（pointer）在 Go 语言中可以被拆分为两个核心概念：</p><ul><li><p>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</p></li><li><p>切片，由指向起始元素的原始指针、元素数量和容量组成。</p></li></ul><p>受益于这样的约束和拆分，Go 语言的指针类型变量既拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。</p><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go 语言中使用在变量名前面添加 <code>&amp;</code> 操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ptr := &amp;v    <span class="hljs-comment">// v 的类型为 T</span><br>value := *ptr<br></code></pre></td></tr></table></figure><p>取地址操作符 <code>&amp;</code> 和取值操作符 <code>*</code> 是一对互补操作符，<code>&amp;</code> 取出地址，<code>*</code> 根据地址取出地址指向的值。</p><h4 id="2-6-2-使用指针修改值"><a href="#2-6-2-使用指针修改值" class="headerlink" title="2.6.2 使用指针修改值"></a>2.6.2 使用指针修改值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(a, b *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 取 a 指针的值, 赋给临时变量 t</span><br>    t := *a<br>    <span class="hljs-comment">// 取 b 指针的值, 赋给 a 指针指向的变量</span><br>    *a = *b<br>    <span class="hljs-comment">// 将 a 指针的值赋给 b 指针指向的变量</span><br>    *b = t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x, y := <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>    swap(&amp;x, &amp;y)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>*</code> 操作符作为<strong>右值</strong>时，意义是取指针的值，作为<strong>左值</strong>时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，<code>*</code> 操作符的根本意义就是操作指针指向的变量。</p><h4 id="2-6-3-new-函数"><a href="#2-6-3-new-函数" class="headerlink" title="2.6.3 new() 函数"></a>2.6.3 new() 函数</h4><p>Go 语言还提供了另外一种方法来创建指针变量：<code>new(类型)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-built_in">new</span>(<span class="hljs-type">string</span>)<br>*str = <span class="hljs-string">&quot;Go语言教程&quot;</span><br>fmt.Println(*str)<br></code></pre></td></tr></table></figure><p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p><h5 id="Q：make-和-new-方法有什么区别"><a href="#Q：make-和-new-方法有什么区别" class="headerlink" title="Q：make 和 new 方法有什么区别"></a>Q：make 和 new 方法有什么区别</h5><ul><li>make 用于初始化内置的数据结构，如数组、切片和 channel 等。</li><li>new 用于分配并创建一个指向对应类型的指针。</li></ul><h2 id="3-面向对象编程"><a href="#3-面向对象编程" class="headerlink" title="3 面向对象编程"></a>3 面向对象编程</h2><p>Go 语言的面向对象编程有三个重要的思想：</p><ul><li><p>封装：Go 语言通过 struct 结构体的方式来实现封装，结构体可以包含各种类型的变量和方法，可以将一组相关的变量和方法封装在一起。使用首字母大小写控制变量和方法的访问权限，实现了信息隐藏和访问控制。</p></li><li><p>继承：Go 语言中没有传统的继承机制，但是可以使用嵌入类型来实现类似继承的效果，将一个类型嵌入到另一个类型中，从而继承嵌入类型的方法和属性。嵌入式类型的特点是可以直接访问嵌入类型的属性和方法，不需要通过接口或者其他方式进行转换。在 Go 语言中，可以通过 struct 嵌套和 interface 嵌套来实现继承的效果。</p></li><li><p>多态：Go 语言通过接口来实现多态，一个类型只需要实现了接口的所有方法，就可以被赋值给该接口类型的变量。这样可以实现类似于面向对象语言中的多态性。多态性使得程序可以根据上下文环境自动选择合适的方法实现，提高了代码的灵活性和可复用性。</p></li></ul><h2 id="4-标准库"><a href="#4-标准库" class="headerlink" title="4 标准库"></a>4 标准库</h2><h3 id="4-1-context"><a href="#4-1-context" class="headerlink" title="4.1 context"></a>4.1 context</h3><p>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。context.Context 类型的值可以协调多个 groutine 中的代码执行“取消”操作，并且可以存储键值对。最重要的是它是并发安全的。</p><p>Go 常用来写后台服务，通常只需要几行代码，就可以搭建一个 http server。在 Go 的 server 里，通常每来一个请求都会启动若干个 goroutine 同时工作：有些去数据库拿数据，有些调用下游接口获取相关数据……</p><p><img src="/ByteDance-1/18.png"></p><p>这些 goroutine 需要共享这个请求的基本数据，例如登陆的 token，处理请求的最大超时时间等等。当请求被取消或是处理时间太长，这有可能是使用者关闭了浏览器或是已经超过了请求方规定的超时时间，请求方直接放弃了这次请求结果。这时，所有正在为这个请求工作的 goroutine 需要快速退出，因为它们不再被需要了。在相关联的 goroutine 都退出后，系统就可以回收相关的资源。</p><p>Go 语言中的 server 实际上是一个<strong>协程模型</strong>，也就是说一个协程处理一个请求。例如在业务的高峰期，某个下游服务的响应变慢，而当前系统的请求又没有超时控制，或者超时时间设置地过大，那么等待下游服务返回数据的协程就会越来越多。而我们知道，协程是要消耗系统资源的，后果就是协程数激增，内存占用飙涨，甚至导致服务不可用。更严重的会导致雪崩效应，整个服务对外表现为不可用，这肯定是 P0 级别的事故。context 包就是为了解决上面所说问题而开发的：在一组 goroutine 之间传递共享的值、取消信号、deadline 等等。</p><p><img src="/ByteDance-1/19.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() <span class="hljs-type">error</span><br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Done() 返回一个 channel，可以表示 context 被取消的信号：当这个 channel 被关闭时，说明 context 被取消了。注意，这是一个只读的 channel。读一个关闭的 channel 会读出相应类型的零值，并且源码里没有地方会向这个 channel 里面塞入值。换句话说，这是一个 receive-only 的 channel。因此在子协程里读这个 channel，除非被关闭，否则读不出来任何东西。也正是利用了这一点，子协程从 channel 里读出了值（零值）后，就可以做一些收尾工作，尽快退出。</p></li><li><p>Err() 返回一个错误，表示 channel 被关闭的原因。例如是被取消，还是超时。</p></li><li><p>Deadline() 返回 context 的截止时间，通过此时间，函数就可以决定是否进行接下来的操作，如果时间太短，就可以不往下做了，否则浪费系统资源。当然，也可以用这个 deadline 来设置一个 I&#x2F;O 操作的超时时间。</p></li><li><p>Value() 获取之前设置的 key 对应的 value。</p></li></ul><p>对于 Web 服务端开发，往往希望将一个请求处理的整个过程串起来，这就非常依赖于 Thread Local（对于 Go 可理解为单个协程所独有）的变量，而在 Go 语言中并没有这个概念，因此需要在函数调用的时候传递 context。</p><p>现实场景中可能是从一个 HTTP 请求中获取到的 Request-ID：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> requestIDKey <span class="hljs-type">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithRequestID</span><span class="hljs-params">(next http.Handler)</span></span> http.Handler &#123;<br><span class="hljs-keyword">return</span> http.HandlerFunc(<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 从 header 中提取 request-id</span><br>reqID := req.Header.Get(<span class="hljs-string">&quot;X-Request-ID&quot;</span>)<br><span class="hljs-comment">// 创建 valueCtx。使用自定义的类型，不容易冲突</span><br>ctx := context.WithValue(<br>req.Context(), requestIDKey, reqID)<br><br><span class="hljs-comment">// 创建新的请求</span><br>req = req.WithContext(ctx)<br><br><span class="hljs-comment">// 调用 HTTP 处理函数</span><br>next.ServeHTTP(rw, req)<br>&#125;<br>)<br>&#125;<br><br><span class="hljs-comment">// 获取 request-id</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetRequestID</span><span class="hljs-params">(ctx context.Context)</span></span> <span class="hljs-type">string</span> &#123;<br>ctx.Value(requestIDKey).(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 拿到 reqId，后面可以记录日志等等</span><br>reqID := GetRequestID(req.Context())<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>handler := WithRequestID(http.HandlerFunc(Handle))<br>http.ListenAndServe(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>&#125;<br></code></pre></td></tr></table></figure><p>取消 goroutine：我们先来设想一个场景：打开外卖的订单页，地图上显示外卖小哥的位置，而且是每秒更新 1 次。app 端向后台发起 websocket 连接（现实中可能是轮询）请求后，后台启动一个协程，每隔 1 秒计算 1 次小哥的位置，并发送给端。如果用户退出此页面，则后台需要取消此过程，退出 goroutine，系统回收资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithTimeout(context.Background(), time.Hour)<br><span class="hljs-keyword">go</span> Perform(ctx)<br><br><span class="hljs-comment">// ……</span><br><span class="hljs-comment">// app 端返回页面，调用 cancel 函数</span><br>cancel()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Perform</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        calculatePos()<br>        sendResult()<br><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            <span class="hljs-comment">// 被取消，直接返回</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">case</span> &lt;-time.After(time.Second):<br>            <span class="hljs-comment">// block 1 秒钟 </span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>WithTimeOut 函数返回的 context 和 cancelFun 是分开的。context 本身并没有取消函数，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：由父节点 context 流向子节点 context。</p><h3 id="4-2-reflect"><a href="#4-2-reflect" class="headerlink" title="4.2 reflect"></a>4.2 reflect</h3><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p><p>使用反射的常见场景有以下两种：</p><ul><li>不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。</li><li>不能明确传入函数的参数类型，需要在运行时处理任意对象。</li></ul><p>反射的缺点：</p><ul><li>与反射相关的代码，经常是难以阅读的。</li><li>Go 语言作为一门静态语言，编码过程中编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。</li><li>反射对性能影响比较大，比正常代码运行速度慢一到两个数量级。</li></ul><h3 id="4-3-unsafe"><a href="#4-3-unsafe" class="headerlink" title="4.3 unsafe"></a>4.3 unsafe</h3><p>相比于 C 语言中指针的灵活，Go 的指针多了一些限制：</p><ul><li>限制一：Go 的指针不能进行数学运算。</li><li>限制二：不同类型的指针不能相互转换。</li><li>限制三：不同类型的指针不能使用 &#x3D;&#x3D; 或 !&#x3D; 比较。</li><li>限制四：不同类型的指针变量不能相互赋值。</li></ul><p>unsafe 包提供了 2 点重要的能力：</p><ol><li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li><li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li></ol><p>pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</p><p><strong>如何实现字符串和 byte 切片的零拷贝转换：原理上是利用指针的强转。</strong></p><p>完成这个任务，我们需要了解 slice 和 string 的底层数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>Cap  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面是反射包下的结构体，路径：src&#x2F;reflect&#x2F;value.go。只需要共享底层 Data 和 Len 就可以实现 zero-copy：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">string2bytes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))<br><br>bh := reflect.SliceHeader &#123;<br>Data: stringHeader.Data,<br>Len:  stringHeader.Len,<br>Cap:  stringHeader.Len,<br>&#125;<br><br><span class="hljs-keyword">return</span> *(*[]<span class="hljs-type">byte</span>)(unsafe.Pointer(&amp;bh))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bytes2string</span><span class="hljs-params">(b []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))<br><br>sh := reflect.StringHeader &#123;<br>Data: sliceHeader.Data,<br>Len:  sliceHeader.Len,<br>&#125;<br><br><span class="hljs-keyword">return</span> *(*<span class="hljs-type">string</span>)(unsafe.Pointer(&amp;sh))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-依赖管理"><a href="#5-依赖管理" class="headerlink" title="5 依赖管理"></a>5 依赖管理</h2><ul><li><strong>GOPATH</strong>：设置环境变量，项目代码依赖 src 下的代码。无法实现 package 的多版本控制。</li><li><strong>Go Vendor</strong>：项目目录下增加 vendor 文件存放依赖包副本。同一项目无法依赖一个 package 的两个不同版本。</li><li><strong>Go Module</strong>：通过 go.mod 文件管理依赖包版本</li></ul><p>依赖管理三要素：</p><ol><li>配置文件，描述依赖：go.mod</li><li>中心仓库管理依赖库：Proxy</li><li>本地工具：go get&#x2F;mod</li></ol><p><img src="/ByteDance-1/9.png" alt="Proxy"></p><h2 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h2><h3 id="6-1-单元测试"><a href="#6-1-单元测试" class="headerlink" title="6.1 单元测试"></a>6.1 单元测试</h3><ul><li>测试文件以 <code>_test.go</code> 结尾</li><li>函数 <code>func TestXxx(t *testing.T)</code></li><li>初始化逻辑放入 <code>TestMain(m *testing.M)</code></li></ul><p>print.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloTom</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tom&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>print_test.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHelloTom</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>output := HelloTom()<br>expectOutput := <span class="hljs-string">&quot;Tom&quot;</span><br>assert.Equal(t, expectOutput, output)<br>&#125;<br></code></pre></td></tr></table></figure><p>覆盖率：<code>go test Xxx_test.go Xxx.go --cover</code></p><h3 id="6-2-Mock"><a href="#6-2-Mock" class="headerlink" title="6.2 Mock"></a>6.2 Mock</h3><p>为一个函数&#x2F;方法打桩，不再依赖本地文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFirstLine</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>open, err := os.Open(<span class="hljs-string">&quot;log&quot;</span>)<br><span class="hljs-keyword">defer</span> open.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>scanner := bufio.NewScanner(open)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br><span class="hljs-keyword">return</span> scanner.Text()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ProcessFirstLine</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>line := ReadFirstLine()<br>destLine := strings.ReplaceAll(line, <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;00&quot;</span>)<br><span class="hljs-keyword">return</span> destLine<br>&#125;<br></code></pre></td></tr></table></figure><p>以上函数读取 log 文件的第一行并将 “11” 替换为 “00”，依赖于本地的文件，而使用 Mock 可以避免依赖。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProcessFirstLine</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>firstLine := ProcessFirstLine()<br>assert.Equal(t, <span class="hljs-string">&quot;line00&quot;</span>, firstLine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProcessFirstLineWithMock</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>monkey.Patch(ReadFirstLine, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;line110&quot;</span><br>&#125;)<br><span class="hljs-keyword">defer</span> monkey.Unpatch(ReadFirstLine)<br>line := ProcessFirstLine()<br>assert.Equal(t, <span class="hljs-string">&quot;line000&quot;</span>, line)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-Benchmark"><a href="#6-3-Benchmark" class="headerlink" title="6.3 Benchmark"></a>6.3 Benchmark</h3><p>基准测试 <code>go test -bench .</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitServerIndex</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ServerIndex[i] = i+<span class="hljs-number">100</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Select</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> ServerIndex[rand.Intn(<span class="hljs-number">10</span>)]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSelect</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>InitServerIndex()<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Select()<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSelectParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>InitServerIndex()<br>b.ResetTimer()<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br>Select()<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/ByteDance-1/10.png" alt="result"></p>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 区块链扩容调研</title>
    <link href="/Research-Scalability/"/>
    <url>/Research-Scalability/</url>
    
    <content type="html"><![CDATA[<p>研一时写的一篇关于区块链 Layer 1 和 Layer 2 的扩容调研报告。</p><span id="more"></span><h2 id="一、区块链扩容"><a href="#一、区块链扩容" class="headerlink" title="一、区块链扩容"></a>一、区块链扩容</h2><h3 id="1-1-为什么需要扩容"><a href="#1-1-为什么需要扩容" class="headerlink" title="1.1 为什么需要扩容"></a>1.1 为什么需要扩容</h3><p>在比特币诞生之初，创始人中本聪并没有特意限制区块的大小，区块最大可以达到 32 MB。有人认为区块链上限过高容易造成计算资源的浪费，还容易发生 DDOS 攻击（分布式拒绝服务攻击）。因此，为了保证比特币系统的安全和稳定，中本聪决定临时将区块大小限制在 1 MB。</p><p>随着越来越多的人关注和使用比特币，链上最高时有上万笔交易积压，很多用户为了尽快让自己的交易被打包，不得不增加手续费，有时候比特币转账交易费高达几十美元。网络拥堵时，一个比特币交易甚至需要花费好几天才能被打包，同理也使得以太坊上的 gas 费用居高不下。比特币和以太坊作为区块链 1.0 和 2.0 的代表，比特币每秒大约只能处理 7 个交易，性能只有 7 TPS；以太坊每秒只能处理 15 个交易，性能只有 15 TPS。而作为中心化的代表，淘宝在 17 年双十一超过了 200,000 TPS，可见区块链的 TPS 跟中心化应用还有很大的差距。</p><p>与很多分布式系统一样，区块链技术中也有一个“不可能三角形”，比特币和以太坊在最早诞生时最关注的是去中心化和安全，牺牲了可扩展性。后来，市场上不断有一些新的区块链项目牺牲掉去中心化或者安全性来为可扩展性保驾护航，试图部署出一个吞吐量较高的区块链网络。迄今为止，还没有人找到去中心化、可扩展性和安全性三全其美的策略，打造出一个充分运行、基于加密货币的大规模区块链网络。但是，如果想把区块链的应用拓展到虚拟货币投资之外，必须得有支持其吞吐量扩容的解决方案。</p><p><img src="/Research-Scalability/1.png" alt="不可能三角"></p><h3 id="1-2-如何扩容"><a href="#1-2-如何扩容" class="headerlink" title="1.2 如何扩容"></a>1.2 如何扩容</h3><p>所谓的扩容方案是指“为了改善区块链交易速度使其达到规模化所提出的解决方案”，各层所提出的扩容方案，其最终目的都是为了解决区块链交易速度的问题。</p><p><img src="/Research-Scalability/2.png" alt="区块链分层"></p><p>目前主要可以分为链上（Layer 1）和链下（Layer 2）的扩容方案。链上扩容是指为了提高区块链的吞吐量而对其进行的任何直接修改，比如比特币修改共识机制来改变区块结构或直接增加区块大小，而以太坊的策略则是改变网络结构进行分片，不同的分片并行处理不同的交易，增加整体吞吐量。而链下扩容是指在不改变公链本身规则的前提下，将数据计算过程等信息移到链下进行，而主链仅记录结果，比如比特币的闪电网络，以太坊的侧链，状态通道和 Rollup 等。下文将对具体方案进行详细介绍。</p><p><img src="/Research-Scalability/3.png" alt="扩容方案"></p><h2 id="二、Layer-1-扩容"><a href="#二、Layer-1-扩容" class="headerlink" title="二、Layer 1 扩容"></a>二、Layer 1 扩容</h2><h3 id="2-1-扩块和隔离见证"><a href="#2-1-扩块和隔离见证" class="headerlink" title="2.1 扩块和隔离见证"></a>2.1 扩块和隔离见证</h3><p>想让一个区块打包更多的交易，最直观的有两种解决办法：一是增加区块大小；二是缩小交易数据的尺寸。这就分别产生了扩块和隔离见证两个扩容方案，当然这两个方案也可以一起使用，可是不论选择何种方案都避免不了区块链的分叉。</p><p>比特币社区中提及比较多的是 2 MB 区块，一部分人希望通过硬分叉直接把区块大小限制从 1 M 改到 2 M，提升单个区块内的交易数，每秒打包的交易就会增加，从而提升 TPS。可是扩块有一些弊端：</p><ul><li>(1) 大区块传播速度变慢，验证速度变慢，导致频繁的重组，双花攻击概率提高；</li><li>(2) 大区块导致储存量大幅度增加，成本提高，节点可能减少，趋向中心化从而影响安全。</li></ul><p>比特币社区有一部分人不接受硬分叉，坚持使用隔离见证（Segwit）方案去优化主链结构，并且结合闪电网络等二层网络结构来改善支付体验。隔离见证的原理是压缩每笔交易的大小，从而增加每个区块可以记录的交易数量。此方案将比特币交易数据分为交易信息和签名信息，对于普通用户来说他们只关心每个账户有多少资产，不需要验证信息，隔离见证就是把区块内的数字签名信息拿出去，让每个区块可以承载更多交易，从而达到扩容的目的。可是这样做的扩容能力有限，依然难以满足大量转账的需求。</p><p>两种方案的支持者方争论不休，随着加密货币市场迎来了前所未有的关注度，比特币价格连创新高，这也让比特币的交易更加拥堵，最终在 2017 年 8 月 1 日导致了比特币历史上第一次重大硬分叉的出现，比特币区块大小由 1 M 扩大到 8 M，同时也诞生出新币种 BCH（比特币现金）。</p><h3 id="2-2-分片"><a href="#2-2-分片" class="headerlink" title="2.2 分片"></a>2.2 分片</h3><p>分片技术（sharding）来自中心化数据库技术，将大型数据库数据进行切分，并分布在特定的服务器中，以提高数据库性能。如果将分片技术运用到区块链中，就相当于将区块链网络里的所有待处理任务进行分解，全网的节点也进行分组，每一组同时处理一个分解后的任务，这样就从原先单一节点处理全网的所有任务变成了多组节点同时处理，如此以来，自然就能大大提升这条链的处理效率。但是分片技术的问题也是显而易见的：分片多用于以太坊网络中，那么跨片区智能合约交易如何处理？片区如何划分？各片区如何同步？</p><p><img src="/Research-Scalability/4.png" alt="分片"></p><p>分片技术根据不同的分片机制可以划分为三种：</p><ul><li>网络分片（network sharding）</li><li>交易分片（transaction sharding）</li><li>状态分片（state sharding）</li></ul><h4 id="2-2-1-网络分片"><a href="#2-2-1-网络分片" class="headerlink" title="2.2.1 网络分片"></a>2.2.1 网络分片</h4><p>网络分片是最基础的一种分片方式，就是将整个区块链网络划分成多个子网络（也就是一个分片），网络中的所有分片并行处理网络中不同的交易。</p><p>但是这个方案会使网络的安全性和去中心化性会下降，比如原来 A 想要在某交易中作恶，因为共识机制的原因，A 需要控制全网的大部分节点或算力才行，但现在因为分片把节点分散到一个个小的区域中，A 只用控制包含这个交易的小区域的大部分节点算力就行。</p><p>幸好分片技术另外一个非常重要的机制就是随机分配，在区块链领域建立随机性的方式主要是利用可验证随机函数（VRF, Verifiable Random Function）。利用随机性，网络可以随机抽取节点形成分片。这样一种随机抽样的方式可以防止恶意节点过度填充单个分片，这样想要作恶的人，就很难知道一个小区域中的节点都有谁，作恶成本会大幅提高，从而分片技术能在保证安全与去中心化的同时，解决效率与可扩展性问题。</p><h4 id="2-2-2-交易分片"><a href="#2-2-2-交易分片" class="headerlink" title="2.2.2 交易分片"></a>2.2.2 交易分片</h4><p>网络分片是其他所有分片的基础，交易分片的前提是先进行网路分片。交易分片主要涉及的问题是哪些交易应该按照特定的属性被分配到哪些分片当中。</p><ul><li>基于 UTXO 的账本系统。在基于 UTXO 的账本系统中，一笔交易可能由多个输入和多个输出构成，我们没有办法按照地址进行交易分片来有效地避免双花问题。比较直观的交易分片方式是按照交易的 hash 值最后几位进行分片。但是这样也有可能导致双花交易，所以不同分片之间不得不进行通信。</li><li>基于账户系统。在基于账户系统中，一笔交易只有一个输入，而输入的地址将被记录在账户系统中。该账户系统在交易分片的每个分片中是全局可见的，因此我们只需要将交易按照发送者的地址进行分片，即可保证同一个账户发出的多笔交易将被在同一个分片当中被处理，这样该分片可以有效的检测双花交易而不需要复杂的跨分片的通信。</li></ul><h4 id="2-2-3-状态分片"><a href="#2-2-3-状态分片" class="headerlink" title="2.2.3 状态分片"></a>2.2.3 状态分片</h4><p>状态分片的关键是将整个存储区分开，让不同的分片存储不同的部分，每个节点只负责托管自己的分片数据，而不是存储完整的区块链状态。状态分片可以减少状态的冗余存储，使得整个区块链网络具有存储的可扩展性。</p><p>在账户型系统中，状态分片是按照账户的地址进行分片的，并且一个特定的分片只会保留一部分状态，而不像是交易分片那样每个节点都保存整个网络中的所有状态。这导致可能需要进行频繁的跨分片通信和状态交换。跨分片通信可能又会降低状态分片的性能。</p><p>在状态分片的情况下，重新分配节点是非常困难的。由于每个分片只保留了网络状态的一部分，所以在一次重新调整网络的过程中，必须要防止调整过大而导致在同步完成前可能会出现的整个系统失效的问题。为了防止系统的中断，必须对网络进行逐步调整，以确保每个分片在所有节点被清空前仍有足够多的旧节点。而新节点在加入分片之前，需要等待同步完该分片中的状态信息之后才可以正式加入分片并提供算力。</p><h3 id="2-3-Casper"><a href="#2-3-Casper" class="headerlink" title="2.3 Casper"></a>2.3 Casper</h3><p>比特币和以太坊当前都采用工作量证明（PoW）共识机制，这是个低效的系统，因为它消耗会大量的电力和能量。而且这个机制可以通过购买更快更强的 ASIC 设备比其他人拥有更高的概率挖到区块，这导致比特币并没有像它希望的那样分散化。如果采取其他共识机制（PoS），改变区块形成的规则，提高系统效率即可增加每秒处理交易。Csaper 就是以太坊选择实行的 PoS 协议，值得一提的是，Casper 并非专为扩容而设计，但它会对以太坊网络容量产生积极影响。</p><p><img src="/Research-Scalability/5.png" alt="PoS"></p><p>在介绍 Casper 之前我们首先要了解无利害关系问题（Nothing at stake），这一问题是由于 PoS 机制不会消耗节点的算力，所以在共识系统出现分叉情况时，出块节点可以在“不受任何损失”的前提下，同时为多条链出块，从而有可能获得“所有收益”。Casper 是一种基于保证金的经济激励共识协议。协议中的节点作为“锁定保证金的验证人”，必须先缴纳保证金才可以参与出块和共识形成。Casper 共识协议通过对这些保证金的直接控制来约束验证人的行为。具体来说就是，如果一个验证人作出了任何 Casper 认为“无效”的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消，从而解决了无利害关系问题。</p><p>从扩容的角度来说，修改后，可以从根本上改变区块形成的规则，往有利于交易量增加的方向修改。但是无论如何改变，共识算法仍然是分布式算法，需要多个节点达成一致，处理的上限是一台机器处理能力的上限。并且共识机制是加密货币的核心，涉及加密货币的整体逻辑，需要全盘考虑对旧区块的承接、安全性、后续发展等问题，还需要做大量的技术尝试。</p><h2 id="三、Layer-2-扩容"><a href="#三、Layer-2-扩容" class="headerlink" title="三、Layer 2 扩容"></a>三、Layer 2 扩容</h2><p>第二层扩容也称链下扩容，是不改变公链基础协议的一种应用层上的扩展方案，即不改动区块链本身的规则（区块大小，共识机制等）。由 Layer 2 协议，区块链事务的“状态生成”可以独立于 Layer 1 之外进行。换句话说 Layer 2 扩容方案是尽可能在不牺牲区块链网络安全性的情况下实现高吞吐量的状态生成。</p><h3 id="3-1-侧链协议"><a href="#3-1-侧链协议" class="headerlink" title="3.1 侧链协议"></a>3.1 侧链协议</h3><p>侧链是与公链并排运行并与之通信的独立区块链，它使用另一个代币与公链代币相互锚定，从而创建了双向桥。侧链是完全独立的，具有自己的共识机制和安全性保证。通过这种解决方案，可以实现数字资产从第一个区块链到第二个区块链的转移，又可以在稍后的时间点从第二个区块链安全返回到第一个区块链。其中第一个区块链通常被称为主区块链或者主链，第二个区块链则被称为侧链。</p><p><img src="/Research-Scalability/7.png" alt="侧链协议"></p><p>由于没有第一层设计的负担，侧链可以支持超出其基础层能力的某些特性，包括但不限于可扩展性和互操作性，同时不依赖于第一层的存储，可以建设多条侧链提供非常高的 TPS。而且得益于其独立性，如果侧链上出现了代码漏洞和大量资金被盗等问题，主链的安全性和稳定性都不会受到影响。缺点是它是一个无信任的环境，用户需要将资金托管转移到侧链，从侧链取回资产时的安全性问题需要被考虑，侧链目前不那么成熟，去中心化也更差。</p><h3 id="3-2-状态通道"><a href="#3-2-状态通道" class="headerlink" title="3.2 状态通道"></a>3.2 状态通道</h3><p>状态通道是固定一组参与者（通常是两名参与者）之间的协议，用以实现安全的链下交易，其中支付通道专门用来支付。支付通道协议具体情况是两名参与者各自通过链上交易在链上锁定保证金，一旦锁定完成，参与者双方即可互相发送形式为轮次、金额、签名的状态更新来实现转账，无需与主链进行交互，只要双方的余额都还为正值即可。一旦参与者中有一方想要停止使用支付通道，可以执行退出操作：将最后的状态更新提交至主链，结算下来的余额会退给发起支付通道的两方。主链可以通过核实签名和最后结余来验证状态更新的有效性，从而防止参与者使用无效状态来退出支付通道。</p><p>该方案会用到一个协议叫 HTLC（Hashed Timelock Contract），其实就是限时转账。A 给 B 转账，A 先冻结一笔钱，并提供一个哈希值，如果在一定时间内 B 能提出一个字符串匹配，则这笔钱转给 B。过了一定时间没有<br>提交这个字符串的话，A 就可以拿回这笔钱。</p><p><img src="/Research-Scalability/12.png" alt="HTLC"></p><p>状态通道带来的优点是交互延迟在毫秒级别，是唯一能够逼近当今互联网用户体验的区块链扩容技术；交易手续费极低，从根本上比所有其他 Layer 2 技术的交易手续费低；水平扩展性强，加节点就能增加总系统容量，TPS 无上限，且互相之间不隔离，不需要有跨分片或者跨链之类的复杂操作。但它的退出模式存在一个问题，即主链无法验证支付通道是否提交了全部交易，也就是说，在提交了状态更新之后是否不再出现新的状态更新。而且它的使用场景较为局限：长期合作关系的双方的支付，偶发性交易难以适用，并且通道不能用于将资金在链外发送给尚未参与的人。此外，状态通道只能在两个参与者之间开设。闪电网络就是比特币使用状态通道的例子。</p><p><img src="/Research-Scalability/6.png" alt="闪电网络"></p><p>状态通道相较于侧链协议有更强的隐私性，并且有即时的最终确定性。但是状态通道需要所有参与者 100% 的在线，在侧链中，你就不需要一直在线。</p><h3 id="3-3-Plasma"><a href="#3-3-Plasma" class="headerlink" title="3.3 Plasma"></a>3.3 Plasma</h3><p>Plasma 由 Vitalik 和 Joseph Poon 在 2017 年共同提出，Plasma 是一种链下交易的技术，从一个新的方向实现了状态通道。它允许创建附加在以太坊主链上的子链，这些子链反过来可以产生他们自己的子链。其结果就是，我们可以在子链级别执行许多复杂的操作，运行拥有数千名用户的整个应用程序，并且只需与以太坊主链进行尽可能少的交互。子链可以更快地操作，且交易费用更低，因为它的操作不需要在整个以太坊区块链存留副本。</p><p>区别于状态通道，Plasma 中能够运行智能合约，如果说状态通道是对交易吞吐量的扩容，那么 Plasma 是对计算能力的扩容。Plasma 是将计算和数据存储都迁移到 Layer 2 进行，由 Layer 2 的执行者周期性地向主链递交 Merkle 根形式的状态承诺。如果执行者递交无效的状态，用户可以向主链上的智能合约提供错误性证明（fraud proof），一旦确认执行者出现欺诈行为，智能合约会没收他的保证金。</p><p><img src="/Research-Scalability/8.png" alt="Plasma"></p><p>虽然说我们可以通过错误性证明，使得提供无效承诺的执行者在主链上遭到惩罚，但 Plasma 的数据并没有提交到链上，如果 Plasma 的执行者拒绝在主链上公开数据，那么用户则无法提供错误性证明，所以 Plasma 面临的最大问题是交易数据可用性。针对这个问题，Plasma 衍生出一些相应的方案，如延长资产从 Layer 2 退出的时间：当出现作恶行为，就能允许资产从 Plasma 链转移回主链。所以在 Plasma 上退出一笔资产的周期会长达一周左右，如果在争议期间没有人提交欺诈证明，那么资产才可以安全退出到主链。相比较而言，普通的侧链就没有这个安全特性。</p><h3 id="3-4-Rollup"><a href="#3-4-Rollup" class="headerlink" title="3.4 Rollup"></a>3.4 Rollup</h3><p>之前介绍的几种链下扩容方案虽然诞生时间很早，但是发展的却比较缓慢，其背后的原因归根结底是数据的可用性（Data Availability）问题。无论是状态通道还是 Plasma 侧链，完整的交易记录和见证数据都只保存在链下，出现争端时如果参与者没有及时提供正确的交易和见证数据，交易的安全性就无法保证。这时一种名为 Rollup 的方案被提了出来。</p><p><img src="/Research-Scalability/9.png" alt="Rollup"></p><p>Rollup 可以被认为是一种压缩技术，多笔交易可以压缩在一起（几千笔交易可以被打包到一个 Rollup 区块中），既能减少交易数据规模，又能降低交易验证负担，因此使得以太坊区块链能处理更多交易。它将所有 Layer 2 上的交易数据快照发送到主链上某个智能合约内，用主链上的单个合约来保管所有的资金，通过在主链上为每一笔交易公开一些数据，让任何人都能通过观察区块链上的 calldata（交易输入数据）来获得 Layer 2 的所有数据。Rollup 区块的状态是由用户以及链下运营者来维护的，因此不会占用主链的存储空间。所有交易的收据都存储在以太坊区块链上，这就提升了 Layer 2 交易的安全性。具体的实现方案目前主要分为 ZK Rollup 和 Optimistic Rollup 两种。</p><h4 id="3-4-1-ZK-Rollup"><a href="#3-4-1-ZK-Rollup" class="headerlink" title="3.4.1 ZK Rollup"></a>3.4.1 ZK Rollup</h4><p>ZK Rollup 是靠着在主链完成零知识证明，链上无需包含签名数据，因为零知识证明就足以证明交易的有效与否，交易有效性就立刻确认，也即数据可用性放在链上，所以 ZK Rollup 对数据存储方面带来了一定程度上的扩展性提升。它的缺点是验证链路的构造没有一个通用的解决方案，所以目前没有很好的办法做到很广义的虚拟机逻辑，简单来说，ZK Rollup 必须对每一个用例定制，程序正确性的验证相对复杂，二层打包节点负担重，成本高，计算零知识证明所需时间长，用户延迟的体验角度仍然比较差，目前只适合简单的转账。</p><h4 id="3-4-2-Optimistic-Rollup"><a href="#3-4-2-Optimistic-Rollup" class="headerlink" title="3.4.2 Optimistic Rollup"></a>3.4.2 Optimistic Rollup</h4><p>ZK Rollup 包含一个 SNARK 零知识证明，合约用它来验证在老的用户状态上施加这批交易，但是生成 SNARK 的成本非常高，所以 Optimistic Rollup 采用了欺诈证明来验证交易有效性。Optimistic Rollup 的理念是由 John Adler 首先构想出来的，它保留了 calldata，主链可以获得所有 Layer 2 的数据，但那些刷新 Layer 2 状态的交易不会在链上被验证，只让主链存储一系列的历史状态根，添加了一个新的状态的一段时间后才将新状态最终敲定，也就是数据可用性放在链下。采用欺诈证明，对提交无效状态的执行者进行惩罚。其链下 OVM 虚拟机可以支持任意智能合约逻辑的实现，与以太坊 EVM 虚拟机搭配使用，开发者就可以用 Solidity 来写代码，实现 DApp 和智能合约之间的无缝互操作性。它的缺点是安全问题，只有使用一到两周的欺诈证明挑战期才足够安全。在挑战期过去以前，没有交易能被认为是确定的。</p><h4 id="3-4-3-比较"><a href="#3-4-3-比较" class="headerlink" title="3.4.3 比较"></a>3.4.3 比较</h4><p><img src="/Research-Scalability/10.png" alt="比较"></p><ul><li><ol><li>Optimistic rollup 和 ZK rollup 的主要区别在于采用了不同的数据证明方式。Optimistic rollup 使用欺诈证明：子链上的交易结果并不直接生成相关证明接入主链，子链仅向主链报告结果。如果有人发现结果错误，他们可以向链上发布一个证明，证明处理计算错误。合约将验证证明，并对结果进行更正。ZK rollup 使用零知识证明: 子链将自身交易采用 ZK-SNARK 技术生成加密证明，证明状态根是执行子链上交易的正确结果。无论计算量有多大，证明都可以在链上快速验证。</li></ol></li><li><ol start="2"><li>Optimistic Rollup 基于加密经济学有效性博弈，只有过了挑战期才能确认交易生效。ZK Rollup 的延迟相对较小，如果一个打包区块中有 1000 笔交易，在普通的服务器上大概需要 20 分钟就可以构造出一个证明。</li></ol></li><li><ol start="3"><li>通用性方面，Optimistic Rollup 明显好于 ZK Rollup，当然它的设计目标就是支持任意智能合约。而 ZK Rollup 目前仅适用于支付之类的特定交易，对于通用智能合约，由于创建零知识证明的成本非常高，部署起来困难较大。</li></ol></li></ul><p>短期看来 Optimistic Rollup 由于较好的通用性会受到开发者的青睐；但从长期来看，随着零知识证明虚拟机的演进，ZK Rollup 会在通用性上不断提高。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>状态通道有一些独特的性质，让它在扩容领域有着独特的地位，它的诸多属性在很多应用中都非常重要。比如游戏、IoT 设备网络、去中心的互联网服务提供商等。Plasma 和状态通道相比，Plasma 中能够运行智能合约，而状态通道则不被允许。分片系统要比 Plasma 链更不易于遭受拒绝服务攻击，分片链提供的防御也更易于普及。但 Plasma 链可以被迭代，新的设计可以更快地被实现，因为每条 Plasma 链都可以在无需与该生态系统中的其他链进行协调的情况下单独地进行部署，而且由单个运营商运行的 Plasma 链还可以提供比分片系统更多的隐私保护。而在分片系统中，所有的数据都是公开的。</p><p>相比于 Plasma 和 ZK Rollup，Optimistic Rollup 做了一些权衡，所以带来的扩展性提升幅度最小，但 Optimistic Rollup 不依赖于什么过于前沿的技术或悬而未决的问题，所以实际推广中 Optimistic Rollup 更好落地。而 ZK Rollup 可以解决 Optimistic Rollup 上的几个根本问题，消除了令人厌恶的尾部风险（通过复杂但可行的攻击方法从 Optimistic Rollup 中盗取资金），将提取资金的时间从几周缩减到几分钟，支持快速的交易确认和退出，并且默认保护隐私。对于需要提高流动性的项目而言，资本运作效率 ZK Rollup 高于 Optimistic Rollup。</p><p>不同的扩容技术有它不同的优缺点，导致适应不同的应用场景，未来不同的扩容技术之间也会是相互合作关系，某一场景下同时使用多种扩容技术。以太坊基金会在今年1月25日宣布淘汰“以太坊 2.0”的说法，改称为“共识层”，设计人员在其中加入当下的一些先进技术，如分片技术、Casper 协议等等。相信伴随着以太坊的全面升级，其 TPS 必将有很大改善，但其中技术上的一些问题还有待大家共同攻坚克难。</p><p><img src="/Research-Scalability/11.png" alt="Eth 2.0"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 登链社区. 突破不可能三角. <a href="https://learnblockchain.cn/column/12">https://learnblockchain.cn/column/12</a>.<br>[2] Croman, K., et al. On Scaling Decentralized Blockchains (A Position Paper).<br>[3] Gangwal A, Gangavalli H R, Thirupathi A. A Survey of Layer-Two Blockchain Protocols.</p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「算」 01. 类型转换</title>
    <link href="/Algorithm-typeTransfer/"/>
    <url>/Algorithm-typeTransfer/</url>
    
    <content type="html"><![CDATA[<p>类型转换的问题。</p><span id="more"></span><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul><li><p>int → int64: <code>i := int64(int)</code></p></li><li><p>int → uint64: <code>ui := uint64(int)</code></p></li><li><p>int → float: <code>f := float64(int)</code></p></li><li><p>int → string: <code>str := strconv.Itoa(int)</code></p></li><li><p>int64 → string: <code>str := strconv.FormatInt(int64, 10)</code></p></li></ul><h2 id="uint"><a href="#uint" class="headerlink" title="uint"></a>uint</h2><ul><li>uint64 → string: <code>str := strconv.FormatUint(uint64, 10)</code></li></ul><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><ul><li><p>float → int: <code>i := int(float)</code></p></li><li><p>float → string: <code>str := strconv.FormatFloat(float64, &#39;E&#39;, -1, 64)</code></p></li></ul><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li><p>string → int: <code>i, err := strconv.Atoi(string)</code></p></li><li><p>string →float: <code>f, err := strconv.ParseFloat(string, 64)</code></p></li><li><p>string → bool: <code>b, err := strconv.ParseBool(&quot;true&quot;)</code></p></li><li><p>string → []byte: <code>b := []byte(string)</code></p></li></ul><h2 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h2><ul><li>[]byte → string: <code>str := string([]byte)</code></li></ul><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><ul><li>bool → string: <code>string := strconv.FormatBool(true)</code></li></ul><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ul><li><p>interface→int: <code>interface.(int64)</code></p></li><li><p>interface→string: <code>interface.(string)</code></p></li><li><p>interface→float: <code>interface.(float64)</code></p></li><li><p>interface→bool: <code>interface.(bool)</code></p></li></ul><h2 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> a := <span class="hljs-number">1</span><br> fmt.Println(<span class="hljs-string">&quot;a type by reflect: &quot;</span>, reflect.TypeOf(a))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法数构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Linux</title>
    <link href="/Note-Linux/"/>
    <url>/Note-Linux/</url>
    
    <content type="html"><![CDATA[<p>Linux，全称 GNU&#x2F;Linux，是一种免费使用和自由传播的类 UNIX 操作系统。作为研究生，我一开始学习 Linux 的源动力自然也是任职要求上的那一条：熟悉 Linux 环境。那么 Linux 系统到底好在哪里？</p><span id="more"></span><h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><p>很多公司包括我们自己的实验室服务器都是用的 Linux 系统，其优点概括而言就是开源、免费、生态好、安全性高。</p><p>首先 Linux 系统稳定性极高且不容易染毒（从来没有听说过要装什么杀毒软件或者需要清理内存，而且我们实验室的服务器永远都不会关机），它自带的命令功能十分强大（比如你可以用简单的几行命令就搞定软件的下载安装整个步骤），还拥有开放的源代码和高度的可定制性。其次，Linux 系统的远程管理非常方便。通过 ssh 或者 telnet 的连接，在很小的带宽环境下也能很轻松实现远程操作，就如服务器摆在眼前一样的感觉，这是 windows 系统无法比拟的。</p><h2 id="Linux-发行版本"><a href="#Linux-发行版本" class="headerlink" title="Linux 发行版本"></a>Linux 发行版本</h2><p><img src="/Note-Linux/1.png" alt="发行版说简单点就是将 Linux 内核与应用软件做一个打包。"></p><p>关于不同版本的安装网上教程很多，就不在此赘述。</p><h2 id="Linux-启动过程"><a href="#Linux-启动过程" class="headerlink" title="Linux 启动过程"></a>Linux 启动过程</h2><p>Linux 系统的启动过程并不是大家想象中的那么复杂，其过程可以分为 5 个阶段：</p><ul><li><p><strong>内核的引导</strong><br>  当计算机打开电源后，首先是 BIOS 开机自检，按照 BIOS 中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</p></li><li><p><strong>运行 init</strong><br>  init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 <code>/etc/inittab</code>。</p></li><li><p><strong>系统初始化</strong><br>  在 init 的配置文件中有这么一行：<code>si::sysinit:/etc/rc.d/rc.sysinit</code> 它调用执行了 <code>/etc/rc.d/rc.sysinit</code>，而 rc.sysinit 是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p></li><li><p><strong>建立终端</strong><br>  rc 执行完毕后，返回 init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init 接下来会打开终端，以便用户登录系统。</p></li><li><p><strong>用户登录系统</strong><br>  一般来说，用户的登录方式有三种：<br>  （1）命令行登录<br>  （2）ssh 登录<br>  （3）图形界面登录</p></li></ul><p><img src="/Note-Linux/2.png" alt="启动过程"></p><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><p><img src="/Note-Linux/3.jpg" alt="树状目录结构"></p><blockquote><p>&#x2F;</p></blockquote><blockquote><blockquote><p>&#x2F;bin：<br>bin 是 Binaries(二进制文件) 的缩写，这个目录存放着最经常使用的命令。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;boot：<br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;dev ：<br>dev 是 Device(设备) 的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;etc：<br>etc 是 Etcetera(等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;home：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lib：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;media：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;opt：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;proc：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sbin：<br>s 就是 Super User 的意思，是 Superuser Binaries(超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;selinux：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;srv：<br> 该目录存放一些服务启动之后需要提取的数据。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sys：<br>该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;tmp：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;usr：<br>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;bin：<br>系统用户使用的应用程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;src：<br>内核源代码默认的放置目录。</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>&#x2F;var：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p></blockquote></blockquote><h2 id="Linux-权限管理"><a href="#Linux-权限管理" class="headerlink" title="Linux 权限管理"></a>Linux 权限管理</h2><p>初学 Linux 我遇到过很多次没有权限而产生的报错，之前的解决办法一直是使用 <code>su</code> 命令给自己 root 权限，注意此时命令行的 <code>$</code> 会变成 <code>#</code>。Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown (change owner) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组</p><p><img src="/Note-Linux/4.jpg" alt="文件属性及权限"></p><p>第一位表示文件的属性：<code>d</code> 是目录，<code>-</code> 是文件，<code>l</code> 表示链接文档等等。</p><p>接下来的字符中，以三个为一组，且均为 <code>rwx</code> 的三个参数的组合。</p><ul><li><code>r</code> 代表可读(read)</li><li><code>w</code> 代表可写(write)</li><li><code>x</code> 代表可执行(execute)</li><li><code>-</code> 代表没有此权限</li></ul><p>而这三组也分别对应属主（该文件的所有者）权限、属组权限、其他用户权限。</p><p>我们可以使用 chmod 更改文件上述的 9 个属性，将三组权限看作三个二进制数，开启设 1 关闭设 0<br>如可以使用我们常见的 <code>chmod 777 文件名</code> 来开启所有权限。</p><h2 id="Linux-用户管理"><a href="#Linux-用户管理" class="headerlink" title="Linux 用户管理"></a>Linux 用户管理</h2><p>此节是关于 Linux 的用户以及用户组管理的，我目前用的不多，请参考<a href="https://www.runoob.com/linux/linux-user-manage.html">菜鸟教程</a>。</p><h2 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h2><p>同上，请参考<a href="https://www.runoob.com/linux/linux-filesystem.html">菜鸟教程</a></p><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><ul><li>ls （list files）：列出目录及文件名</li><li>cd （change directory）：切换目录</li><li>pwd （print work directory）：显示目前的目录</li><li>mkdir （make directory）：创建一个新的目录</li><li>rmdir （remove directory）：删除一个空的目录</li><li>cp （copy file）：复制文件或目录</li><li>rm （remove）：删除文件或目录</li><li>mv （move file）：移动文件与目录，或修改文件与目录的名称</li><li>cat （concatenate）：显示文件内容或是将多个文件合并成一个文件</li><li>yum（Yellow dog Updater, Modified）：一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器</li><li>apt（Advanced Packaging Tool）：一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器</li></ul><p>你可以使用 man [命令] 来查看各个命令的使用文档，如：<code>man cp</code>。此外文本编辑器 <a href="https://www.runoob.com/linux/linux-vim.html">vim</a> 也是很值得学习一下的。</p><p>我们通常会在命令后添加参数来执行更多功能，具体参数和使用方法请参考<a href="https://blog.csdn.net/weixin_66975803/article/details/123693997">这篇笔记</a>。</p><h2 id="Linux-更多命令"><a href="#Linux-更多命令" class="headerlink" title="Linux 更多命令"></a>Linux 更多命令</h2><ul><li><p><a href="https://blog.csdn.net/weixin_45004203/article/details/125885958">进程相关</a>：<code>top</code>, <code>ps</code>, <code>pidof</code>, <code>kill</code>, <code>killall</code>, <code>pkill</code></p></li><li><p>端口相关：<code>lsof -i:port</code>, <code>netstat -nltp | grep port</code></p></li></ul><h2 id="Bash-Shell"><a href="#Bash-Shell" class="headerlink" title="Bash Shell"></a>Bash Shell</h2><p>我之前一直知道 Shell 这个东西，但是对于它的认识很模糊，关于 Shell 有如下两条解释：</p><ul><li><p>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，不启动 Shell 的话，用户就没办法使用 Linux。</p></li><li><p>Shell 是一个命令语言解释器，在操作系统的最外层，是用户（用户程序）与操作系统（Linux）内核的接口程序，用户输入的每个命令都由 Shell 先翻译再传给 Linux 内核, 并将处理后的结果输出至屏幕。</p></li></ul><p>常用的 Shell 功能有两种形式外在形式：GUI 和 cmdline。</p><p>Shell 的使用方法有两种：1. 直接输入命令； 2. 使用 .sh 脚本。 对于脚本语法感兴趣请学习 <a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a>。</p><p>Bash（GUN Bourne-Again Shell）是许多 Linux 发行版本默认的 Shell。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我在这篇文章里面列出了我自己认为 Linux 中比较重要的内容，学习它的办法唯有多用，逐渐感受它的强大与可靠，你一定会理解为什么它会受到那么多公司的青睐。 Linux 上手可能会比 Windows 要困难一点，尤其是在没有装图形化界面的服务器上，各位同学不必害怕，熟能生巧，习惯以后真的非常好用。相信不久后你也可以在简历里面加上一句 “熟悉 Linux 开发环境” 了。</p><p>附两个我常用的在本地与服务器传文件的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件从远程系统上用户的主目录复制到本地当前目录</span><br>scp username@ip_address:/home/username/filename .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将本地文件复制到远程系统上用户名的主目录</span><br>scp filename username@ip_address:/home/username<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以复制目录</span><br>scp -r source_dir username@ip_address:/home/username/target_dir<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Markdown</title>
    <link href="/Note-Markdown/"/>
    <url>/Note-Markdown/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，在 2004 年由 John Gruber 创建。它允许人们使用易读易写的纯文本格式编写文档。本文介绍使用 Markdown 编写博客时常用的标记符号供后续使用时参考。</p><span id="more"></span><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>使用 # 号标记，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><h2 id="Markdown-格式"><a href="#Markdown-格式" class="headerlink" title="Markdown 格式"></a>Markdown 格式</h2><p>可以实现的格式： <em>斜体文本</em> ， <strong>粗体文本</strong> ， <em><strong>粗斜体文本</strong></em> ， <del>删除线</del> ， <u>带下划线文本</u></p><p>分割线</p><hr><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套<br>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p><code>Println()</code> 函数输出 “Hello, world!” :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>欢迎访问我的 <a href="https://github.com/qanlyma">Github 仓库</a>: <a href="https://github.com/qanlyma">https://github.com/qanlyma</a></p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p><img src="/Note-Markdown/love.jpg" alt="我最喜欢的彩虹六号"></p><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><table><thead><tr><th align="left">左  对  齐</th><th align="right">右  对  齐</th><th align="center">居  中  对  齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="Markdown-高级"><a href="#Markdown-高级" class="headerlink" title="Markdown 高级"></a>Markdown 高级</h2><h3 id="支持部分-HTML-元素"><a href="#支持部分-HTML-元素" class="headerlink" title="支持部分 HTML 元素"></a>支持部分 HTML 元素</h3><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><strong>文本加粗</strong><br>** 正常显示星号 **</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Hexo</title>
    <link href="/Note-Hexo/"/>
    <url>/Note-Hexo/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建新网站"><a href="#创建新网站" class="headerlink" title="创建新网站"></a>创建新网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><h3 id="清除缓存文件"><a href="#清除缓存文件" class="headerlink" title="清除缓存文件"></a>清除缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h3 id="在本地启动-hexo"><a href="#在本地启动-hexo" class="headerlink" title="在本地启动 hexo"></a>在本地启动 hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="更换电脑"><a href="#更换电脑" class="headerlink" title="更换电脑"></a>更换电脑</h3><p>hexo 目录下的文件和 github 上的文件是不同的，public 文件夹的文件通过 <code>hexo d</code> 上传到 github，其他的文件则留在本地目录下。</p><ol><li>将本地文件传入 github 新建分支 <code>hexo</code>，并设为默认。</li><li>在新电脑上克隆新分支到本地，切换到 <code>username.github.io</code> 目录，执行 <code>npm install</code> 安装依赖（node_modules文件）。</li><li>安装 hexo： <code>npm install -g hexo-cli</code>，安装必要的插件，例如需要部署到 gitPage： <code>npm install hexo-deployer-git --save</code>。</li><li>更改后依次执行 <code>git add .</code>、<code>git commit -m &quot;...&quot;</code>、<code>git push</code>。</li><li>更新前使用 <code>git pull</code>。</li></ol><p><strong>.md 文件建议使用 UTF-8，其他格式可能会乱码。</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
