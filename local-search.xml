<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「研」 区块链扩容调研</title>
    <link href="/Blockchain-scalability/"/>
    <url>/Blockchain-scalability/</url>
    
    <content type="html"><![CDATA[<p>一篇关于区块链 Layer 1 和 Layer 2 的扩容调研报告。</p><span id="more"></span><h2 id="一、区块链扩容"><a href="#一、区块链扩容" class="headerlink" title="一、区块链扩容"></a>一、区块链扩容</h2><h3 id="1-1-为什么需要扩容"><a href="#1-1-为什么需要扩容" class="headerlink" title="1.1 为什么需要扩容"></a>1.1 为什么需要扩容</h3><p>在比特币诞生之初，创始人中本聪并没有特意限制区块的大小，区块最大可以达到 32MB。当时，平均每个区块大小为 1-2KB，有人认为区块链上限过高容易造成计算资源的浪费，还容易发生 DDOS 攻击（分布式拒绝服务攻击）。因此，为了保证比特币系统的安全和稳定，中本聪决定临时将区块大小限制在 1MB。</p><p>随着越来越多的人关注和使用比特币，链上最高时有上万笔交易积压，很多用户为了尽快让自己的交易被打包，不得不增加手续费，有时候比特币转账交易费高达几十美元。网络拥堵时，一个比特币交易甚至需要花费好几天才能被打包，同理也使得以太坊上的gas费用居高不下。比特币和以太坊作为区块链 1.0 和 2.0 的代表，比特币每秒大约只能处理 7 个交易，性能只有 7TPS；以太坊每秒只能处理 15 个交易，性能只有 15TPS。而作为中心化的代表，淘宝在 17 年双十一超过了 200,000TPS，可见区块链的 TPS 跟中心化应用还有很大的差距。</p><p>与很多分布式系统一样，区块链技术中也有一个“不可能三角形”，比特币和以太坊在最早诞生时最关注的是去中心化和安全，牺牲了可扩展性。后来，市场上不断有一些新的区块链项目牺牲掉去中心化或者安全性来为可扩展性保驾护航，试图部署出一个吞吐量较高的区块链网络。迄今为止，还没有人找到去中心化、可扩展性和安全性三全其美的策略，打造出一个充分运行、基于加密货币的大规模区块链网络。但是，如果想把区块链的应用拓展到虚拟货币投资之外，必须得有支持其吞吐量扩容的解决方案。</p><h3 id="1-2-如何扩容"><a href="#1-2-如何扩容" class="headerlink" title="1.2 如何扩容"></a>1.2 如何扩容</h3><p>所谓的扩容方案是指“为了改善区块链交易速度使其达到规模化所提出的解决方案”，各层所提出的扩容方案，其最终目的都是为了解决区块链交易速度的问题。</p><p>目前主要可以分为链上（Layer 1）和链下（Layer 2）的扩容方案。链上扩容是指为了提高区块链的吞吐量而对其进行的任何直接修改，比如比特币修改共识机制来改变区块结构或直接增加区块大小，而以太坊的策略则是改变网络结构进行分片，不同的分片并行处理不同的交易，增加整体吞吐量。而链下扩容是指在不改变公链本身规则的前提下，将数据计算过程等信息移到链下进行，而主链仅记录结果，比如比特币的闪电网络，以太坊的侧链，状态通道和 Rollup 等。下文将对具体方案进行详细介绍。</p><h2 id="二、Layer-1-扩容"><a href="#二、Layer-1-扩容" class="headerlink" title="二、Layer 1 扩容"></a>二、Layer 1 扩容</h2><h3 id="2-1-扩块和隔离见证"><a href="#2-1-扩块和隔离见证" class="headerlink" title="2.1 扩块和隔离见证"></a>2.1 扩块和隔离见证</h3><p>想让一个区块打包更多的交易，最直观的有两种解决办法：一是增加区块大小；二是缩小交易数据的尺寸。这就分别产生了扩块和隔离见证两个扩容方案，当然这两个方案也可以一起使用，可是不论选择何种方案都避免不了区块链的分叉。</p><p>比特币社区中提及比较多的是 2MB 区块，一部分人希望通过硬分叉直接把区块大小限制从 1M 改到 2M，提升单个区块内的交易数，每秒打包的交易就会增加，从而提升 TPS。可是扩块有一些弊端：</p><ul><li>(1) 大区块传播速度变慢，验证速度变慢，导致频繁的重组，双花攻击概率提高；</li><li>(2) 大区块导致储存量大幅度增加，成本提高，节点可能减少，趋向中心化从而影响安全。</li></ul><p>比特币社区有一部分人不接受硬分叉，坚持使用隔离见证（Segwit）方案去优化主链结构，并且结合闪电网络等二层网络结构来改善支付体验。隔离见证的原理是压缩每笔交易的大小，从而增加每个区块可以记录的交易数量。此方案将比特币交易数据分为交易信息和签名信息，对于普通用户来说他们只关心每个账户有多少资产，不需要验证信息，隔离见证就是把区块内的数字签名信息拿出去，让每个区块可以承载更多交易，从而达到扩容的目的。可是这样做的扩容能力有限，依然难以满足大量转账的需求。</p><p>两种方案的支持者方争论不休，随着加密货币市场迎来了前所未有的关注度，比特币价格连创新高，这也让比特币的交易更加拥堵，最终在 2017 年 8 月 1 日导致了比特币历史上第一次重大硬分叉的出现，比特币区块大小由 1M 扩大到 8M，同时也诞生出新币种 BCH（比特币现金）。</p><h3 id="2-2-分片"><a href="#2-2-分片" class="headerlink" title="2.2 分片"></a>2.2 分片</h3><p>分片技术（sharding）来自中心化数据库技术，将大型数据库数据进行切分，并分布在特点的服务器中，以提高数据库性能。如果将分片技术运用到区块链中，就相当于将区块链网络里的所有待处理任务进行分解，全网的节点也进行分组，每一组同时处理一个分解后的任务，这样就从原先单一节点处理全网的所有任务变成了多组节点同时处理，如此以来，自然就能大大提升这条链的处理效率。但是分片技术的问题也是显而易见的：分片多用于以太坊网络中，那么跨片区智能合约交易如何处理？片区如何划分？各片区如何同步？</p><p>分片技术根据不同的分片机制可以划分为三种：</p><ul><li>网络分片（network sharding）</li><li>交易分片（transaction sharding）</li><li>状态分片（state sharding）</li></ul><h4 id="2-2-1-网络分片"><a href="#2-2-1-网络分片" class="headerlink" title="2.2.1 网络分片"></a>2.2.1 网络分片</h4><p>网络分片是最基础的一种分片方式，就是将整个区块链网络划分成多个子网络（也就是一个分片），网络中的所有分片并行处理网络中不同的交易。</p><p>但是这个方案会使网络的安全性和去中心化性会下降，比如原来 A 想要在某交易中作恶，因为共识机制的原因，A 需要控制全网的大部分节点或算力才行，但现在因为分片把节点分散到一个个小的区域中，A 只用控制包含这个交易的小区域的大部分节点算力就行。</p><p>幸好分片技术另外一个非常重要的机制就是随机分配，在区块链领域建立随机性的方式主要是利用可验证随机函数（VRF, Verifiable Random Function）。利用随机性，网络可以随机抽取节点形成分片。这样一种随机抽样的方式可以防止恶意节点过度填充单个分片，这样想要作恶的人，就很难知道一个小区域中的节点都有谁，作恶成本会大幅提高，从而分片技术能在保证安全与去中心化的同时，解决效率与可扩展性问题。</p><h4 id="2-2-2-交易分片"><a href="#2-2-2-交易分片" class="headerlink" title="2.2.2 交易分片"></a>2.2.2 交易分片</h4><p>网络分片是其他所有分片的基础，交易分片的前提是先进行网路分片。交易分片主要涉及的问题是哪些交易应该按照特定的属性被分配到哪些分片当中。</p><ul><li>基于 UTXO 的账本系统。在基于 UTXO 的账本系统中，一笔交易可能由多个输入和多个输出构成，我们没有办法按照地址进行交易分片来有效地避免双花问题。比较直观的交易分片方式是按照交易的 hash 值最后几位进行分片。但是这样也有可能导致双花交易，所以不同分片之间不得不进行通信。</li><li>基于账户系统。在基于账户系统中，一笔交易只有一个输入，而输入的地址将被记录在账户系统中。该账户系统在交易分片的每个分片中是全局可见的，因此我们只需要将交易按照发送者的地址进行分片，即可保证同一个账户发出的多笔交易将被在同一个分片当中被处理，这样该分片可以有效的检测双花交易而不需要复杂的跨分片的通信。</li></ul><h4 id="2-2-3-状态分片"><a href="#2-2-3-状态分片" class="headerlink" title="2.2.3 状态分片"></a>2.2.3 状态分片</h4><p>状态分片的关键是将整个存储区分开，让不同的分片存储不同的部分，每个节点只负责托管自己的分片数据，而不是存储完整的区块链状态。状态分片可以减少状态的冗余存储，使得整个区块链网络具有存储的可扩展性。</p><p>在账户型系统中，状态分片是按照账户的地址进行分片的，并且一个特定的分片只会保留一部分状态，而不像是交易分片那样每个节点都保存整个网络中的所有状态。这导致可能需要进行频繁的跨分片通信和状态交换。跨分片通信可能又会降低状态分片的性能。</p><p>在状态分片的情况下，重新分配节点是非常困难的。由于每个分片只保留了网络状态的一部分，所以在一次重新调整网络的过程中，必须要防止调整过大而导致在同步完成前可能会出现的整个系统失效的问题。为了防止系统的中断，必须对网络进行逐步调整，以确保每个分片在所有节点被清空前仍有足够多的旧节点。而新节点在加入分片之前，需要等待同步完该分片中的状态信息之后才可以正式加入分片并提供算力。</p><h3 id="2-3-Casper"><a href="#2-3-Casper" class="headerlink" title="2.3 Casper"></a>2.3 Casper</h3><p>比特币和以太坊当前都采用工作量证明（PoW）共识机制，这是个低效的系统，因为它消耗会大量的电力和能量。而且这个机制可以通过购买更快更强的 ASIC 设备比其他人拥有更高的概率挖到区块，这导致比特币并没有像它希望的那样分散化。如果采取其他共识机制（PoS），改变区块形成的规则，提高系统效率即可增加每秒处理交易。Csaper 就是以太坊选择实行的 PoS 协议，值得一提的是，Casper 并非专为扩容而设计，但它会对以太坊网络容量产生积极影响。</p><p>在介绍 Casper 之前我们首先要了解无利害关系问题（Nothing at stake），这一问题是由于 PoS 机制不会消耗节点的算力，所以在共识系统出现分叉情况时，出块节点可以在“不受任何损失”的前提下，同时为多条链出块，从而有可能获得“所有收益”。Casper 是一种基于保证金的经济激励共识协议。协议中的节点，作为“锁定保证金的验证人”，必须先缴纳保证金才可以参与出块和共识形成。Casper 共识协议通过对这些保证金的直接控制来约束验证人的行为。具体来说就是，如果一个验证人作出了任何 Casper 认为“无效”的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消从而解决了无利害关系问题。</p><p>从扩容的角度来说，修改后，可以从根本上改变区块形成的规则，往有利于交易量增加的方向修改。但是无论如何改变，共识算法仍然是分布式算法，需要多个节点达成一致，处理的上限是一台机器处理能力的上限。并且共识机制是加密货币的核心，涉及加密货币的整体逻辑，需要全盘考虑对旧区块的承接、安全性、后续发展等问题，还需要做大量的技术尝试。</p><h2 id="三、Layer-2-扩容"><a href="#三、Layer-2-扩容" class="headerlink" title="三、Layer 2 扩容"></a>三、Layer 2 扩容</h2><p>第二层扩容也称链下扩容，是不改变公链基础协议的一种应用层上的扩展方案，即不改动区块链本身的规则（区块大小，共识机制等）。由 Layer 2 协议，区块链事务的“状态生成”可以独立于 Layer 1 之外进行。换句话说 Layer 2 扩容方案是尽可能在不牺牲区块链网络安全性的情况下实现高吞吐量的状态生成。</p><h3 id="3-1-侧链协议"><a href="#3-1-侧链协议" class="headerlink" title="3.1 侧链协议"></a>3.1 侧链协议</h3><p>侧链是与公链并排运行并与之通信的独立区块链，它使用另一个代币与公链代币相互锚定，从而创建了双向桥。侧链是完全独立的，具有自己的共识机制和安全性保证。通过这种解决方案，可以实现数字资产从第一个区块链到第二个区块链的转移，又可以在稍后的时间点从第二个区块链安全返回到第一个区块链。其中第一个区块链通常被称为主区块链或者主链，每二个区块链则被称为侧链。</p><p>由于没有第一层设计的负担，侧链可以支持超出其基础层能力的某些特性，包括但不限于可扩展性和互操作性，同时不依赖于第一层的存储，可以建设多条侧链提供非常高的 TPS。而且得益于其独立性，如果侧链上出现了代码漏洞和大量资金被盗等问题，主链的安全性和稳定性都不会受到影响。缺点是它不是一个无信任的环境，用户需要将资金托管转移到侧链，从侧链取回资产时的安全性问题需要被考虑，侧链目前不那么成熟，去中心化也更差。</p><h3 id="3-2-状态通道"><a href="#3-2-状态通道" class="headerlink" title="3.2 状态通道"></a>3.2 状态通道</h3><p>状态通道是固定一组参与者（通常是两名参与者）之间的协议，用以实现安全的链下交易，其中支付通道专门用来支付。支付通道协议具体情况是两名参与者各自通过链上交易在链上锁定保证金，一旦锁定完成，参与者双方即可互相发送形式为轮次、金额、签名的状态更新来实现转账，无需与主链进行交互，只要双方的余额都还为正值即可。一旦参与者中有一方想要停止使用支付通道，可以执行退出操作：将最后的状态更新提交至主链，结算下来的余额会退给发起支付通道的两方。主链可以通过核实签名和最后结余来验证状态更新的有效性，从而防止参与者使用无效状态来退出支付通道。</p><p>状态通道带来的优点是交互延迟在毫秒级别，是唯一能够逼近当今互联网用户体验的区块链扩容技术；交易手续费极低，从根本上比所有其他 Layer 2 技术的交易手续费低；水平扩展性强，加节点就能增加总系统容量，TPS 无上限，且互相之间不隔离，不需要有跨分片或者跨链之类的复杂操作。但它的退出模式存在一个问题，即主链无法验证支付通道是否提交了全部交易，也就是说，在提交了状态更新之后是否不再出现新的状态更新。而且它的使用场景较为局限：长期合作关系的双方的支付，偶发性交易难以适用，并且通道不能用于将资金在链外发送给尚未参与的人。此外，状态通道只能在两个参与者之间开设。闪电网络就是比特币使用状态通道的例子。</p><p>状态通道相较于侧链协议有更强的隐私性，并且有即时的最终确定性。但是状态通道需要所有参与者 100% 的在线，在侧链中，你就不需要一直在线。</p><h3 id="3-3-Plasma"><a href="#3-3-Plasma" class="headerlink" title="3.3 Plasma"></a>3.3 Plasma</h3><p>Plasma 由 Vitalik 和 Joseph Poon 在 2017 年共同提出，Plasma 是一种链下交易的技术，从一个新的方向实现了状态通道。它允许创建附加在以太坊主链上的子链，这些子链反过来可以产生他们自己的子链。其结果就是，我们可以在子链级别执行许多复杂的操作，运行拥有数千名用户的整个应用程序，并且只需与以太坊主链进行尽可能少的交互。子链可以更快地操作，且交易费用更低，因为它的操作不需要在整个以太坊区块链存留副本。</p><p>区别于状态通道，Plasma 中能够运行智能合约，如果说状态通道是对交易吞吐量的扩容，那么它是对计算能力的扩容。Plasma 是将计算和数据存储都迁移到 Layer 2 进行，由 Layer 2 的执行者周期性地向主链递交 Merkle 根形式的状态承诺。如果执行者递交无效的状态，用户可以向主链上的智能合约提供错误性证明（fraud proof），一旦确认执行者出现欺诈行为，智能合约会没收他的保证金。</p><p>虽然说我们可以通过错误性证明，使得提供无效承诺的执行者在主链上遭到惩罚，但 Plasma 的数据并没有提交到链上，如果 Plasma 的执行者拒绝在主链上公开数据，那么用户则无法提供错误性证明，所以 Plasma 面临的最大问题是交易数据可用性。针对这个问题，Plasma 衍生出一些相应的方案，如延长资产从 Layer 2 退出的时间：当出现作恶行为，就能允许资产从 Plasma 链转移回主链。所以在 Plasma 上退出一笔资产的周期会长达一周左右，如果在争议期间没有人提交欺诈证明，那么资产才可以安全退出到主链。相比较而言，普通的侧链就没有这个安全特性。</p><h3 id="3-4-Rollup"><a href="#3-4-Rollup" class="headerlink" title="3.4 Rollup"></a>3.4 Rollup</h3><p>之前介绍的几种链下扩容方案虽然诞生时间很早，但是发展的却比较缓慢，其背后的原因归根结底是数据的可用性（Data Availability）问题。无论是状态通道还是 Plasma 侧链，完整的交易记录和见证数据都只保存在链下，出现争端时如果参与者没有及时提供正确的交易和见证数据，交易的安全性就无法保证。这时一种名为 Rollup 的方案被提了出来。</p><p>Rollup 可以被认为是一种压缩技术，多笔交易可以压缩在一起（几千笔交易可以被打包到一个 Rollup 区块中），既能减少交易数据规模，又能降低交易验证负担，因此使得以太坊区块链能处理更多交易。它将所有 Layer 2 上的交易数据快照发送到主链上某个智能合约内，用主链上的单个合约来保管所有的资金，通过在主链上为每一笔交易公开一些数据，让任何人都能通过观察区块链上的 calldata（交易输入数据）来获得Layer2的所有数据。Rollup 区块的状态是由用户以及链下运营者来维护的，因此不会占用主链的存储空间。所有交易的收据都存储在以太坊区块链上，这就提升了 Layer 2 交易的安全性。具体的实现方案目前主要分为 ZK Rollup 和 Optimistic Rollup 两种。</p><h4 id="3-4-1-ZK-Rollup"><a href="#3-4-1-ZK-Rollup" class="headerlink" title="3.4.1 ZK Rollup"></a>3.4.1 ZK Rollup</h4><p>ZK Rollup 是靠着在主链完成零知识证明，链上无需包含签名数据，因为零知识证明就足以证明交易的有效与否，交易有效性就立刻确认，也即数据可用性放在链上，所以 ZK Rollup 对数据存储方面带来了一定程度上的扩展性提升。它的缺点是验证链路的构造没有一个通用的解决方案，所以目前没有很好的办法做到很广义的虚拟机逻辑，简单来说，ZK Rollup 必须对每一个用例定制，程序正确性的验证相对复杂，二层打包节点负担重，成本高，计算零知识证明所需时间长，用户延迟的体验角度仍然比较差，目前只适合简单的转账。</p><h4 id="3-4-2-Optimistic-Rollup"><a href="#3-4-2-Optimistic-Rollup" class="headerlink" title="3.4.2 Optimistic Rollup"></a>3.4.2 Optimistic Rollup</h4><p>ZK Rollup 包含一个 SNARK 零知识证明，合约用它来验证在老的用户状态上施加这批交易，但是生成 SNARK 的成本非常高，所以 Optimistic Rollup 采用了欺诈证明来验证交易有效性。Optimistic Rollup 的理念是由 John Adler 首先构想出来的，它保留了 calldata，主链可以获得所有 Layer 2 的数据，但那些刷新 Layer 2 状态的交易不会在链上被验证，只让主链存储一系列的历史状态根，添加了一个新的状态的一段时间后才将新状态最终敲定，也就是数据可用性放在链下。采用欺诈证明，对提交无效状态的执行者进行惩罚。其链下 OVM 虚拟机可以支持任意智能合约逻辑的实现，与以太坊 EVM 虚拟机搭配使用，开发者就可以用 Solidity 来写代码，实现 DApp 和智能合约之间的无缝互操作性。它的缺点是安全问题，只有使用一到两周的欺诈证明挑战期才足够安全。在挑战期过去以前，没有交易能被认为是确定的。</p><h4 id="3-4-3-比较"><a href="#3-4-3-比较" class="headerlink" title="3.4.3 比较"></a>3.4.3 比较</h4><ul><li><ol><li>Optimistic rollup 和 ZK rollup 的主要区别在于采用了不同的数据证明方式。Optimistic rollup 使用欺诈证明：子链上的交易结果并不直接生成相关证明接入主链，子链仅向主链报告结果。如果有人发现结果错误，他们可以向链上发布一个证明，证明处理计算错误。合约将验证证明，并对结果进行更正。ZK rollup 使用零知识证明: 子链将自身交易采用 ZK-SNARK 技术生成加密证明，证明状态根是执行子链上交易的正确结果。无论计算量有多大，证明都可以在链上快速验证。</li></ol></li><li><ol start="2"><li>Optimistic Rollup 基于加密经济学有效性博弈，只有过了挑战期才能确认交易生效。ZK Rollup 的延迟相对较小，如果一个打包区块中有 1000 笔交易，在普通的服务器上大概需要 20 分钟就可以构造出一个证明。</li></ol></li><li><ol start="3"><li>通用性方面，Optimistic Rollup 明显好于 ZK Rollup，当然它的设计目标就是支持任意智能合约。而 ZK Rollup 目前仅适用于支付之类的特定交易，对于通用智能合约，由于创建零知识证明的成本非常高，部署起来困难较大。</li></ol></li></ul><p>短期看来 Optimistic Rollup 由于较好的通用性会受到开发者的青睐；但从长期来看，随着零知识证明虚拟机的演进，ZK Rollup 会在通用性上不断提高。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>状态通道有一些独特的性质，让它在扩容领域有着独特的地位，它的诸多属性在很多应用中都非常重要。比如游戏、IoT 设备网络、去中心的互联网服务提供商等。Plasma 和状态通道相比，Plasma 中能够运行智能合约，而状态通道则不被允许。分片系统要比 Plasma 链更不易于遭受拒绝服务攻击，分片链提供的防御也更易于普及。但 Plasma 链可以被迭代，新的设计可以更快地被实现，因为每条 Plasma 链都可以在无需与该生态系统中的其他链进行协调的情况下单独地进行部署，而且由单个运营商运行的 Plasma 链还可以提供比分片系统更多的隐私保护。而在分片系统中，所有的数据都是公开的。</p><p>相比于 Plasma 和ZK Rollup，Optimistic Rollup 做了一些权衡，所以带来的扩展性提升幅度最小，但 Optimistic Rollup 不依赖于什么过于前沿的技术或悬而未决的问题，所以实际推广中 Optimistic Rollup 更好落地。而 ZK Rollup 可以解决 Optimistic Rollup 上的几个根本问题，消除了令人厌恶的尾部风险（通过复杂但可行的攻击方法从 Optimistic Rollup 中盗取资金），将提取资金的时间从几周缩减到几分钟，支持快速的交易确认和退出，并且默认保护隐私。对于需要提高流动性的项目而言，资本运作效率 ZK Rollup 高于 Optimistic Rollup。</p><p>不同的扩容技术有它不同的优缺点，导致适应不同的应用场景，未来不同的扩容技术之间也会是相互合作关系，某一场景下同时使用多种扩容技术。以太坊基金会在今年1月25日宣布淘汰“以太坊 2.0”的说法，改称为“共识层”，设计人员在其中加入当下的一些先进技术，如分片技术、Casper 协议等等。相信伴随着以太坊的全面升级，其TPS必将有很大改善，但其中技术上的一些问题还有待大家共同攻坚克难。</p>]]></content>
    
    
    <categories>
      
      <category>调研报告</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Go」 各种类型相互转换</title>
    <link href="/Go-typeTransfer/"/>
    <url>/Go-typeTransfer/</url>
    
    <content type="html"><![CDATA[<p>在做 leetcode 和自己写 go 程序的时候，总是会遇到一些类型转换的问题，在这里总结一下。</p><span id="more"></span><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul><li><p>int → int64: <code>i := int64(int)</code></p></li><li><p>int → uint64: <code>ui := uint64(int)</code></p></li><li><p>int → float: <code>f := float64(int)</code></p></li><li><p>int → string: <code>str := strconv.Itoa(int)</code></p></li><li><p>int64 → string: <code>str := strconv.FormatInt(int64, 10)</code></p></li></ul><h2 id="uint"><a href="#uint" class="headerlink" title="uint"></a>uint</h2><ul><li>uint64 → string: <code>str := strconv.FormatUint(uint64, 10)</code></li></ul><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><ul><li><p>float → int: <code>i := int(float)</code></p></li><li><p>float → string: <code>str := strconv.FormatFloat(float64, &#39;E&#39;, -1, 64)</code></p></li></ul><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li><p>string → int: <code>i, err := strconv.Atoi(string)</code></p></li><li><p>string →float: <code>f, err := strconv.ParseFloat(string, 64)</code></p></li><li><p>string → bool: <code>b, err := strconv.ParseBool(&quot;true&quot;)</code></p></li><li><p>string → []byte: <code>b := []byte(string)</code></p></li></ul><h2 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h2><p>[]byte → string: <code>str := string([]byte)</code></p><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><ul><li>bool → string: <code>string := strconv.FormatBool(true)</code></li></ul><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ul><li><p>interface→int: <code>interface.(int64)</code></p></li><li><p>interface→string: <code>interface.(string)</code></p></li><li><p>interface→float: <code>interface.(float64)</code></p></li><li><p>interface→bool: <code>interface.(bool)</code></p></li></ul><h2 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-built_in">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br> <br> <br>func <span class="hljs-selector-tag">main</span>() &#123;<br> <span class="hljs-selector-tag">a</span> := <span class="hljs-number">1</span><br> fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a type by reflect: &quot;</span>, reflect<span class="hljs-selector-class">.TypeOf</span>(a))<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Linux 使用教程</title>
    <link href="/Linux-tutorial/"/>
    <url>/Linux-tutorial/</url>
    
    <content type="html"><![CDATA[<p>Linux，全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统。作为研究生，我一开始学习 Linux 的源动力自然也是任职要求上的那一条：熟悉 Linux 环境。那么 Linux 系统到底好在哪里？</p><span id="more"></span><h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><p>很多公司包括我们自己的实验室服务器都是用的 Linux 系统，其优点概括而言就是开源、免费、生态好、安全性高。</p><p>首先 Linux 系统稳定性极高且不容易染毒（从来没有听说过要装什么杀毒软件或者需要清理内存，而且我们实验室的服务器永远都不会关机），它自带的命令功能十分强大（比如你可以用简单的几行命令就搞定软件的下载安装整个步骤），还拥有开放的源代码和高度的可定制性。其次，Linux 系统的远程管理非常方便。通过 ssh 或者 telnet 的连接，在很小的带宽环境下也能很轻松实现远程操作。就如服务器摆在眼前一样的感觉。这是 windows 系统无法比拟的。</p><h2 id="Linux-发行版本"><a href="#Linux-发行版本" class="headerlink" title="Linux 发行版本"></a>Linux 发行版本</h2><p><img src="/Linux-tutorial/1.png" alt="发行版说简单点就是将 Linux 内核与应用软件做一个打包。"></p><p>关于不同版本的安装网上教程很多，就不在此赘述。</p><h2 id="Linux-启动过程"><a href="#Linux-启动过程" class="headerlink" title="Linux 启动过程"></a>Linux 启动过程</h2><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p><ul><li><p><strong>内核的引导</strong><br>  当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</p></li><li><p><strong>运行 init</strong><br>  init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。</p></li><li><p><strong>系统初始化</strong><br>  在init的配置文件中有这么一行： <code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了 &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而 rc.sysinit 是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p></li><li><p><strong>建立终端</strong><br>  rc 执行完毕后，返回 init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。 init 接下来会打开终端，以便用户登录系统。</p></li><li><p><strong>用户登录系统</strong><br>  一般来说，用户的登录方式有三种：<br>  （1）命令行登录<br>  （2）ssh登录<br>  （3）图形界面登录</p></li></ul><p><img src="/Linux-tutorial/2.png" alt="启动过程"></p><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><p><img src="/Linux-tutorial/3.jpg" alt="树状目录结构"></p><blockquote><p>&#x2F;</p></blockquote><blockquote><blockquote><p>&#x2F;bin：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;boot：<br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;dev ：<br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;etc：<br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;home：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lib：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;media：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;opt：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;proc：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sbin：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;selinux：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;srv：<br> 该目录存放一些服务启动之后需要提取的数据。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sys：<br>该文件系统是内核设备树的一个直观反映。<br>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;tmp：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;usr：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;bin：<br>系统用户使用的应用程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;src：<br>内核源代码默认的放置目录。</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>&#x2F;var：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p></blockquote></blockquote><h2 id="Linux-权限管理"><a href="#Linux-权限管理" class="headerlink" title="Linux 权限管理"></a>Linux 权限管理</h2><p>初学 Linux 我遇到过很多次没有权限而产生的报错，之前的解决办法一直是使用 <code>su</code> 命令给自己 root 权限，注意此时命令行的 <code>$</code> 会变成 <code>#</code> 。Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown (change owner) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组</p><p><img src="/Linux-tutorial/4.jpg" alt="文件属性及权限"></p><p>第一位表示文件的属性： <code>d</code> 是目录， <code>-</code> 是文件， <code>l</code> 表示链接文档等等。</p><p>接下来的字符中，以三个为一组，且均为 <code>rwx</code> 的三个参数的组合。</p><ul><li><code>r</code> 代表可读(read)</li><li><code>w</code> 代表可写(write)</li><li><code>x</code> 代表可执行(execute)</li><li><code>-</code> 代表没有此权限</li></ul><p>而这三组也分别对应属主（该文件的所有者）权限、属组权限、其他用户权限。</p><p>我们可以使用 chmod 更改文件上述的 9 个属性，将三组权限看作三个二进制数，开启设 1 关闭设 0 。<br>则可以使用我们常见的 <code>chmod 777 文件名</code> 来开启所有权限。</p><h2 id="Linux-用户管理"><a href="#Linux-用户管理" class="headerlink" title="Linux 用户管理"></a>Linux 用户管理</h2><p>此节是关于 Linux 的用户以及用户组管理的，我目前用的不多，请参考<a href="https://www.runoob.com/linux/linux-user-manage.html">菜鸟教程</a>。</p><h2 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h2><p>同上，请参考<a href="https://www.runoob.com/linux/linux-filesystem.html">菜鸟教程</a></p><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><ul><li>ls （list files）: 列出目录及文件名</li><li>cd （change directory）：切换目录</li><li>pwd （print work directory）：显示目前的目录</li><li>mkdir （make directory）：创建一个新的目录</li><li>rmdir （remove directory）：删除一个空的目录</li><li>cp （copy file）: 复制文件或目录</li><li>rm （remove）: 删除文件或目录</li><li>mv （move file）: 移动文件与目录，或修改文件与目录的名称</li><li>cat （concatenate）：显示文件内容或是将多个文件合并成一个文件</li><li>yum（Yellow dog Updater, Modified）：一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</li><li>apt（Advanced Packaging Tool）：一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</li></ul><p>你可以使用 man [命令] 来查看各个命令的使用文档，如： <code>man cp</code> 。此外文本编辑器 <a href="https://www.runoob.com/linux/linux-vim.html">vim</a> 也是很值得学习一下的。</p><p>我们通常会在命令后添加参数来执行更多功能，具体参数和使用方法请参考<a href="https://blog.csdn.net/weixin_66975803/article/details/123693997">这篇笔记</a>。</p><h2 id="Linux-更多命令"><a href="#Linux-更多命令" class="headerlink" title="Linux 更多命令"></a>Linux 更多命令</h2><ul><li><p><a href="https://blog.csdn.net/weixin_45004203/article/details/125885958">进程相关</a>：<code>top</code>, <code>ps</code>, <code>pidof</code>, <code>kill</code>, <code>killall</code>, <code>pkill</code></p></li><li><p>端口相关：<code>lsof -i:port</code>, <code>netstat -nltp | grep port</code></p></li></ul><h2 id="Bash-Shell"><a href="#Bash-Shell" class="headerlink" title="Bash Shell"></a>Bash Shell</h2><p>我之前一直知道 Shell 这个东西，但是对于它的认识很模糊，关于 Shell 有如下两条解释：</p><ul><li><p>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，不启动 Shell 的话，用户就没办法使用 Linux 。</p></li><li><p>Shell是一个命令语言解释器, 在操作系统的最外层, 是用户（用户程序）与操作系统（Linux）内核的接口程序，用户输入的每个命令都由 Shell 先翻译再传给 Linux 内核, 并将处理后的结果输出至屏幕。</p></li></ul><p>常用的 Shell 功能有两种形式外在形式： GUI 和 cmdline 。</p><p>Shell 的使用方法有两种：1. 直接输入命令； 2. 使用 .sh 脚本。 对于脚本语法感兴趣的同学请学习 <a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a>。</p><p>Bash (GUN Bourne-Again Shell）是许多 Linux 发行版本默认的 Shell 。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我在这篇文章里面列出了我自己认为 Linux 中比较重要的内容，学习它的办法唯有多用，逐渐感受它的强大与可靠，你一定会理解为什么它会受到那么多公司的青睐。 Linux 上手可能会比 Windows 要困难一点，尤其是在没有装图形化界面的服务器上，各位同学不必害怕，熟能生巧，习惯以后真的非常好用。相信不久后你也可以在简历里面加上一句 “熟悉 Linux 开发环境” 了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Markdown 使用教程</title>
    <link href="/Markdown-tutorial/"/>
    <url>/Markdown-tutorial/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，在 2004 年由 John Gruber 创建。它允许人们使用易读易写的纯文本格式编写文档。<br>本文介绍使用 Markdown 编写博客时常用的标记符号供后续使用时参考。</p><span id="more"></span><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>使用 # 号标记，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><h2 id="Markdown-格式"><a href="#Markdown-格式" class="headerlink" title="Markdown 格式"></a>Markdown 格式</h2><p>可以实现的格式： <em>斜体文本</em> ， <strong>粗体文本</strong> ， <em><strong>粗斜体文本</strong></em> ， <del>删除线</del> ， <u>带下划线文本</u></p><p>分割线</p><hr><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套<br>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p><code>Println()</code> 函数输出 “Hello, world!” :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>欢迎访问我的 <a href="https://github.com/qanlyma">Github 仓库</a>: <a href="https://github.com/qanlyma">https://github.com/qanlyma</a></p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p><img src="/Markdown-tutorial/love.jpg" alt="我最喜欢的彩虹六号"></p><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><table><thead><tr><th align="left">左  对  齐</th><th align="right">右  对  齐</th><th align="center">居  中  对  齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="Markdown-高级"><a href="#Markdown-高级" class="headerlink" title="Markdown 高级"></a>Markdown 高级</h2><h3 id="支持部分-HTML-元素"><a href="#支持部分-HTML-元素" class="headerlink" title="支持部分 HTML 元素"></a>支持部分 HTML 元素</h3><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><strong>文本加粗</strong><br>** 正常显示星号 **</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Hexo 基础命令</title>
    <link href="/Hello-Hexo/"/>
    <url>/Hello-Hexo/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建新网站"><a href="#创建新网站" class="headerlink" title="创建新网站"></a>创建新网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><h3 id="清除缓存文件"><a href="#清除缓存文件" class="headerlink" title="清除缓存文件"></a>清除缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h3 id="在本地启动-hexo"><a href="#在本地启动-hexo" class="headerlink" title="在本地启动 hexo"></a>在本地启动 hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
