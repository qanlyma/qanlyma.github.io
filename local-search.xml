<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「研」 TCP 与 TLS/SSL</title>
    <link href="/TCP-IP-handshake/"/>
    <url>/TCP-IP-handshake/</url>
    
    <content type="html"><![CDATA[<p>本文总结 TCP 的三次握手和四次挥手，以及 TLS&#x2F;SSL 的四次握手过程。</p><span id="more"></span><h2 id="TCP-连接的建立（三次握手）"><a href="#TCP-连接的建立（三次握手）" class="headerlink" title="TCP 连接的建立（三次握手）"></a>TCP 连接的建立（三次握手）</h2><p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><p><img src="/TCP-IP-handshake/1.png" alt="三次握手"></p><ol><li>TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态。</li><li>TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文。报文首部中的同部位 SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x。此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN&#x3D;1 的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中 ACK&#x3D;1，SYN&#x3D;1，确认号是 ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK&#x3D;1，ack&#x3D;y+1，自己的序列号 seq&#x3D;x+1，此时，TCP连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段<strong>可以</strong>携带数据，如果<strong>不携带数据则不消耗序号</strong>。</li><li>当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。</li></ol><blockquote><p><strong>为什么TCP客户端最后还要发送一次确认呢？</strong></p><p>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><h2 id="TCP-连接的释放（四次挥手）"><a href="#TCP-连接的释放（四次挥手）" class="headerlink" title="TCP 连接的释放（四次挥手）"></a>TCP 连接的释放（四次挥手）</h2><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p><p><img src="/TCP-IP-handshake/2.png" alt="四次挥手"></p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN&#x3D;1，其序列号为 seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号 seq&#x3D;v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq&#x3D;w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是 seq&#x3D;u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2?MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</li><li>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</li></ol><blockquote><p><strong>为什么客户端最后还要等待 2MSL？</strong></p><p>MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><blockquote><p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p></blockquote><h2 id="TLS-x2F-SSL-握手"><a href="#TLS-x2F-SSL-握手" class="headerlink" title="TLS&#x2F;SSL 握手"></a>TLS&#x2F;SSL 握手</h2><p>SSL（Secure Socket Layer 安全套接层）是 TCP&#x2F;IP 协议中位于 HTTP 之下，TCP 之上的一个可选协议层。起初 HTTP 在传输数据时使用的是明文，是不安全的。为了解决这个隐患，网景（Netscap）公司推出了 SSL。</p><p>HTTPS（HTTP+SSL）的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时， 互联网工程任务组（IETF）对 SSL3.0 进行了标准化，并添加了少数机制，并将其更名为 TLS1.0（Transport Layer Security 安全传输层协议）。</p><p><img src="/TCP-IP-handshake/3.png" alt="HTTPS = HTTP + TLS/SSL"></p><p>在 HTTPS 协议中，当客户端与服务器通过三次握手建立 TCP 连接之后，并不会直接传输数据，而是会经过一个 SSL&#x2F;TLS 握手的过程，用于协商、以及验证证书等，之后就可以安全传输数据了。</p><p><img src="/TCP-IP-handshake/4.png" alt="TLS/SSL 握手"></p><ol><li><p>Client Hello：由客户端发起，主要包含以下信息：</p><ul><li>客户端生成的随机数 x，用于之后的密钥生成</li><li>客户端支持的加密算法列表（Cipher Suites）</li><li>TLS 版本信息</li><li>客户端支持的压缩算法列表（Compression Methods）</li></ul></li><li><p>Server Hello：服务端接收到客户端的 Client Hello 之后，服务端需要将自己的 CA 证书发送给客户端，这个步骤叫 Server Certificate。证书是对服务端的一种认证，是由专门的数字证书认证机构（CA）审核之后颁发的，所以一般人无法伪造。在颁发证书的同时还会产生两把钥匙，一把私钥，一把公钥。私钥由服务端保管不可泄露，公钥则附带在证书中公开。证书本身还附带了一个证书电子签名，这个签名用来验证证书的完整性和真实性，防止证书被人窜改。跟客户端一样，服务端也需要生产一个随机数 y 发送给客户端，客户端和服务端都需要使用这俩随机数生成通信密钥，这个过程叫 Server Key Exchange。最后服务端会发送一个 Server Hello Done 给到客户端，表示 Server Hello 过程结束。综上，由服务端发起的消息内容，主要包含：</p><ul><li>确认使用的加密通信协议版本，比如 TLS 1.2 版本。如果客户端和服务端支持的版本不一致，服务端关闭加密通信</li><li>服务端生成的随机数 y，用于之后的密钥生成</li><li>在客户端发送的加密算法列表里选一个加密算法，比如 RSA 公钥加密</li><li>服务器 CA 证书</li></ul></li><li><p>Certificate Verify：如果服务端需要客户端进行验证，在客户端收到服务端的 Server Hello 消息之后，首先需要向服务端发送客户端的证书，让服务端验证客户端的合法性。这个过程叫 Client Certificate。接着，客户端需要对服务端的证书进行检查，如果证书不是可信机构颁布、或证书中的域名与实际域名不符、或者证书已过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没问题，客户端就会从服务器证书中取出服务端公钥。这个过程叫 Certificate Verify。客户端用这个服务端的公钥加密一个随机数 z，并把这个加密过的随机数发送给服务端，这个过程叫 Client Key Exchange。由客户端会告诉服务端已经切换到协商好的加密算法的状态了，这个过程叫 Change Cipher Spec。最后由已经协商好的加密算法和之前的随机数 x、y、z，产生的一个密钥就是整个消息加密解密过程的核心所在了。这个过程叫 Encrypted Handshake Message。综上，由客户端发送给服务端的信息如下：</p><ul><li>由服务器公钥加密过的随机数 z，用于生成服务器的密钥</li><li>编码改变通知，表示随后的信息都将由双方协商的加密方法和密钥发送</li><li>客户端 TLS 握手结束通知，这一项也是前面发送所有内容的哈希值，用来供服务器校验</li></ul></li><li><p>Server Finish：服务端在接收到客户端传来的加密过的随机数 z 之后，使用自己的私钥对其进行解密获取随机数 z，并对数据进行验证。验证无误，用协商好的加密算法和之前的随机数 x、y、z 产生服务器密钥，它和客户端生成的密钥是一致的，因为此后的加密都是对称加密了。这个过程叫 Encrypted Handshake Message。等一切完毕之后，会给客户端发送通知，告知客户端已经切换到协商过的加密算法，这个过程叫 Change Cipher Spec。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 TCP/IP 分层结构</title>
    <link href="/TCP-IP-fiveLayers/"/>
    <url>/TCP-IP-fiveLayers/</url>
    
    <content type="html"><![CDATA[<p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;互联网协议）是互联网的基本协议，也是国际互联网络的基础。TCP&#x2F;IP 是一个协议族，包括多个网络协议，定义了计算机操作系统如何连入互联网，以及数据传输的标准。它是为了解决不同系统的计算机之间的传输通信而提出的一个标准，不同系统的计算机采用了同一种协议后，就能相互通信，从而能够建立网络连接，实现资源共享和网络通信。</p><span id="more"></span><h2 id="TCP-x2F-IP-的分层结构"><a href="#TCP-x2F-IP-的分层结构" class="headerlink" title="TCP&#x2F;IP 的分层结构"></a>TCP&#x2F;IP 的分层结构</h2><p>目前对计算机网络的分层方式一共有三种：1.OSI 七层模型；2.五层模型；3.TCP&#x2F;IP 四层模型</p><p>OSI 是一种理论模型，实现起来过分复杂，而且运行效率低。OSI 先有模型，后有协议，先有标准，后进行实践，而 TCP&#x2F;IP 则相反。TCI&#x2F;IP 已经被广泛使用，成为网络互连实际上的标准。而五层模型一般只出现在计算机网络学习教学过程中，是对七层模型和四层模型的一个折中。</p><p><img src="/TCP-IP-fiveLayers/1.png" alt="三种模型"></p><ul><li><strong>应用层</strong>：包含所有的高层协议，比如 Telnet（Telecommunications Network，远程登录协议）、FTP、SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）、DNS（Domain Name Service，域名服务）、NNTP（Net News Transfer Protocol，网络新闻传输协议）和 HTTP 等。Telnet 允许一台机器上的用户登录远程机器进行工作，FTP 提供将文件从一台机器上移到另一台机器上的有效方法，SMTP用于电子邮件的收发，DNS 用于把主机名映射到网络地址，NNTP 用于新闻的发布、检索和获取，HTTP 用于在 WWW 上获取主页。</li><li><strong>传输层</strong>：著名的 TCP 和 UDP（User Datagram Protocol，用户数据报协议）就在这一层。TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</li><li><strong>网络层</strong>：该层是整个 TCP&#x2F;IP 体系结构的关键部分，其功能是使主机可以把数据报（Packet，或称为分组）发往任何网络，并使分组独立地传向目标。这些分组经由不同的网络到达的顺序和发送的顺序可能不同。网络层使用的协议有 IP。</li><li><strong>数据链路层</strong>：该层是整个体系结构的基础部分，负责接收 IP 层的 IP 数据报，通过网络向外发送，或接收从网络上来的物理帧，抽出 IP 数据报，向 IP 层发送。该层是主机与网络的实际连接层。数据链路层下面就是实体线路（比如以太网络、光纤网络等）。数据链路层有以太网、令牌环网等标准，负责网卡设备的驱动、帧同步（从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机可以在不同的数据链路层的网络之间（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间）转发数据帧，由于不同数据链路层的帧格式不同，交换机要将进来的数据报拆掉报头重新封装之后再转发。</li></ul><p>不同的协议层对数据报有不同的称谓，在传输层叫作段（Segment），在网络层叫作数据报（Datagram），在数据链路层叫作帧（Frame）。数据封装成帧后发送到传输介质上，到达目的主机后，每层协议再剥掉相应的报头，最后将应用层数据交给应用程序处理。</p><p><img src="/TCP-IP-fiveLayers/2.png" alt="数据封装"></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>以浏览某个网页为例，看一下浏览网页的过程中 TCP&#x2F;IP 各层做了哪些工作。</p><p>发送方：</p><ol><li>打开浏览器，输入网址 <a href="http://www.xxx.com/">www.xxx.com</a> 按回车键来访问网页，其实就是访问 Web 服务器上的网页，在应用层采用的协议是 HTTP，浏览器将网址等信息组成 HTTP 数据，并将数据传送给传输层。</li><li>传输层在数据前面加上 TCP 报头，并标记端口为 80（Web 服务器的默认端口），将这个数据段给了网络层。</li><li>网络层在这个数据段前面加上自己机器的 IP 和目的 IP，这时该段被称为 IP 数据报，然后将这个 IP 数据报给了数据链路层。</li><li>数据链路层先在 IP 数据报前面加上自己机器的 MAC 地址以及目的 MAC 地址，加上 MAC 地址的数据称为帧，然后通过物理网卡把这个帧以比特流的方式发送到网络上。</li></ol><p>互联网上有路由器，它会读取比特流中的 IP 地址进行路由操作，到达正确的网段后，这个网段的交换机读取比特流中的 MAC 地址，从而找到要接收的对应机器。</p><p>接收方：</p><ol><li>数据链路层用网卡接收到了比特流，读取比特流中的帧，将帧中的 MAC 地址去掉，就成了 IP 数据报，传递给网络层。</li><li>网络层接收下层传来的 IP 数据报，将 IP 从包的前面拿掉，取出带有 TCP 的数据（数据段）交给传输层。</li><li>传输层拿到了这个数据段，看到 TCP 标记的端口是 80，说明应用层协议是 HTTP，之后将 TCP 头去掉并将数据交给应用层，告诉应用层对方请求的是 HTTP 数据。</li><li>应用层得知发送方请求的是 HTTP 数据，因此调用 Web 服务器程序把 <a href="http://www.xxx.com/">www.xxx.com</a> 的首页文件发送回去。</li></ol><p>如果两台计算机位于不同的网段中，那么数据从一台计算机到另一台计算机传输的过程中要经过一个或多个路由器，如下图所示。</p><p><img src="/TCP-IP-fiveLayers/3.png" alt="例子"></p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「论」 Hyperledger Fabric: A Distributed Operating System for Permissioned Blockchains</title>
    <link href="/Hyperledger-Fabric/"/>
    <url>/Hyperledger-Fabric/</url>
    
    <content type="html"><![CDATA[<p>摘要：Fabric 是一个模块化、可扩展的开源系统，用于部署和操作<strong>许可区块链</strong>，也是 Linux 基金会托管的超级账本项目之一。它支持<strong>模块化共识协议</strong>，允许系统根据特定用例和信任模型进行定制。在某些流行的部署配置中， Fabric 实现了每秒 3500 TPS，具有 sub-second 的延迟，可扩展到 100 多个对等节点。</p><span id="more"></span><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>区块链相较于传统的 SMR（state-machine replication，状态机复制）存在拜占庭式缺陷：</p><ol><li>不只一个，而是许多分布式应用程序同时运行</li><li>应用程序可以由任何人动态部署</li><li>应用程序代码是不可信的，甚至可能是恶意的</li></ol><p>许多现有区块链实施的是 <strong>order-execute</strong> 结构，它的局限性在于要求所有对等方执行每个交易，并且所有交易都是确定的。</p><ul><li>共识在平台内是硬编码的，这与没有一刀切的（BFT）共识协议的公认理解相矛盾</li><li>交易验证的信任模型由共识协议决定，不能适应智能合约的要求</li><li>智能合约必须以固定的、非标准的或特定领域的语言编写，这会阻碍广泛的应用，并可能导致编程错误</li><li>所有对等方对所有交易的顺序执行限制了性能，需要采取复杂的措施防止来自不可信合约的拒绝服务攻击</li><li>交易必须是确定性的，这在编程上很难保证</li><li>每个智能合约都在所有对等方上运行，这与保密性不符，并禁止向一部分对等方传播合约代码和状态</li></ul><p>Fabric 可以克服这些局限性。</p><p>Fabric 使用 <strong>execute-order-validate</strong> 结构，将交易分为三个步骤，可以在系统中不同的实体中运行：</p><ol><li><strong>executing</strong> 交易并检查其正确性，从而 <strong>endorsing</strong> 交易（对应于其他区块链中的“交易验证”）</li><li>通过共识协议进行 <strong>ordering</strong>，而不考虑交易语义</li><li>根据特定于应用程序的信任假设进行 <strong>validation</strong>，这防止了并发导致的竞争</li></ol><p>该设计结合了两种复制方案：<strong>passive</strong>（当一个事务提交时，领导者副本将该事务的数据变更广播给所有跟随者副本，跟随者按照提交顺序应用这些变更） 和 <strong>active</strong>（每个副本独立执行相同的确定性交易代码）</p><ul><li>首先 Fabric 使用 passive or primary-backup replication， 每个事务仅由一个对等方的子集执行（认可），这允许<strong>并行执行</strong>。灵活的背书政策规定了哪些对等方或其中多少对等方需要为正确执行给定智能合约提供担保。</li><li>其次 Fabric 结合了 active replication，即每个对等方单独执行的确定性验证步骤中，交易对账本状态的影响只有在总顺序达成共识后才能写入。状态更新的排序被委托给一个模块化组件以实现共识（即 atomic broadcast），该组件是无状态的，并且在逻辑上与执行事务和维护账本的对等方分离。由于共识是模块化的，因此它的实现可以根据特定部署的信任假设进行调整。</li></ul><p>Fabric 中包含了以下组件：</p><ul><li><strong>ordering service</strong> 以原子方式向对等方广播状态更新，并就事务顺序建立共识。</li><li><strong>membership service provider</strong> 负责将对等方与加密身份相关联。它保持了 Fabric 的许可性。</li><li>可选的 <strong>peer-to-peer gossip service</strong> 通过 ordering service 向所有对等节点传播块的输出。</li><li>Fabric 中的 <strong>smart contracts</strong> 在容器环境中运行以隔离。它们可以用标准编程语言编写，但不能直接访问帐本状态。</li><li>每个对等方以 append-only blockchain 的形式在本地维护 <strong>ledger</strong>，并将其作为键值存储中最新状态的快照。</li></ul><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2 BACKGROUND"></a>2 BACKGROUND</h2><h3 id="2-1-Order-Execute-Architecture-for-Blockchains"><a href="#2-1-Order-Execute-Architecture-for-Blockchains" class="headerlink" title="2.1 Order-Execute Architecture for Blockchains"></a>2.1 Order-Execute Architecture for Blockchains</h3><p><img src="/Hyperledger-Fabric/1.png" alt="Order-execute architecture in replicated services."></p><h3 id="2-2-Limitations-of-Order-Execute"><a href="#2-2-Limitations-of-Order-Execute" class="headerlink" title="2.2 Limitations of Order-Execute"></a>2.2 Limitations of Order-Execute</h3><ul><li>Sequential execution：成为性能瓶颈</li><li>Non-deterministic code：导致分叉</li><li>Confidentiality of execution：保密开销巨大</li></ul><h3 id="2-3-Further-Limitations-of-Existing-Architectures"><a href="#2-3-Further-Limitations-of-Existing-Architectures" class="headerlink" title="2.3 Further Limitations of Existing Architectures"></a>2.3 Further Limitations of Existing Architectures</h3><ul><li>Fixed trust model：应用程序级别的信任不应固定为协议级别的信任</li><li>Hard-coded consensus：应使用不同共识协议适应不同的环境</li></ul><h3 id="2-4-Experience-with-Order-Execute-Blockchain"><a href="#2-4-Experience-with-Order-Execute-Blockchain" class="headerlink" title="2.4 Experience with Order-Execute Blockchain"></a>2.4 Experience with Order-Execute Blockchain</h3><p>区块链系统的关键属性，即一致性、安全性和性能，不得依赖于其用户的知识和善意，因为区块链在不受信任的环境中运行。</p><h2 id="3-ARCHITECTURE"><a href="#3-ARCHITECTURE" class="headerlink" title="3 ARCHITECTURE"></a>3 ARCHITECTURE</h2><h3 id="3-1-Fabric-Overview"><a href="#3-1-Fabric-Overview" class="headerlink" title="3.1 Fabric Overview"></a>3.1 Fabric Overview</h3><p>Execute-order-validate blockchain architecture：<br><img src="/Hyperledger-Fabric/2.png" alt="Execute-order-validate architecture of Fabric"></p><p>Fabric 的分布式应用程序由两部分组成：</p><ul><li><strong>chaincode</strong>：一个智能合约，在执行阶段运行，可以使用通用编程语言（Golang、Java等）</li><li><strong>endorsement policy</strong>：一个背书策略，在验证阶段被评估，只有特定的管理员可以修改</li></ul><p>客户端向背书策略指定的节点发送交易，然后由节点执行每个交易，并记录其输出，这一步骤也称为 endorsement。执行完成后，交易进入排序阶段，通过可插拔的共识协议对这些交易排序（并非交易输入，而是对交易输出排序，并结合状态依赖），然后向所有节点广播。然后，每个节点根据背书策略验证背书交易的状态变化，并验证交易的一致性。在此期间 Fabric 使用了主动和被动复制的混合策略。</p><p>三个角色：</p><p><img src="/Hyperledger-Fabric/3.png" alt="MSP: membership service provider"></p><ul><li><strong>Clients</strong>：提交、广播交易</li><li><strong>Peers</strong>：执行（并不执行所有交易，只有被指定为 endorsers 时执行）、验证交易，维护区块链</li><li><strong>Orderers</strong> (OSN，Ordering Service Nodes)：给所有交易排序</li></ul><p>交易流：</p><p><img src="/Hyperledger-Fabric/4.png" alt="Fabric high level transaction flow"></p><h3 id="3-2-Execution-Phase"><a href="#3-2-Execution-Phase" class="headerlink" title="3.2 Execution Phase"></a>3.2 Execution Phase</h3><p>在执行阶段，客户端签署交易提案（proposal）并发送给背书策略中指定的背书人。背书人根据本地区块链状态模拟执行提案，此时的执行结果并不会与其他节点同步，也不会写入账本中。链码创建的状态仅限于该链码，不能由其他链码直接访问。给定适当的许可，链码可以调用另一个链码来访问同一通道内的状态。</p><p>每一个背书人在模拟执行的时候会生成一个 writeset（模拟执行产生的状态更新，即修改的键和值）和一个 readset（表示提案模拟执行的版本依赖，即模拟过程中所有的键和它的版本号）。模拟结束后，背书人对一条名为背书（endorsement）的消息进行加密签名，该消息包含 writeset 和 readset（以及交易 ID、背书人 ID 和背书人签名等元数据），并在提案响应中将其发送回客户端。客户端收集这些 endorsement 直到满足背书策略的要求，同时所有背书人要产生相同的执行结果（即，相同的 writeset 和 readset）。然后客户端会将交易发送给排序服务。</p><p>这种在排序之前的执行可以容忍非确定性链码，执行结果的不一致会导致它无法收集足够数量的背书。同时背书人若怀疑收到 DoS 攻击，可以根据本地协议单方面终止执行交易。</p><h3 id="3-3-Ordering-Phase"><a href="#3-3-Ordering-Phase" class="headerlink" title="3.3 Ordering Phase"></a>3.3 Ordering Phase</h3><p>当客户端收集到足够的背书时，它组装一个交易并将其提交给排序服务，该交易包含链码操作和参数、交易元数据和一组背书。排序阶段为每个通道（channel，不同的区块链系统可以连接至同一个排序服务，每一个区块链系统都叫做一个通道）提交的交易分别进行总排序。此外，排序服务将多个交易打包成块，并输出块的哈希链序列。</p><p>排序服务的节点不维护区块链的状态，也不验证或执行交易。这种架构是 Fabric 的一个关键的特征，使 Fabric 成为第一个将共识与执行和验证完全分离的区块链系统。同时请注意，我们不需要排序服务来防止交易重复，因为在验证阶段节点在读写检查中过滤了重复的交易。</p><h3 id="3-4-Validation-Phase"><a href="#3-4-Validation-Phase" class="headerlink" title="3.4 Validation Phase"></a>3.4 Validation Phase</h3><p>区块直接由排序服务或者 gossip 发送给节点，然后进入验证阶段：</p><ol><li>对区块内的所有交易并行进行背书策略评估。评估是所谓的验证系统链码（VSCC）的任务，如果背书不满足，则交易被标记为无效，其影响将被忽略。</li><li>对区块内的所有交易按序进行读写冲突检查。对于每一笔交易，它都会将 readset 字段中的键与节点本地存储的账本当前状态的键进行比较，并确保它们相同。如果版本不匹配，则转换标记为无效，并忽略其影响。</li><li>最后对账本进行更新，其中区块被附加到本地存储的账本，区块链状态被更新。特别是，当将块添加到账本时，前两个步骤中的有效性检查结果也将以位掩码的形式持久化，该位掩码表示块内有效的交易。这有助于以后恢复状态。此外，所有状态更新都是将写集中的键值对写入本地状态。</li></ol><p>Fabric 帐本中也包括无效的交易，只是因为排序服务在形成区块时与链码状态无关。在某些需要在后续审计期间跟踪无效交易的用例中需要此功能，与以太坊（只包含有效交易）等其他区块链形成对比。</p><h3 id="3-5-Trust-and-Fault-Model"><a href="#3-5-Trust-and-Fault-Model" class="headerlink" title="3.5 Trust and Fault Model"></a>3.5 Trust and Fault Model</h3><p>所有客户端都是潜在的恶意或者拜占庭节点；节点被分为不同的组织，组织内节点相互信任，但不信任组织外的某一节点；排序服务认为所有客户端和节点都可能是拜占庭的。</p><p>Fabric 将应用程序的信任模型与共识的信任模型解耦。分布式应用程序可以定义自己的信任假设，这些假设通过背书策略传递，并且独立于由排序服务实现的共识假设。</p><h2 id="4-FABRIC-COMPONENTS"><a href="#4-FABRIC-COMPONENTS" class="headerlink" title="4 FABRIC COMPONENTS"></a>4 FABRIC COMPONENTS</h2><p>Fabric 是用 Go 语言编写的，并采用 gRPC 框架在节点之间传输信息。</p><p><img src="/Hyperledger-Fabric/5.png" alt="Fabric 节点的组成"></p><h3 id="4-1-Membership-Service"><a href="#4-1-Membership-Service" class="headerlink" title="4.1 Membership Service"></a>4.1 Membership Service</h3><p>The membership service provider (MSP) 维护着系统内所有节点（clients，peers，OSNs）的身份信息，并负责颁发用来认证和授权的凭据。因为 Fabric 是许可链，节点之间的所有交互都是通过经过身份验证的消息进行的，通常会使用数字签名。用于节点密钥管理和注册的工具也是 MSP 的一部分。</p><h3 id="4-2-Ordering-Service"><a href="#4-2-Ordering-Service" class="headerlink" title="4.2 Ordering Service"></a>4.2 Ordering Service</h3><p>排序服务管理着多个通道，对于每个通道它提供以下服务：</p><ol><li>用于交易排序的原子广播，实现 broadcast 和 deliver 调用</li><li>在成员广播配置更新交易时，修改通道的配置</li><li>访问控制（可选），限制向指定客户端和节点广播交易和接收区块</li></ol><p>OSN 直接将新接收的交易注入原子广播（例如，Kafka代理）。OSNs 对原子广播接收的交易批处理并形成块。一旦满足以下三个条件之一，即成块：</p><ol><li>该块包含指定的最大交易数</li><li>块已达到最大大小（字节）</li><li>从接收到新块的第一个交易起已经过去了一段时间</li></ol><p><strong>该批处理过程是确定性的，因此在所有节点上产生相同的块。</strong>（这是由原子广播的特性决定的）</p><h3 id="4-3-Peer-Gossip"><a href="#4-3-Peer-Gossip" class="headerlink" title="4.3 Peer Gossip"></a>4.3 Peer Gossip</h3><p>将执行、排序和验证阶段分离的一个优点是它们可以独立扩展。由于大多数共识算法（在 CFT 和 BFT 模型中）都有带宽限制，排序服务的吞吐量会受到其节点的网络容量的限制。研究表明共识性能不能通过增加节点数量来增大，这样做吞吐量反而会降低。然而，由于排序和验证是分离的，因此在排序阶段之后，可以高效地将执行结果广播给所有节点进行验证；以及向新加入的节点和长期断开连接的节点的状态同步，正是 gossip 部分的目标。</p><p>Gossip 的通信层基于 gRPC，并利用 TLS 相互认证，其组件维护系统中最新的在线成员视图。</p><p>Fabric gossip 使用两个阶段进行信息传播：</p><ul><li>push：每个节点从成员视图中随机选取一组活跃的邻居节点，并向它们转发消息</li><li>pull：每个节点周期性地访问一组随机选择的节点并请求丢失的消息。</li></ul><p>为了减少从排序节点向网络发送块的负载，该协议还选择一个领导节点从排序服务中 pull 区块并发起 gossip。</p><h3 id="4-4-Ledger"><a href="#4-4-Ledger" class="headerlink" title="4.4 Ledger"></a>4.4 Ledger</h3><p>Ledger 由一个 block store 和一个 peer transaction manager 组成：</p><ul><li>Ledger block store：由一组仅添加的文件组成，同时维护一些索引，用于随机访问块或块中的交易。</li><li>Peer transaction manager（PTM）：在版本化的键值储存中维护最新状态（key，val，ver）</li></ul><p>对于交易验证，PTM 顺序验证块中的所有交易。这将检查一个交易是否与之前的任何交易冲突（当前块或更早的块中）。对于 readset 中的任何键，如果 readset 中记录的版本与最新状态下的版本不同（假设所有之前的有效交易都已提交），则 PTM 将该交易标记为无效。PTM 会计算并保存一个 savepoint，表示成功应用的最大块数，用于崩溃中恢复时从持久化块中恢复索引和最新状态。</p><h3 id="4-5-Chaincode-Execution"><a href="#4-5-Chaincode-Execution" class="headerlink" title="4.5 Chaincode Execution"></a>4.5 Chaincode Execution</h3><p>链码的执行环境与节点低耦合，它支持用于添加新的链码编程语言的插件，目前支持 Go、Java 和 Node。</p><p>每个用户级或应用程序链码都在 Docker 容器的一个单独进程中运行，这将链码彼此隔离，并与节点隔离。而系统链码直接在节点进程中运行，可以实现 Fabric 所需的特定功能，并且可以在用户链码之间的隔离过于严格的情况下使用。</p><h3 id="4-6-Configuration-and-System-Chaincodes"><a href="#4-6-Configuration-and-System-Chaincodes" class="headerlink" title="4.6 Configuration and System Chaincodes"></a>4.6 Configuration and System Chaincodes</h3><p>Fabric 可以通过 channel configuration 和 system chaincodes 来定制结构。每个通道形成一个逻辑区块链，通道的配置保存在特殊 configuration blocks（genesis block）的元数据中。通道配置包括：</p><ol><li>确定参与节点的 MSPs</li><li>OSNs 的网络地址</li><li>实现共识和排序服务的共享配置（例如 batch size 和 timeouts）</li><li>制定访问排序服务的操作（broadcast 和 deliver）</li><li>制定修改通道配置的规则</li></ol><h2 id="5-EVALUATION"><a href="#5-EVALUATION" class="headerlink" title="5 EVALUATION"></a>5 EVALUATION</h2><p>此节介绍一些初步的性能数据和影响因素。引入 Fabric Coin（Fabcoin，UTXO cryptocurrencies）用于性能测试和比较。</p><h2 id="6-APPLICATIONS-AND-USE-CASES"><a href="#6-APPLICATIONS-AND-USE-CASES" class="headerlink" title="6 APPLICATIONS AND USE CASES"></a>6 APPLICATIONS AND USE CASES</h2><p>略</p><h2 id="7-RELATED-WORK"><a href="#7-RELATED-WORK" class="headerlink" title="7 RELATED WORK"></a>7 RELATED WORK</h2><p>略</p><h2 id="8-CONCLUSION"><a href="#8-CONCLUSION" class="headerlink" title="8 CONCLUSION"></a>8 CONCLUSION</h2><p>未来的改进工作：</p><ol><li>探索基准测试和优化实现性能</li><li>可扩展到大型部署</li><li>一致性保证和更通用的数据模型</li><li>通过不同的共识协议保证其他弹性</li><li>通过加密技术对交易和账本数据进行隐私和保密</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「训」 笔记（一）：Go 语言</title>
    <link href="/ByteDance-1/"/>
    <url>/ByteDance-1/</url>
    
    <content type="html"><![CDATA[<p>关于 Go 语言的基础和进阶教程，示例代码在我的 Github 上：<a href="https://github.com/qanlyma/go-by-example">基础代码</a>，<a href="https://github.com/qanlyma/go-project-example/tree/V0">进阶代码</a></p><span id="more"></span><h2 id="1-Go-语言基础"><a href="#1-Go-语言基础" class="headerlink" title="1 Go 语言基础"></a>1 Go 语言基础</h2><h3 id="1-1-Go-语言简介"><a href="#1-1-Go-语言简介" class="headerlink" title="1.1 Go 语言简介"></a>1.1 Go 语言简介</h3><ul><li>高性能、高并发</li><li>语法简单、学习曲线平滑</li><li>丰富的标准库</li><li>完善的工具链</li><li>静态链接</li><li>快速编译</li><li>跨平台</li><li>垃圾回收</li></ul><h3 id="1-2-基础语法"><a href="#1-2-基础语法" class="headerlink" title="1.2 基础语法"></a>1.2 基础语法</h3><p>Golang 的安装和基础使用，可以参考<a href="https://www.runoob.com/go/go-tutorial.html">菜鸟教程</a>。</p><p>补充几点：</p><ol><li>错误处理</li></ol><p><img src="/ByteDance-1/1.png" alt="错误处理"></p><ol start="2"><li>字符串操作</li></ol><p><img src="/ByteDance-1/2.png" alt="字符串操作"></p><ol start="3"><li>字符串格式化</li></ol><p><img src="/ByteDance-1/3.png" alt="字符串格式化"></p><ol start="4"><li>JSON 处理</li></ol><p>对于一个已有的结构体，只要保证每个字段的第一个字母是大写（公开字段），就可以用 JSON.Marshal 序列化成一个 JSON 字符串。</p><p><img src="/ByteDance-1/4.png" alt="JSON 处理"></p><ol start="5"><li>时间处理</li></ol><p><img src="/ByteDance-1/5.png" alt="时间处理"></p><ol start="6"><li>数字解析</li></ol><p><img src="/ByteDance-1/6.png" alt="数字解析"></p><ol start="7"><li>进程信息</li></ol><p><img src="/ByteDance-1/7.png" alt="进程信息"></p><h3 id="1-3-项目实战"><a href="#1-3-项目实战" class="headerlink" title="1.3 项目实战"></a>1.3 项目实战</h3><ol><li><p>猜谜游戏</p><ul><li>生成随机数：用时间戳来初始化随机数种子</li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    maxNum := <span class="hljs-number">100</span> <br>    rand.Seed(time.Now().UnixNano()) <br>    secretNumber := rand.Intn(maxNum) <br>    fmt.Println(<span class="hljs-string">&quot;The secret number is &quot;</span>, secretNumber)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读取用户输入</li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    maxNum := <span class="hljs-number">100</span><br>    rand.Seed(time.Now().UnixNano())<br>    secretNumber := rand.Intn(maxNum)<br>    fmt.Println(<span class="hljs-string">&quot;The secret number is &quot;</span>, secretNumber)<br><br>    fmt.Println(<span class="hljs-string">&quot;Please input your guess&quot;</span>)<br>    reader := bufio.NewReader(os.Stdin)<br><br>    <span class="hljs-comment">//读取一行输入</span><br>    input, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;An error occured while reading input. Please try again&quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">//去掉换行符</span><br>    input = strings.Trim(input, <span class="hljs-string">&quot;\r\n&quot;</span>)<br>    <span class="hljs-comment">//转换为数字</span><br>    guess, err := strconv.Atoi(input)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Invalid input. Please enter an integer value&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;You guess is&quot;</span>, guess)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>逻辑判断 + 游戏循环：略</li></ul></li></ol><hr><ol start="2"><li>命令行词典</li></ol><hr><ol start="3"><li>SOCKS5 代理</li></ol><h2 id="2-Go-语言进阶"><a href="#2-Go-语言进阶" class="headerlink" title="2 Go 语言进阶"></a>2 Go 语言进阶</h2>]]></content>
    
    
    <categories>
      
      <category>字节青训</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「研」 区块链扩容调研</title>
    <link href="/Blockchain-scalability/"/>
    <url>/Blockchain-scalability/</url>
    
    <content type="html"><![CDATA[<p>一篇关于区块链 Layer 1 和 Layer 2 的扩容调研报告。</p><span id="more"></span><h2 id="一、区块链扩容"><a href="#一、区块链扩容" class="headerlink" title="一、区块链扩容"></a>一、区块链扩容</h2><h3 id="1-1-为什么需要扩容"><a href="#1-1-为什么需要扩容" class="headerlink" title="1.1 为什么需要扩容"></a>1.1 为什么需要扩容</h3><p>在比特币诞生之初，创始人中本聪并没有特意限制区块的大小，区块最大可以达到 32MB。当时，平均每个区块大小为 1-2KB，有人认为区块链上限过高容易造成计算资源的浪费，还容易发生 DDOS 攻击（分布式拒绝服务攻击）。因此，为了保证比特币系统的安全和稳定，中本聪决定临时将区块大小限制在 1MB。</p><p>随着越来越多的人关注和使用比特币，链上最高时有上万笔交易积压，很多用户为了尽快让自己的交易被打包，不得不增加手续费，有时候比特币转账交易费高达几十美元。网络拥堵时，一个比特币交易甚至需要花费好几天才能被打包，同理也使得以太坊上的gas费用居高不下。比特币和以太坊作为区块链 1.0 和 2.0 的代表，比特币每秒大约只能处理 7 个交易，性能只有 7TPS；以太坊每秒只能处理 15 个交易，性能只有 15TPS。而作为中心化的代表，淘宝在 17 年双十一超过了 200,000TPS，可见区块链的 TPS 跟中心化应用还有很大的差距。</p><p>与很多分布式系统一样，区块链技术中也有一个“不可能三角形”，比特币和以太坊在最早诞生时最关注的是去中心化和安全，牺牲了可扩展性。后来，市场上不断有一些新的区块链项目牺牲掉去中心化或者安全性来为可扩展性保驾护航，试图部署出一个吞吐量较高的区块链网络。迄今为止，还没有人找到去中心化、可扩展性和安全性三全其美的策略，打造出一个充分运行、基于加密货币的大规模区块链网络。但是，如果想把区块链的应用拓展到虚拟货币投资之外，必须得有支持其吞吐量扩容的解决方案。</p><p><img src="/Blockchain-scalability/1.png" alt="不可能三角"></p><h3 id="1-2-如何扩容"><a href="#1-2-如何扩容" class="headerlink" title="1.2 如何扩容"></a>1.2 如何扩容</h3><p>所谓的扩容方案是指“为了改善区块链交易速度使其达到规模化所提出的解决方案”，各层所提出的扩容方案，其最终目的都是为了解决区块链交易速度的问题。</p><p><img src="/Blockchain-scalability/2.png" alt="区块链分层"></p><p>目前主要可以分为链上（Layer 1）和链下（Layer 2）的扩容方案。链上扩容是指为了提高区块链的吞吐量而对其进行的任何直接修改，比如比特币修改共识机制来改变区块结构或直接增加区块大小，而以太坊的策略则是改变网络结构进行分片，不同的分片并行处理不同的交易，增加整体吞吐量。而链下扩容是指在不改变公链本身规则的前提下，将数据计算过程等信息移到链下进行，而主链仅记录结果，比如比特币的闪电网络，以太坊的侧链，状态通道和 Rollup 等。下文将对具体方案进行详细介绍。</p><p><img src="/Blockchain-scalability/3.png" alt="扩容方案"></p><h2 id="二、Layer-1-扩容"><a href="#二、Layer-1-扩容" class="headerlink" title="二、Layer 1 扩容"></a>二、Layer 1 扩容</h2><h3 id="2-1-扩块和隔离见证"><a href="#2-1-扩块和隔离见证" class="headerlink" title="2.1 扩块和隔离见证"></a>2.1 扩块和隔离见证</h3><p>想让一个区块打包更多的交易，最直观的有两种解决办法：一是增加区块大小；二是缩小交易数据的尺寸。这就分别产生了扩块和隔离见证两个扩容方案，当然这两个方案也可以一起使用，可是不论选择何种方案都避免不了区块链的分叉。</p><p>比特币社区中提及比较多的是 2MB 区块，一部分人希望通过硬分叉直接把区块大小限制从 1M 改到 2M，提升单个区块内的交易数，每秒打包的交易就会增加，从而提升 TPS。可是扩块有一些弊端：</p><ul><li>(1) 大区块传播速度变慢，验证速度变慢，导致频繁的重组，双花攻击概率提高；</li><li>(2) 大区块导致储存量大幅度增加，成本提高，节点可能减少，趋向中心化从而影响安全。</li></ul><p>比特币社区有一部分人不接受硬分叉，坚持使用隔离见证（Segwit）方案去优化主链结构，并且结合闪电网络等二层网络结构来改善支付体验。隔离见证的原理是压缩每笔交易的大小，从而增加每个区块可以记录的交易数量。此方案将比特币交易数据分为交易信息和签名信息，对于普通用户来说他们只关心每个账户有多少资产，不需要验证信息，隔离见证就是把区块内的数字签名信息拿出去，让每个区块可以承载更多交易，从而达到扩容的目的。可是这样做的扩容能力有限，依然难以满足大量转账的需求。</p><p>两种方案的支持者方争论不休，随着加密货币市场迎来了前所未有的关注度，比特币价格连创新高，这也让比特币的交易更加拥堵，最终在 2017 年 8 月 1 日导致了比特币历史上第一次重大硬分叉的出现，比特币区块大小由 1M 扩大到 8M，同时也诞生出新币种 BCH（比特币现金）。</p><h3 id="2-2-分片"><a href="#2-2-分片" class="headerlink" title="2.2 分片"></a>2.2 分片</h3><p>分片技术（sharding）来自中心化数据库技术，将大型数据库数据进行切分，并分布在特点的服务器中，以提高数据库性能。如果将分片技术运用到区块链中，就相当于将区块链网络里的所有待处理任务进行分解，全网的节点也进行分组，每一组同时处理一个分解后的任务，这样就从原先单一节点处理全网的所有任务变成了多组节点同时处理，如此以来，自然就能大大提升这条链的处理效率。但是分片技术的问题也是显而易见的：分片多用于以太坊网络中，那么跨片区智能合约交易如何处理？片区如何划分？各片区如何同步？</p><p><img src="/Blockchain-scalability/4.png" alt="分片"></p><p>分片技术根据不同的分片机制可以划分为三种：</p><ul><li>网络分片（network sharding）</li><li>交易分片（transaction sharding）</li><li>状态分片（state sharding）</li></ul><h4 id="2-2-1-网络分片"><a href="#2-2-1-网络分片" class="headerlink" title="2.2.1 网络分片"></a>2.2.1 网络分片</h4><p>网络分片是最基础的一种分片方式，就是将整个区块链网络划分成多个子网络（也就是一个分片），网络中的所有分片并行处理网络中不同的交易。</p><p>但是这个方案会使网络的安全性和去中心化性会下降，比如原来 A 想要在某交易中作恶，因为共识机制的原因，A 需要控制全网的大部分节点或算力才行，但现在因为分片把节点分散到一个个小的区域中，A 只用控制包含这个交易的小区域的大部分节点算力就行。</p><p>幸好分片技术另外一个非常重要的机制就是随机分配，在区块链领域建立随机性的方式主要是利用可验证随机函数（VRF, Verifiable Random Function）。利用随机性，网络可以随机抽取节点形成分片。这样一种随机抽样的方式可以防止恶意节点过度填充单个分片，这样想要作恶的人，就很难知道一个小区域中的节点都有谁，作恶成本会大幅提高，从而分片技术能在保证安全与去中心化的同时，解决效率与可扩展性问题。</p><h4 id="2-2-2-交易分片"><a href="#2-2-2-交易分片" class="headerlink" title="2.2.2 交易分片"></a>2.2.2 交易分片</h4><p>网络分片是其他所有分片的基础，交易分片的前提是先进行网路分片。交易分片主要涉及的问题是哪些交易应该按照特定的属性被分配到哪些分片当中。</p><ul><li>基于 UTXO 的账本系统。在基于 UTXO 的账本系统中，一笔交易可能由多个输入和多个输出构成，我们没有办法按照地址进行交易分片来有效地避免双花问题。比较直观的交易分片方式是按照交易的 hash 值最后几位进行分片。但是这样也有可能导致双花交易，所以不同分片之间不得不进行通信。</li><li>基于账户系统。在基于账户系统中，一笔交易只有一个输入，而输入的地址将被记录在账户系统中。该账户系统在交易分片的每个分片中是全局可见的，因此我们只需要将交易按照发送者的地址进行分片，即可保证同一个账户发出的多笔交易将被在同一个分片当中被处理，这样该分片可以有效的检测双花交易而不需要复杂的跨分片的通信。</li></ul><h4 id="2-2-3-状态分片"><a href="#2-2-3-状态分片" class="headerlink" title="2.2.3 状态分片"></a>2.2.3 状态分片</h4><p>状态分片的关键是将整个存储区分开，让不同的分片存储不同的部分，每个节点只负责托管自己的分片数据，而不是存储完整的区块链状态。状态分片可以减少状态的冗余存储，使得整个区块链网络具有存储的可扩展性。</p><p>在账户型系统中，状态分片是按照账户的地址进行分片的，并且一个特定的分片只会保留一部分状态，而不像是交易分片那样每个节点都保存整个网络中的所有状态。这导致可能需要进行频繁的跨分片通信和状态交换。跨分片通信可能又会降低状态分片的性能。</p><p>在状态分片的情况下，重新分配节点是非常困难的。由于每个分片只保留了网络状态的一部分，所以在一次重新调整网络的过程中，必须要防止调整过大而导致在同步完成前可能会出现的整个系统失效的问题。为了防止系统的中断，必须对网络进行逐步调整，以确保每个分片在所有节点被清空前仍有足够多的旧节点。而新节点在加入分片之前，需要等待同步完该分片中的状态信息之后才可以正式加入分片并提供算力。</p><h3 id="2-3-Casper"><a href="#2-3-Casper" class="headerlink" title="2.3 Casper"></a>2.3 Casper</h3><p>比特币和以太坊当前都采用工作量证明（PoW）共识机制，这是个低效的系统，因为它消耗会大量的电力和能量。而且这个机制可以通过购买更快更强的 ASIC 设备比其他人拥有更高的概率挖到区块，这导致比特币并没有像它希望的那样分散化。如果采取其他共识机制（PoS），改变区块形成的规则，提高系统效率即可增加每秒处理交易。Csaper 就是以太坊选择实行的 PoS 协议，值得一提的是，Casper 并非专为扩容而设计，但它会对以太坊网络容量产生积极影响。</p><p><img src="/Blockchain-scalability/5.png" alt="PoS"></p><p>在介绍 Casper 之前我们首先要了解无利害关系问题（Nothing at stake），这一问题是由于 PoS 机制不会消耗节点的算力，所以在共识系统出现分叉情况时，出块节点可以在“不受任何损失”的前提下，同时为多条链出块，从而有可能获得“所有收益”。Casper 是一种基于保证金的经济激励共识协议。协议中的节点作为“锁定保证金的验证人”，必须先缴纳保证金才可以参与出块和共识形成。Casper 共识协议通过对这些保证金的直接控制来约束验证人的行为。具体来说就是，如果一个验证人作出了任何 Casper 认为“无效”的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消，从而解决了无利害关系问题。</p><p>从扩容的角度来说，修改后，可以从根本上改变区块形成的规则，往有利于交易量增加的方向修改。但是无论如何改变，共识算法仍然是分布式算法，需要多个节点达成一致，处理的上限是一台机器处理能力的上限。并且共识机制是加密货币的核心，涉及加密货币的整体逻辑，需要全盘考虑对旧区块的承接、安全性、后续发展等问题，还需要做大量的技术尝试。</p><h2 id="三、Layer-2-扩容"><a href="#三、Layer-2-扩容" class="headerlink" title="三、Layer 2 扩容"></a>三、Layer 2 扩容</h2><p>第二层扩容也称链下扩容，是不改变公链基础协议的一种应用层上的扩展方案，即不改动区块链本身的规则（区块大小，共识机制等）。由 Layer 2 协议，区块链事务的“状态生成”可以独立于 Layer 1 之外进行。换句话说 Layer 2 扩容方案是尽可能在不牺牲区块链网络安全性的情况下实现高吞吐量的状态生成。</p><h3 id="3-1-侧链协议"><a href="#3-1-侧链协议" class="headerlink" title="3.1 侧链协议"></a>3.1 侧链协议</h3><p>侧链是与公链并排运行并与之通信的独立区块链，它使用另一个代币与公链代币相互锚定，从而创建了双向桥。侧链是完全独立的，具有自己的共识机制和安全性保证。通过这种解决方案，可以实现数字资产从第一个区块链到第二个区块链的转移，又可以在稍后的时间点从第二个区块链安全返回到第一个区块链。其中第一个区块链通常被称为主区块链或者主链，每二个区块链则被称为侧链。</p><p><img src="/Blockchain-scalability/7.png" alt="侧链协议"></p><p>由于没有第一层设计的负担，侧链可以支持超出其基础层能力的某些特性，包括但不限于可扩展性和互操作性，同时不依赖于第一层的存储，可以建设多条侧链提供非常高的 TPS。而且得益于其独立性，如果侧链上出现了代码漏洞和大量资金被盗等问题，主链的安全性和稳定性都不会受到影响。缺点是它不是一个无信任的环境，用户需要将资金托管转移到侧链，从侧链取回资产时的安全性问题需要被考虑，侧链目前不那么成熟，去中心化也更差。</p><h3 id="3-2-状态通道"><a href="#3-2-状态通道" class="headerlink" title="3.2 状态通道"></a>3.2 状态通道</h3><p>状态通道是固定一组参与者（通常是两名参与者）之间的协议，用以实现安全的链下交易，其中支付通道专门用来支付。支付通道协议具体情况是两名参与者各自通过链上交易在链上锁定保证金，一旦锁定完成，参与者双方即可互相发送形式为轮次、金额、签名的状态更新来实现转账，无需与主链进行交互，只要双方的余额都还为正值即可。一旦参与者中有一方想要停止使用支付通道，可以执行退出操作：将最后的状态更新提交至主链，结算下来的余额会退给发起支付通道的两方。主链可以通过核实签名和最后结余来验证状态更新的有效性，从而防止参与者使用无效状态来退出支付通道。</p><p>该方案会用到一个协议叫 HTLC（Hashed Timelock Contract），其实就是限时转账。A 给 B 转账，A 先冻结一笔钱，并提供一个哈希值，如果在一定时间内 B 能提出一个字符串匹配，则这笔钱转给 B。过了一定时间没有<br>提交这个字符串的话，A 就可以拿回这笔钱。</p><p><img src="/Blockchain-scalability/12.png" alt="HTLC"></p><p>状态通道带来的优点是交互延迟在毫秒级别，是唯一能够逼近当今互联网用户体验的区块链扩容技术；交易手续费极低，从根本上比所有其他 Layer 2 技术的交易手续费低；水平扩展性强，加节点就能增加总系统容量，TPS 无上限，且互相之间不隔离，不需要有跨分片或者跨链之类的复杂操作。但它的退出模式存在一个问题，即主链无法验证支付通道是否提交了全部交易，也就是说，在提交了状态更新之后是否不再出现新的状态更新。而且它的使用场景较为局限：长期合作关系的双方的支付，偶发性交易难以适用，并且通道不能用于将资金在链外发送给尚未参与的人。此外，状态通道只能在两个参与者之间开设。闪电网络就是比特币使用状态通道的例子。</p><p><img src="/Blockchain-scalability/6.png" alt="闪电网络"></p><p>状态通道相较于侧链协议有更强的隐私性，并且有即时的最终确定性。但是状态通道需要所有参与者 100% 的在线，在侧链中，你就不需要一直在线。</p><h3 id="3-3-Plasma"><a href="#3-3-Plasma" class="headerlink" title="3.3 Plasma"></a>3.3 Plasma</h3><p>Plasma 由 Vitalik 和 Joseph Poon 在 2017 年共同提出，Plasma 是一种链下交易的技术，从一个新的方向实现了状态通道。它允许创建附加在以太坊主链上的子链，这些子链反过来可以产生他们自己的子链。其结果就是，我们可以在子链级别执行许多复杂的操作，运行拥有数千名用户的整个应用程序，并且只需与以太坊主链进行尽可能少的交互。子链可以更快地操作，且交易费用更低，因为它的操作不需要在整个以太坊区块链存留副本。</p><p>区别于状态通道，Plasma 中能够运行智能合约，如果说状态通道是对交易吞吐量的扩容，那么它是对计算能力的扩容。Plasma 是将计算和数据存储都迁移到 Layer 2 进行，由 Layer 2 的执行者周期性地向主链递交 Merkle 根形式的状态承诺。如果执行者递交无效的状态，用户可以向主链上的智能合约提供错误性证明（fraud proof），一旦确认执行者出现欺诈行为，智能合约会没收他的保证金。</p><p><img src="/Blockchain-scalability/8.png" alt="Plasma"></p><p>虽然说我们可以通过错误性证明，使得提供无效承诺的执行者在主链上遭到惩罚，但 Plasma 的数据并没有提交到链上，如果 Plasma 的执行者拒绝在主链上公开数据，那么用户则无法提供错误性证明，所以 Plasma 面临的最大问题是交易数据可用性。针对这个问题，Plasma 衍生出一些相应的方案，如延长资产从 Layer 2 退出的时间：当出现作恶行为，就能允许资产从 Plasma 链转移回主链。所以在 Plasma 上退出一笔资产的周期会长达一周左右，如果在争议期间没有人提交欺诈证明，那么资产才可以安全退出到主链。相比较而言，普通的侧链就没有这个安全特性。</p><h3 id="3-4-Rollup"><a href="#3-4-Rollup" class="headerlink" title="3.4 Rollup"></a>3.4 Rollup</h3><p>之前介绍的几种链下扩容方案虽然诞生时间很早，但是发展的却比较缓慢，其背后的原因归根结底是数据的可用性（Data Availability）问题。无论是状态通道还是 Plasma 侧链，完整的交易记录和见证数据都只保存在链下，出现争端时如果参与者没有及时提供正确的交易和见证数据，交易的安全性就无法保证。这时一种名为 Rollup 的方案被提了出来。</p><p><img src="/Blockchain-scalability/9.png" alt="Rollup"></p><p>Rollup 可以被认为是一种压缩技术，多笔交易可以压缩在一起（几千笔交易可以被打包到一个 Rollup 区块中），既能减少交易数据规模，又能降低交易验证负担，因此使得以太坊区块链能处理更多交易。它将所有 Layer 2 上的交易数据快照发送到主链上某个智能合约内，用主链上的单个合约来保管所有的资金，通过在主链上为每一笔交易公开一些数据，让任何人都能通过观察区块链上的 calldata（交易输入数据）来获得Layer2的所有数据。Rollup 区块的状态是由用户以及链下运营者来维护的，因此不会占用主链的存储空间。所有交易的收据都存储在以太坊区块链上，这就提升了 Layer 2 交易的安全性。具体的实现方案目前主要分为 ZK Rollup 和 Optimistic Rollup 两种。</p><h4 id="3-4-1-ZK-Rollup"><a href="#3-4-1-ZK-Rollup" class="headerlink" title="3.4.1 ZK Rollup"></a>3.4.1 ZK Rollup</h4><p>ZK Rollup 是靠着在主链完成零知识证明，链上无需包含签名数据，因为零知识证明就足以证明交易的有效与否，交易有效性就立刻确认，也即数据可用性放在链上，所以 ZK Rollup 对数据存储方面带来了一定程度上的扩展性提升。它的缺点是验证链路的构造没有一个通用的解决方案，所以目前没有很好的办法做到很广义的虚拟机逻辑，简单来说，ZK Rollup 必须对每一个用例定制，程序正确性的验证相对复杂，二层打包节点负担重，成本高，计算零知识证明所需时间长，用户延迟的体验角度仍然比较差，目前只适合简单的转账。</p><h4 id="3-4-2-Optimistic-Rollup"><a href="#3-4-2-Optimistic-Rollup" class="headerlink" title="3.4.2 Optimistic Rollup"></a>3.4.2 Optimistic Rollup</h4><p>ZK Rollup 包含一个 SNARK 零知识证明，合约用它来验证在老的用户状态上施加这批交易，但是生成 SNARK 的成本非常高，所以 Optimistic Rollup 采用了欺诈证明来验证交易有效性。Optimistic Rollup 的理念是由 John Adler 首先构想出来的，它保留了 calldata，主链可以获得所有 Layer 2 的数据，但那些刷新 Layer 2 状态的交易不会在链上被验证，只让主链存储一系列的历史状态根，添加了一个新的状态的一段时间后才将新状态最终敲定，也就是数据可用性放在链下。采用欺诈证明，对提交无效状态的执行者进行惩罚。其链下 OVM 虚拟机可以支持任意智能合约逻辑的实现，与以太坊 EVM 虚拟机搭配使用，开发者就可以用 Solidity 来写代码，实现 DApp 和智能合约之间的无缝互操作性。它的缺点是安全问题，只有使用一到两周的欺诈证明挑战期才足够安全。在挑战期过去以前，没有交易能被认为是确定的。</p><h4 id="3-4-3-比较"><a href="#3-4-3-比较" class="headerlink" title="3.4.3 比较"></a>3.4.3 比较</h4><p><img src="/Blockchain-scalability/10.png" alt="比较"></p><ul><li><ol><li>Optimistic rollup 和 ZK rollup 的主要区别在于采用了不同的数据证明方式。Optimistic rollup 使用欺诈证明：子链上的交易结果并不直接生成相关证明接入主链，子链仅向主链报告结果。如果有人发现结果错误，他们可以向链上发布一个证明，证明处理计算错误。合约将验证证明，并对结果进行更正。ZK rollup 使用零知识证明: 子链将自身交易采用 ZK-SNARK 技术生成加密证明，证明状态根是执行子链上交易的正确结果。无论计算量有多大，证明都可以在链上快速验证。</li></ol></li><li><ol start="2"><li>Optimistic Rollup 基于加密经济学有效性博弈，只有过了挑战期才能确认交易生效。ZK Rollup 的延迟相对较小，如果一个打包区块中有 1000 笔交易，在普通的服务器上大概需要 20 分钟就可以构造出一个证明。</li></ol></li><li><ol start="3"><li>通用性方面，Optimistic Rollup 明显好于 ZK Rollup，当然它的设计目标就是支持任意智能合约。而 ZK Rollup 目前仅适用于支付之类的特定交易，对于通用智能合约，由于创建零知识证明的成本非常高，部署起来困难较大。</li></ol></li></ul><p>短期看来 Optimistic Rollup 由于较好的通用性会受到开发者的青睐；但从长期来看，随着零知识证明虚拟机的演进，ZK Rollup 会在通用性上不断提高。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>状态通道有一些独特的性质，让它在扩容领域有着独特的地位，它的诸多属性在很多应用中都非常重要。比如游戏、IoT 设备网络、去中心的互联网服务提供商等。Plasma 和状态通道相比，Plasma 中能够运行智能合约，而状态通道则不被允许。分片系统要比 Plasma 链更不易于遭受拒绝服务攻击，分片链提供的防御也更易于普及。但 Plasma 链可以被迭代，新的设计可以更快地被实现，因为每条 Plasma 链都可以在无需与该生态系统中的其他链进行协调的情况下单独地进行部署，而且由单个运营商运行的 Plasma 链还可以提供比分片系统更多的隐私保护。而在分片系统中，所有的数据都是公开的。</p><p>相比于 Plasma 和ZK Rollup，Optimistic Rollup 做了一些权衡，所以带来的扩展性提升幅度最小，但 Optimistic Rollup 不依赖于什么过于前沿的技术或悬而未决的问题，所以实际推广中 Optimistic Rollup 更好落地。而 ZK Rollup 可以解决 Optimistic Rollup 上的几个根本问题，消除了令人厌恶的尾部风险（通过复杂但可行的攻击方法从 Optimistic Rollup 中盗取资金），将提取资金的时间从几周缩减到几分钟，支持快速的交易确认和退出，并且默认保护隐私。对于需要提高流动性的项目而言，资本运作效率 ZK Rollup 高于 Optimistic Rollup。</p><p>不同的扩容技术有它不同的优缺点，导致适应不同的应用场景，未来不同的扩容技术之间也会是相互合作关系，某一场景下同时使用多种扩容技术。以太坊基金会在今年1月25日宣布淘汰“以太坊 2.0”的说法，改称为“共识层”，设计人员在其中加入当下的一些先进技术，如分片技术、Casper 协议等等。相信伴随着以太坊的全面升级，其TPS必将有很大改善，但其中技术上的一些问题还有待大家共同攻坚克难。</p><p><img src="/Blockchain-scalability/11.png" alt="Eth 2.0"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 登链社区. 突破不可能三角. <a href="https://learnblockchain.cn/column/12">https://learnblockchain.cn/column/12</a>.<br>[2] Croman, K., et al. On Scaling Decentralized Blockchains (A Position Paper).<br>[3] Gangwal A, Gangavalli H R, Thirupathi A. A Survey of Layer-Two Blockchain Protocols.</p>]]></content>
    
    
    <categories>
      
      <category>理论研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Go」 各种类型相互转换</title>
    <link href="/Go-typeTransfer/"/>
    <url>/Go-typeTransfer/</url>
    
    <content type="html"><![CDATA[<p>在做 leetcode 和自己写 go 程序的时候，总是会遇到一些类型转换的问题，在这里总结一下。</p><span id="more"></span><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul><li><p>int → int64: <code>i := int64(int)</code></p></li><li><p>int → uint64: <code>ui := uint64(int)</code></p></li><li><p>int → float: <code>f := float64(int)</code></p></li><li><p>int → string: <code>str := strconv.Itoa(int)</code></p></li><li><p>int64 → string: <code>str := strconv.FormatInt(int64, 10)</code></p></li></ul><h2 id="uint"><a href="#uint" class="headerlink" title="uint"></a>uint</h2><ul><li>uint64 → string: <code>str := strconv.FormatUint(uint64, 10)</code></li></ul><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><ul><li><p>float → int: <code>i := int(float)</code></p></li><li><p>float → string: <code>str := strconv.FormatFloat(float64, &#39;E&#39;, -1, 64)</code></p></li></ul><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li><p>string → int: <code>i, err := strconv.Atoi(string)</code></p></li><li><p>string →float: <code>f, err := strconv.ParseFloat(string, 64)</code></p></li><li><p>string → bool: <code>b, err := strconv.ParseBool(&quot;true&quot;)</code></p></li><li><p>string → []byte: <code>b := []byte(string)</code></p></li></ul><h2 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h2><p>[]byte → string: <code>str := string([]byte)</code></p><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><ul><li>bool → string: <code>string := strconv.FormatBool(true)</code></li></ul><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ul><li><p>interface→int: <code>interface.(int64)</code></p></li><li><p>interface→string: <code>interface.(string)</code></p></li><li><p>interface→float: <code>interface.(float64)</code></p></li><li><p>interface→bool: <code>interface.(bool)</code></p></li></ul><h2 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> a := <span class="hljs-number">1</span><br> fmt.Println(<span class="hljs-string">&quot;a type by reflect: &quot;</span>, reflect.TypeOf(a))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Linux 使用教程</title>
    <link href="/Tutorial-Linux/"/>
    <url>/Tutorial-Linux/</url>
    
    <content type="html"><![CDATA[<p>Linux，全称 GNU&#x2F;Linux，是一种免费使用和自由传播的类 UNIX 操作系统。作为研究生，我一开始学习 Linux 的源动力自然也是任职要求上的那一条：熟悉 Linux 环境。那么 Linux 系统到底好在哪里？</p><span id="more"></span><h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><p>很多公司包括我们自己的实验室服务器都是用的 Linux 系统，其优点概括而言就是开源、免费、生态好、安全性高。</p><p>首先 Linux 系统稳定性极高且不容易染毒（从来没有听说过要装什么杀毒软件或者需要清理内存，而且我们实验室的服务器永远都不会关机），它自带的命令功能十分强大（比如你可以用简单的几行命令就搞定软件的下载安装整个步骤），还拥有开放的源代码和高度的可定制性。其次，Linux 系统的远程管理非常方便。通过 ssh 或者 telnet 的连接，在很小的带宽环境下也能很轻松实现远程操作。就如服务器摆在眼前一样的感觉。这是 windows 系统无法比拟的。</p><h2 id="Linux-发行版本"><a href="#Linux-发行版本" class="headerlink" title="Linux 发行版本"></a>Linux 发行版本</h2><p><img src="/Tutorial-Linux/1.png" alt="发行版说简单点就是将 Linux 内核与应用软件做一个打包。"></p><p>关于不同版本的安装网上教程很多，就不在此赘述。</p><h2 id="Linux-启动过程"><a href="#Linux-启动过程" class="headerlink" title="Linux 启动过程"></a>Linux 启动过程</h2><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p><ul><li><p><strong>内核的引导</strong><br>  当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</p></li><li><p><strong>运行 init</strong><br>  init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。</p></li><li><p><strong>系统初始化</strong><br>  在init的配置文件中有这么一行： <code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了 &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而 rc.sysinit 是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p></li><li><p><strong>建立终端</strong><br>  rc 执行完毕后，返回 init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。 init 接下来会打开终端，以便用户登录系统。</p></li><li><p><strong>用户登录系统</strong><br>  一般来说，用户的登录方式有三种：<br>  （1）命令行登录<br>  （2）ssh登录<br>  （3）图形界面登录</p></li></ul><p><img src="/Tutorial-Linux/2.png" alt="启动过程"></p><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><p><img src="/Tutorial-Linux/3.jpg" alt="树状目录结构"></p><blockquote><p>&#x2F;</p></blockquote><blockquote><blockquote><p>&#x2F;bin：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;boot：<br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;dev ：<br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;etc：<br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;home：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lib：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;media：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;opt：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;proc：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sbin：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;selinux：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;srv：<br> 该目录存放一些服务启动之后需要提取的数据。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;sys：<br>该文件系统是内核设备树的一个直观反映。<br>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;tmp：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;usr：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;bin：<br>系统用户使用的应用程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>&#x2F;usr&#x2F;src：<br>内核源代码默认的放置目录。</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>&#x2F;var：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></blockquote></blockquote><blockquote><blockquote><p>&#x2F;run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p></blockquote></blockquote><h2 id="Linux-权限管理"><a href="#Linux-权限管理" class="headerlink" title="Linux 权限管理"></a>Linux 权限管理</h2><p>初学 Linux 我遇到过很多次没有权限而产生的报错，之前的解决办法一直是使用 <code>su</code> 命令给自己 root 权限，注意此时命令行的 <code>$</code> 会变成 <code>#</code> 。Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown (change owner) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组</p><p><img src="/Tutorial-Linux/4.jpg" alt="文件属性及权限"></p><p>第一位表示文件的属性： <code>d</code> 是目录， <code>-</code> 是文件， <code>l</code> 表示链接文档等等。</p><p>接下来的字符中，以三个为一组，且均为 <code>rwx</code> 的三个参数的组合。</p><ul><li><code>r</code> 代表可读(read)</li><li><code>w</code> 代表可写(write)</li><li><code>x</code> 代表可执行(execute)</li><li><code>-</code> 代表没有此权限</li></ul><p>而这三组也分别对应属主（该文件的所有者）权限、属组权限、其他用户权限。</p><p>我们可以使用 chmod 更改文件上述的 9 个属性，将三组权限看作三个二进制数，开启设 1 关闭设 0 。<br>则可以使用我们常见的 <code>chmod 777 文件名</code> 来开启所有权限。</p><h2 id="Linux-用户管理"><a href="#Linux-用户管理" class="headerlink" title="Linux 用户管理"></a>Linux 用户管理</h2><p>此节是关于 Linux 的用户以及用户组管理的，我目前用的不多，请参考<a href="https://www.runoob.com/linux/linux-user-manage.html">菜鸟教程</a>。</p><h2 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h2><p>同上，请参考<a href="https://www.runoob.com/linux/linux-filesystem.html">菜鸟教程</a></p><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><ul><li>ls （list files）: 列出目录及文件名</li><li>cd （change directory）：切换目录</li><li>pwd （print work directory）：显示目前的目录</li><li>mkdir （make directory）：创建一个新的目录</li><li>rmdir （remove directory）：删除一个空的目录</li><li>cp （copy file）: 复制文件或目录</li><li>rm （remove）: 删除文件或目录</li><li>mv （move file）: 移动文件与目录，或修改文件与目录的名称</li><li>cat （concatenate）：显示文件内容或是将多个文件合并成一个文件</li><li>yum（Yellow dog Updater, Modified）：一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</li><li>apt（Advanced Packaging Tool）：一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</li></ul><p>你可以使用 man [命令] 来查看各个命令的使用文档，如： <code>man cp</code> 。此外文本编辑器 <a href="https://www.runoob.com/linux/linux-vim.html">vim</a> 也是很值得学习一下的。</p><p>我们通常会在命令后添加参数来执行更多功能，具体参数和使用方法请参考<a href="https://blog.csdn.net/weixin_66975803/article/details/123693997">这篇笔记</a>。</p><h2 id="Linux-更多命令"><a href="#Linux-更多命令" class="headerlink" title="Linux 更多命令"></a>Linux 更多命令</h2><ul><li><p><a href="https://blog.csdn.net/weixin_45004203/article/details/125885958">进程相关</a>：<code>top</code>, <code>ps</code>, <code>pidof</code>, <code>kill</code>, <code>killall</code>, <code>pkill</code></p></li><li><p>端口相关：<code>lsof -i:port</code>, <code>netstat -nltp | grep port</code></p></li></ul><h2 id="Bash-Shell"><a href="#Bash-Shell" class="headerlink" title="Bash Shell"></a>Bash Shell</h2><p>我之前一直知道 Shell 这个东西，但是对于它的认识很模糊，关于 Shell 有如下两条解释：</p><ul><li><p>Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，不启动 Shell 的话，用户就没办法使用 Linux 。</p></li><li><p>Shell是一个命令语言解释器, 在操作系统的最外层, 是用户（用户程序）与操作系统（Linux）内核的接口程序，用户输入的每个命令都由 Shell 先翻译再传给 Linux 内核, 并将处理后的结果输出至屏幕。</p></li></ul><p>常用的 Shell 功能有两种形式外在形式： GUI 和 cmdline 。</p><p>Shell 的使用方法有两种：1. 直接输入命令； 2. 使用 .sh 脚本。 对于脚本语法感兴趣的同学请学习 <a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a>。</p><p>Bash (GUN Bourne-Again Shell）是许多 Linux 发行版本默认的 Shell 。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我在这篇文章里面列出了我自己认为 Linux 中比较重要的内容，学习它的办法唯有多用，逐渐感受它的强大与可靠，你一定会理解为什么它会受到那么多公司的青睐。 Linux 上手可能会比 Windows 要困难一点，尤其是在没有装图形化界面的服务器上，各位同学不必害怕，熟能生巧，习惯以后真的非常好用。相信不久后你也可以在简历里面加上一句 “熟悉 Linux 开发环境” 了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Markdown 使用教程</title>
    <link href="/Tutorial-Markdown/"/>
    <url>/Tutorial-Markdown/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，在 2004 年由 John Gruber 创建。它允许人们使用易读易写的纯文本格式编写文档。<br>本文介绍使用 Markdown 编写博客时常用的标记符号供后续使用时参考。</p><span id="more"></span><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>使用 # 号标记，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><h2 id="Markdown-格式"><a href="#Markdown-格式" class="headerlink" title="Markdown 格式"></a>Markdown 格式</h2><p>可以实现的格式： <em>斜体文本</em> ， <strong>粗体文本</strong> ， <em><strong>粗斜体文本</strong></em> ， <del>删除线</del> ， <u>带下划线文本</u></p><p>分割线</p><hr><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套<br>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p><code>Println()</code> 函数输出 “Hello, world!” :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>欢迎访问我的 <a href="https://github.com/qanlyma">Github 仓库</a>: <a href="https://github.com/qanlyma">https://github.com/qanlyma</a></p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p><img src="/Tutorial-Markdown/love.jpg" alt="我最喜欢的彩虹六号"></p><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><table><thead><tr><th align="left">左  对  齐</th><th align="right">右  对  齐</th><th align="center">居  中  对  齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="Markdown-高级"><a href="#Markdown-高级" class="headerlink" title="Markdown 高级"></a>Markdown 高级</h2><h3 id="支持部分-HTML-元素"><a href="#支持部分-HTML-元素" class="headerlink" title="支持部分 HTML 元素"></a>支持部分 HTML 元素</h3><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><strong>文本加粗</strong><br>** 正常显示星号 **</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「学」 Hexo 基础命令</title>
    <link href="/Tutorial-Hexo/"/>
    <url>/Tutorial-Hexo/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建新网站"><a href="#创建新网站" class="headerlink" title="创建新网站"></a>创建新网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><h3 id="清除缓存文件"><a href="#清除缓存文件" class="headerlink" title="清除缓存文件"></a>清除缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h3 id="在本地启动-hexo"><a href="#在本地启动-hexo" class="headerlink" title="在本地启动 hexo"></a>在本地启动 hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
